var APNVideo_VmapVastPlugin =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * VMAP Plugin Brightcove module.
	 */

	//////////////////////////////////////////////////////////////////////
	// CONSTANTS

	var _vjs = videojs;
	var _vmapManager = __webpack_require__(1);
	var _vastManager = __webpack_require__(32);
	var _vastArrayManager = __webpack_require__(35);
	var _logger = __webpack_require__(3);
	var _prefix = 'apnVmapVast';
	//var _uaParser = require('@appnexus/videoads-util-user-agent-parser');

	_logger.always(_prefix, 'Version 1.2.7');

	function registerVmapVastPlugin() {
		//_vjs = vjs;
		/*var _player;
		var _vmapManagerObj;
		var _vastManagerObj;
		var _ua = _uaParser();
		_vjs.registerPlugin('apnVmapVastPlugin', function(options) {
			_player = this;
			if (!options || !options.apnTagParams) {
				_logger.error(_prefix, "Invalid parameter 'options': ", options);
				return;
			}
			
	    	//if (!_ua.device.type && !_ua.device.model) {
	    	//	// hide big play button for desktop
	    	//	_player.bigPlayButton.el_.style.display = 'none';
	    	//}
			if (options.vmapEnabled) {
				_vmapManagerObj = new _vmapManager();
				_vmapManagerObj.play(_player, options);
			}
			else {
				_vastManagerObj = new _vastManager();
				_vastManagerObj.play(_player, options);
			}
		});*/	
		
		_vjs.registerPlugin('apnVmapVastPluginCommand', function(command, data) {
			if (command === 'stop') {
				if (_vmapManagerObj) {
					_vmapManagerObj.stop();
				}
				else if (_vastManagerObj) {
					_vastManagerObj.stop();
				}
			}
			else if (command === 'insertAdBreak') {
				if (!_player) {
					_player = this;
				}
				if (!data || !data.apnTagParams) {
					_logger.error(_prefix, "Invalid parameter 'data': ", data);
					return;
				}
				if (!_vmapManagerObj) {
					_vmapManagerObj = new _vmapManager();
				}
				_vmapManagerObj.play(_player, data);
			}
		});
	}

	var vmapVastPlugin = {
				
			init : function () {
				registerVmapVastPlugin();
			},
			
			id: null,
			
			play: function(options, id) {
				this.id = id;
				_vjs(id).apnVmapVastPlugin(options);
			},
			
			stop: function() {
				_vjs(this.id).apnVmapVastPluginCommand('stop');
			},
			
			insertAdBreak: function(id, options, breakTime) {
				this.id = id;
				options.breakTime = breakTime;
				_vjs(this.id).apnVmapVastPluginCommand('insertAdBreak', options);
			}		
	};
	//////////////////////////////////////////////////////////////////////
	// EXPORTS
	module.exports = vmapVastPlugin;
	/*module.exports = {
			
		init : function () {
			registerVmapVastPlugin(videojs);
		},
		
		id: null,
		
		play: function(options, id) {
			this.id = id;
			_vjs(id).apnVmapVastPlugin(options);
		},
		
		stop: function() {
			_vjs(this.id).apnVmapVastPluginCommand('stop');
		},
		
		insertAdBreak: function(id, options, breakTime) {
			this.id = id;
			options.breakTime = breakTime;
			_vjs(this.id).apnVmapVastPluginCommand('insertAdBreak', options);
		}
	};*/

	// test
	var _player;
	var _vmapManagerObj;
	var _vastManagerObj;
	videojs.registerPlugin('apnVmapVastPlugin', function(options) {
		_player = this;
		if (!options || !options.apnTagParams) {
			//_logger.error(_prefix, "Invalid parameter 'options': ", options);
			return;
		}
		
		if (options.vmapEnabled) {
			_vmapManagerObj = new _vmapManager();
			_vmapManagerObj.play(_player, options);
		}
		else {
			if (Array.isArray(options.apnTagParams)) {
				_vastManagerObj = new _vastArrayManager();
				_vastManagerObj.play(_player, options);
			}
			else {
				_vastManagerObj = new _vastManager();
				_vastManagerObj.play(_player, options);
			}
		}
	});
	window.APNVideo_VmapVastPlugin = vmapVastPlugin;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	var _markersHandler = __webpack_require__(2);
	var _breakManager = __webpack_require__(4);
	var _ImpbusCommunicator = __webpack_require__(17);
	var _vmapParser = __webpack_require__(24);
	var _utils = __webpack_require__(16);
	var _xmlParserHelper = __webpack_require__(18);
	var _logger = __webpack_require__(3);
	var _uaParser = __webpack_require__(9);

	var _prefix = 'apnVmapVast->vmapManager';

	var vmapManager = function () {
		var _ua = _uaParser();
		var _preparationDone = false;
		var _player;
		var _options;
		var _helper = new _xmlParserHelper();
		var _impbusCommunicator = new _ImpbusCommunicator();
		
		var _cover = document.getElementById('apn-break-cover');
		var _spinnerDiv = document.getElementById('apn-break-spinner');

		var _needsResetData = false;
		
		var _adBreaks = [];
		var _breakPlaying = false;
		var _playingBreakIdx = -1;
		var _snapshot;
		var _savedMarkers;
		var _newMarkerSeconds;
		var _markersHandlerObj;
		var _contentDuration;
		
		var _playlist = [];
		var _playlistIdx = -1;
		var _playlistBreaks = null;
		var _nextPlaylistItemFired = false;

		var _lastBreakTime = 0;
		var _source;
		var _canReplayPreroll = false;
		
		function showCover(show) {
			_logger.log(_prefix, (show ? "Show" : "Hide") + " ad cover with spinner");
			if (show) {
	    		_cover.style.display = 'block';
	     		_player.el().classList.add('vjs-waiting');
			}
			else {
	    		_cover.style.display = 'none';
	    		_player.el().classList.remove('vjs-waiting');
			}
		}
		
		function modifyVastXmlsInVmapObject(vmapObj) {
			for (var i = 0; i < vmapObj.adBreaks.length; i++) {
				if (_options.breakTime) {
					vmapObj.adBreaks[i].timeOffset = _options.breakTime;
				}
				if (vmapObj.adBreaks[i].adSource && vmapObj.adBreaks[i].adSource.vastData) {
					for (var sequence in vmapObj.adBreaks[i].adSource.vastData) {
						var vastObjSequence = vmapObj.adBreaks[i].adSource.vastData[sequence];
						if (Array.isArray(vastObjSequence) && vastObjSequence.length > 0) {
							for (var j = 0; j <  vastObjSequence.length; j++) {
								var vastObj = vastObjSequence[j];
					    		if (vastObj.vastXml && _options && _options.skippable) {
					    			// update skipOffset in vastXml
					    			var xmlDoc = (new DOMParser()).parseFromString(vastObj.vastXml, 'text/xml');
					    			var linear = _helper.getSubNode(xmlDoc, 'Linear', 0);
					    			if (linear) {
					    				// remove skippOffset attribute
					    				linear.removeAttribute('skipoffset');
					    				if (_options.skippable.enabled) {
						    				var node = _helper.getSubNode(linear, 'Duration');
						    				var str = _helper.getNodeValue(node);
						    				var duration = _utils.convertStringToMseconds(str);
						    				if (duration && duration >= _options.skippable.videoThreshold * 1000) {
						    					vastObj.durationMsecs = duration;
						    					vastObj.skipOffset = _utils.convertSecsToString(_options.skippable.videoOffset);
						    				}
						    				else {
							    				if (vastObj.skipOffset) {
							    					delete vastObj.skipOffset;
							    				}
						    				}
					    				}
						    			else {
						    				if (vastObj.skipOffset) {
						    					delete vastObj.skipOffset;
						    				}
						    			}
					    				if (vastObj.skipOffset) {
					    					// add new skipoffset attribute if needed 
					                        var attr = xmlDoc.createAttribute('skipoffset');
					                        attr.value = vastObj.skipOffset;
					                        linear.setAttributeNode(attr);
					    				}
					    				vastObj.vastXml = (new XMLSerializer()).serializeToString(xmlDoc);
					    			}
					    		}
							}
						}
					}
				}
			}
		}
		
		function parseVmapXmls(arrXml, callback) {
			var vmapObjects = [];
			var count = 0;
			
			for (var i = 0; i < arrXml.length; i++) {
				var parserCallbackWrapper = function(idx) {
					return function(succ, data, arrErrorUrls) {
						count++;
						var url = arrXml[idx].url;
						if (succ) {
							_logger.log(_prefix, 'Successfully parsed VMAP xml from ' + url);
							modifyVastXmlsInVmapObject(data);
							vmapObjects.push(data);
						}
						else {
							
							_logger.log(_prefix, 'Failed to parse VMAP xml from ' + url);
							if (arrErrorUrls && arrErrorUrls.length > 0) {
								_utils.trackUrls(arrErrorUrls);
							}
						}
						if (count >= arrXml.length) {
							callback(vmapObjects);
						}
					};
				};
				if (_options.timeouts) {
					if (_options.timeouts.adServerTimeout) {
						_options.adServerTimeout = _options.timeouts.adServerTimeout;
						_vmapParser.parse(arrXml[i].xml, parserCallbackWrapper(i), null, _options);
					}
					else {
						_vmapParser.parse(arrXml[i].xml, parserCallbackWrapper(i), _options.timeouts.adCallTimeout, _options);
					}
				}
				else {
					_vmapParser.parse(arrXml[i].xml, parserCallbackWrapper(i), null, _options);
				}
			}
		}
		
		function afterParseVmapXmls(vmapObjects) {
			// merge all vmap objects into one vmap object
			if (vmapObjects.length > 0) {
				var vmapObject = vmapObjects[0];
				for (var i = 1; i < vmapObjects.length; i++) {
					vmapObject = _vmapParser.mergeVmapData(vmapObject, vmapObjects[i]);
				}
				_logger.debug(_prefix, 'VMAP data for rendering: ', vmapObject);
				prepareBreakInstances(vmapObject);
			}
			else {
				showCover(false);
				_logger.warn(_prefix, 'No VMAP data is available.');
				_preparationDone = true;
				_player.play();
			}
		}
		
		function insertSingleXML(sXml) {
			var singleVmapObject = {};
			singleVmapObject.adBreaks = [];
			singleVmapObject.adBreaks.push({timeOffset: _options.breakTime, xml: sXml});
			prepareBreakInstances(singleVmapObject);
		}
		
		function prepareBreakInstances(vmapObject) {
			if (Array.isArray(vmapObject.adBreaks) && vmapObject.adBreaks.length > 0) {
			    var timeMarkers = {
				    	markerStyle: {
				    		'width': '5px',
				    		'border-radius': '10%',
				    		'background-color': 'white'
				    	},
						markerTip: {
							display: false
						},
				    	onMarkerReached: function(marker) {
				    		startBreak(marker.time);
				    	},
				    	markers: [],
				    	metadataLoaded: true
				    };
			    
			    var prepareBreakArray = function() {
			    	if (!_contentDuration) {
			    		_contentDuration = _player.duration();
					}
					var hasPreroll = false;
			    	var duration = _contentDuration;
			    	var seconds;
					for (var i = 0; i < vmapObject.adBreaks.length; i++) {
						var adBreak = vmapObject.adBreaks[i];
						var currentTime = _player.currentTime();
						if (_snapshot) {
							currentTime = _snapshot.currentTime;
						}
						seconds = _utils.convertStringToSeconds(adBreak.timeOffset, duration, currentTime);
						if (seconds !== null && seconds <= duration) {
							if (seconds === duration) {
								seconds = parseInt(duration + 0.5);
							}
							var bFound = false;
							for (var j = 0; j < timeMarkers.markers.length; j++) {
								if (timeMarkers.markers[j].time === seconds) {
									bFound = true;
									break;
								}
							}
							if (bFound) {
								// break at particular time already exist
								continue;
							}
							var adBreakTime = {time: seconds, played: false, adBreak: adBreak};
							if (seconds >= 0) {
								timeMarkers.markers.push({time: seconds});
								if (seconds < 1) {
									hasPreroll = true;
								}
							}
							_adBreaks.push(adBreakTime);
						}
					}
					if (timeMarkers.markers.length > 0) {
					    _adBreaks.sort(function(a, b) {
					    	return a.time - b.time;
					    });
					    if (_options.breakTime && _adBreaks.length > 1) {
					    	// add new break
					    	if (!_breakPlaying) {
						    	_player.markers.add(timeMarkers.markers);
					    	}
					    	else {
						    	_newMarkerSeconds = seconds;
					    	}
					    }
					    else {
					    	// initialize markers for all breaks
							if (_markersHandler && _player.markers && _player.markers.destroy) {
								_player.markers.destroy();
							}
							if (!_markersHandlerObj) {
								_markersHandlerObj = new _markersHandler(videojs);
							}
						    _markersHandlerObj.init(_player);
						    _markersHandlerObj.markers(timeMarkers);
					    }
					}
	    			_preparationDone = true;
	    			if (_options.playerSettings.autostart) {
	        			_player.play();
					}
					
					if (!hasPreroll) {
						showCover(false);
					}
	    			
	    			if (_options.replayAdBreak) {
	    				// VIDLA-2319 - support break replay functionality
	    				_source = _player.currentSource().src;
	    				_canReplayPreroll = false;
		    		    _player.on('seeked', function() {
		    		    	if (!_breakPlaying && _source === _player.currentSource().src) {
		    		    		if (_player.markers) {
		    		    			_player.markers.allowReplay();
		    		    		}
		    		    		prepareBreaksForReplay();
		    		    	}
		    		    });
		    		    _player.on('timeupdate', function() {
		    		    	if (_source === _player.currentSource().src) {
			    		    	if (!_canReplayPreroll && !_breakPlaying && _player.currentTime() > 2) {
			    		    		_canReplayPreroll = true;
			    		    	}
		    		    	}
		    		    });
	    			}
			    };
			    
			    if (_contentDuration || (!_contentDuration && _player.duration() > 0)) {
			    	prepareBreakArray();
			    }
			    else {
			    	_player.one("loadedmetadata",prepareBreakArray);
				}
				if (_player.playlist && _player.playlist.autoadvance) {
					_player.playlist.autoadvance(null);
				}
			}
			else {
				_logger.warn(_prefix, 'VMAP object does not contain breaks.');
				_preparationDone = true;
				_player.play();
				if (_player.playlist && _player.playlist.autoadvance) {
					_player.playlist.autoadvance(0);
				}
			}
		}
		
		// VIDLA-2319 - support break replay functionality
		function prepareBreaksForReplay() {
			var playerCurTime = _player.currentTime();
			_logger.log(_prefix, 'Seeked event: player time = ' + playerCurTime + ', last break time = ' + _lastBreakTime);
	    	//if (playerCurTime <= _lastBreakTime) {
				_logger.log(_prefix, 'Seeked back event happened');
				for (var i = 0; i < _adBreaks.length; i++) {
					if (_adBreaks[i].time >= playerCurTime && _adBreaks[i].played) {
						if (_adBreaks[i].time === 0) {
							// pre-roll
		    				_logger.log(_prefix, 'Seeked event: can replay preroll = ' + _canReplayPreroll);
							if (_canReplayPreroll) {
								_canReplayPreroll = false;
	    						_adBreaks[i].played = false;
	    						_adBreaks[i].breakObj = null;
							}
						}
						else if ((_player.duration() - _adBreaks[i].time) < 2) {
							// post-roll
							if ((_adBreaks[i].time - playerCurTime) > 2) {
	    						_adBreaks[i].played = false;
	    						_adBreaks[i].breakObj = null;
							}
						}
						else {
							// mid-roll
							if (_adBreaks[i].time > playerCurTime) {
	    						_adBreaks[i].played = false;
	    						_adBreaks[i].breakObj = null;
							}
						}
					}
				}
	    	//}
		}
		
		function getBreakIndex(breakTime, cuePoint) {
			var i;
			if (breakTime === null) {
				if (cuePoint) {
					for (i = _adBreaks.length - 1; i >= 0; i--) {
						if (_adBreaks[i].time < 0 && !_adBreaks[i].played) {
							return i;
						}
					}
				}
				else {
					for (i = 0; i < _adBreaks.length; i++) {
						if (_adBreaks[i].time >= 0 && !_adBreaks[i].played) {
							return i;
						}
					}
				}
			}
			else {
				for (i = 0; i < _adBreaks.length; i++) {
					if (_adBreaks[i].time === breakTime && !_adBreaks[i].played) {
						return i;
					}
				}
			}
			return null;
		}
		
		function getBreakByBreakId(breakId) {
			for (var i = 0; i < _adBreaks.length; i++) {
				if (_adBreaks[i].adBreak.breakId === breakId) {
					return _adBreaks[i];
				}
			}
			return null;
		}
		
		function removeBrightcodeErrorDialog() {
			var elements = document.getElementsByClassName('vjs-error-display');
			if (elements && elements.length > 0) {
				var elem = elements[0];
				if (elem) {
					elem.parentNode.removeChild(elem);
				}
			}
		}

		function startBreak(breakTime) {
			_logger.log(_prefix, 'startBreak called. Break time: ' + breakTime);
			showCover(false);
			if (_breakPlaying) {
				// not interrupt playing break
				_logger.log(_prefix, 'startBreak called. Break are playing right now');
				return;
			}
			_player.off('ended', mainContentEnded);
			removeBrightcodeErrorDialog();
			_playingBreakIdx = -1;
			// VIDLA-2319 - support break replay functionality
			if (_options.replayAdBreak) {
				prepareBreaksForReplay();
			}
			var idx = getBreakIndex(breakTime, false);
			if (idx !== null && !_adBreaks[idx].played) {
	    		//_snapshot = _utils.getPlayerSnapshot(_player);
				//_player.pause();		// pause main content
				_playingBreakIdx = idx;
				_breakPlaying = true;
				if (!_adBreaks[idx].breakObj) {
				    _adBreaks[idx].breakObj = new _breakManager(_adBreaks[idx].adBreak, _player, _options, breakNotificationCallback);
				}
				// save markers
	    		if (_markersHandler) {
	      	  		_savedMarkers = JSON.stringify(_player.markers.getMarkers());
	      	  		_player.markers.removeAll();
	    		}
	   			_adBreaks[idx].played = true;
	   			_lastBreakTime = breakTime;
	   			if (breakTime !== 0) {
	   				_options.playerSettings.autostart = true;
	   				_options.playerSettings.muted = _player.muted();
	   			}
				var needWaitForStartContent = (breakTime === 0) && (_ua.device.type || _ua.device.model);
				if (needWaitForStartContent && _player.playlist && typeof _player.playlist === 'function') {
					if (_player.playlist.currentIndex() > 0) {
						needWaitForStartContent = false;
					}
				}
				if (needWaitForStartContent) {
					setTimeout(function() {
						_player.pause();
						_player.bigPlayButton.el_.style.display = 'block';
						_player.one('play', function() {
							_snapshot = _utils.getPlayerSnapshot(_player);
							_player.pause();		// pause main content
							_adBreaks[idx].breakObj.start();
						});
					}, 500);
				}
				else {
		    		_snapshot = _utils.getPlayerSnapshot(_player);
					_player.pause();		// pause main content
					_adBreaks[idx].breakObj.start();
				}
			}
			else {
				_logger.log(_prefix, 'Break time: ' + breakTime + ' already played or not exist.');
			}
			if (!_playlistBreaks) {
				getXmlsForNextPlaylistItem();
			}
		}

		function mainContentEnded() {
			setTimeout(function() {
				if (!_nextPlaylistItemFired && _playlistBreaks && !_breakPlaying) {
					_player.playlist.next();
				}
			}, 500);
		}
		
		function resetContent() {
			_player.one('tryToResumeDone', function() {
				_breakPlaying = false;
				_nextPlaylistItemFired = false;
				// make sure we are waiting for event 'ended' on main content 
				var delay = _player.currentTime() < (_player.duration() - 3) ? 2000 : 0;
				_logger.log(_prefix, 'Activate ended event delay = ' + delay);
				if (delay === 0) {
					if (_playlistBreaks && _playlist.length > 0 && _player.playlist.currentIndex() < (_playlist.length - 1)) {
						_player.one('ended', mainContentEnded);
					}		
				}
				else {
					setTimeout(function() {
						if (_playlistBreaks && _playlist.length > 0 && _player.playlist.currentIndex() < (_playlist.length - 1)) {
							_player.one('ended', mainContentEnded);
						}		
					}, delay);
				}
			});
			_utils.restorePlayerSnapshot(_player, _snapshot);
			_snapshot = null;
			_utils.showNextOverlay(true);
			setTimeout(function() {
				_breakPlaying = false;
				if (_savedMarkers) {
					var markers = JSON.parse(_savedMarkers);
					if (_newMarkerSeconds) {
						// add new marker
						markers.push({time: _newMarkerSeconds});
						_newMarkerSeconds = null;
					}
					if (_player.markers && _player.markers.reset) {
						_player.markers.reset(markers);
					}
				}
				if (_player.paused() && _player.currentTime() === 0) {
					_player.bigPlayButton.el_.style.display = 'block';
					_player.one('playing', function() {
						_player.bigPlayButton.el_.style.display = 'none';
					});
				}
			}, 1000);
		}
		
		function getXmlsForNextPlaylistItem() {
			_playlist = (_player.playlist && typeof _player.playlist === 'function') ? _player.playlist() : [];
			if (!_playlist) {
				_playlist = [];
			}
			if (_playlist.length > 1 && _player.playlist.currentIndex() < (_playlist.length - 1)) {
				if (!_playlistBreaks) {
					_impbusCommunicator.getXML(_options, _player, function(arrXml) {
						if (!arrXml) {
							_logger.error(_prefix, 'Error to get VMAP xml(s) for next playlist item.');
						}
						else {
							if (Array.isArray(arrXml)) {
								parseVmapXmls(arrXml, function(vmapObjects) {
									// merge all vmap objects into one vmap object
									if (vmapObjects.length > 0) {
										_playlistBreaks = vmapObjects[0];
										for (var i = 1; i < vmapObjects.length; i++) {
											_playlistBreaks = _vmapParser.mergeVmapData(_playlistBreaks, vmapObjects[i]);
										}
										_logger.debug(_prefix, 'VMAP data for rendering next playlist item: ', _playlistBreaks);
									}
									else {
										_logger.warn(_prefix, 'No VMAP data is available for next playlist item.');
									}
								});
							}
							else {
								if (arrXml) {
									_playlistBreaks = {};
									_playlistBreaks.adBreaks = [];
									_playlistBreaks.adBreaks.push({timeOffset: _options.breakTime, xml: arrXml});
								}
								else {
									_logger.warn(_prefix, 'No VMAP data is available for next playlist item.');
								}
							}
						}
					});
				}
			}
			else {
				_player.off('playlistitem', nextListItemHandler);
			}
		}

		function nextListItemHandler() {
			_logger.log(_prefix, 'playlistitem is fired');
			showCover(true);
			_nextPlaylistItemFired = true;
			_playlistIdx++;
			_contentDuration = 0;
			if (_markersHandler && _player.markers && _player.markers.destroy) {
				_player.markers.destroy();
			}
			_player.one('loadedmetadata', function() {
				if (_playlistBreaks) {
					prepareBreakInstances(_playlistBreaks);
					_playlistBreaks = null;
				}
				else {
					_impbusCommunicator.getXML(_options, _player, function(arrXml) {
						if (!arrXml) {
							showCover(false);
							_logger.error(_prefix, 'Error to get VMAP xml(s) for next playlist item.');
						}
						else {
							if (Array.isArray(arrXml)) {
								parseVmapXmls(arrXml, function(vmapObjects) {
									// merge all vmap objects into one vmap object
									if (vmapObjects.length > 0) {
										_playlistBreaks = vmapObjects[0];
										for (var i = 1; i < vmapObjects.length; i++) {
											_playlistBreaks = _vmapParser.mergeVmapData(_playlistBreaks, vmapObjects[i]);
										}
										_logger.debug(_prefix, 'VMAP data for rendering next playlist item: ', _playlistBreaks);
										prepareBreakInstances(_playlistBreaks);
										_playlistBreaks = null;
									}
									else {
										showCover(false);
										_logger.warn(_prefix, 'No VMAP data is available for next playlist item.');
										_player.play();
									}
								});
							}
							else {
								if (arrXml) {
									_playlistBreaks = {};
									_playlistBreaks.adBreaks = [];
									_playlistBreaks.adBreaks.push({timeOffset: _options.breakTime, xml: arrXml});
									prepareBreakInstances(_playlistBreaks);
									_playlistBreaks = null;
								}
								else {
									showCover(false);
									_logger.warn(_prefix, 'No VMAP data is available for next playlist item.');
									_player.play();
								}
							}
						}
					});
				}
			});
		}

		function breakNotificationCallback(breakId, notificationObj) {
			var adBreak = getBreakByBreakId(breakId);
			if (adBreak) {
				_logger.log(_prefix, 'Notification ' + notificationObj.name + ' from break ' + breakId);
				switch (notificationObj.name) {
				case "BreakStarted":
					_breakPlaying = true;
					_utils.showNextOverlay(false);
					break;
				case "BreakComplete":
					resetContent();
					break;
				case "BreakError":
					resetContent();
					break;
				case "BreakStopped":
					resetContent();
					break;
				case "BreakAdStarted":
					_utils.showNextOverlay(false);
					break;
				case "BreakAdComplete":
					break;
				case "BreakAdError":
					break;
				case "BreakAdStopped":
					if (_needsResetData) {
						_needsResetData = false;
						_adBreaks = [];
						setTimeout(function() {
							resetContent();
						}, 1);
					}
					break;
				default:
					_logger.warn(_prefix, 'Unknown notification ' + notificationObj.name + ' from break ' + breakId);
				}
			}
		}
		
		function requestImpbus() {
			showCover(true);
	    	_impbusCommunicator.getXML(_options, _player, function(arrXml) {
	    		if (!arrXml) {
					showCover(false);
	    			_logger.error(_prefix, 'Error to get VMAP xml(s).');
	    			_preparationDone = true;
	    			if (_options.playerSettings.autostart) {
						if (_ua.device.type || _ua.device.model) {
							_player.bigPlayButton.el_.style.display = 'block';
							_player.one('play', function() {
								_player.bigPlayButton.el_.style.display = 'none';
							});
						}
						else {
							_player.play();
						}
	    			}
	    			else {
	    	    		_player.bigPlayButton.el_.style.display = 'block';
	    			}
	    		}
	    		else {
	    			if (Array.isArray(arrXml)) {
	        			// parse all VMAP xmls
	        			parseVmapXmls(arrXml, afterParseVmapXmls);
	    			}
	    			else {
	    				insertSingleXML(arrXml);
	    			}
	    		}
	    	});
		}

		this.play = function (vjsPlayer, options) {
	    	_player = vjsPlayer;
			_options = options;	  
	    	
	    	// get player autostart and audio settings
	    	_options.playerSettings = {};
	    	_options.playerSettings.autostart = _player.currentTime() === 0 ? _player.autoplay() : !_player.paused();
	    	_options.playerSettings.muted = _player.muted();
	    	
			// initialize graphics 
			if (!_cover) {
				_cover = document.createElement('div');
				_cover.id = 'apn-break-cover';
				_cover.style.width = '100%';
				_cover.style.height = '100%';
				_cover.style.backgroundColor = 'black';
				_cover.style.position = 'absolute';
				_cover.style.zIndex = 101;
				_player.el().appendChild(_cover);
			}
			_cover.style.display = 'none';
			if (!_spinnerDiv) {
				_spinnerDiv = document.createElement('div');
				_spinnerDiv.id = 'apn-break-spinner';
				_spinnerDiv.className = 'vjs-loading-spinner';
				_cover.appendChild(_spinnerDiv);
			}

			_player.bigPlayButton.el_.style.opacity = 1;
	    	if (!_ua.device.type && !_ua.device.model && _options.playerSettings.autostart) {
				// hide big play button for desktop
				_player.bigPlayButton.el_.style.display = 'none';
			}
	    	if (_player.duration() > 0) {
	    		// main content passible playing
				_player.pause();
				_player.on('playlistitem', nextListItemHandler);
				requestImpbus();
	    	}
	    	else {
				showCover(true);
	    		if (_ua.device.type || _ua.device.model) {
					// mobile
					_options.playerSettings.autostart = true;
					_options.playerSettings.muted = _player.muted();
					if (_player.autoplay() === true) {
						_player.autoplay('any');
					}

					if (!_preparationDone) {
						_player.pause();
					}
					requestImpbus();
					_player.one('loadedmetadata', function() {
						_player.on('playlistitem', nextListItemHandler);
					});
				}
				else {
					// desktop
					setTimeout(function() {
						if (_player.paused() && _player.bigPlayButton.el_.style.display !== 'block' && !_breakPlaying) {
							showCover(false);
							_player.bigPlayButton.el_.style.display = 'block';
							_player.bigPlayButton.one('click', function() {
								_player.bigPlayButton.el_.style.display = 'none';
							});
						}	
					}, 1000);
					_player.one('playing', function() {
						if (_player.paused()) {
							showCover(false);
							_player.bigPlayButton.el_.style.display = 'block';
							_player.bigPlayButton.one('click', function() {
								_player.bigPlayButton.el_.style.display = 'none';
								requestImpbus();
							});
						}
						else {
							_player.bigPlayButton.el_.style.display = 'none';
							requestImpbus();
						}
						if (!_preparationDone) {
							_player.pause();
						}
						_player.on('playlistitem', nextListItemHandler);
					});
				}
	    	}
	    };
	    
	    this.stop = function() {
	    	if (_breakPlaying) {
	    		_needsResetData = true;
	    		_adBreaks[_playingBreakIdx].breakObj.stop();
	    	}
	    	else {
	    		_adBreaks = [];
	    	}
	    	_savedMarkers = null;
			if (_markersHandler) {
	  	  		_player.markers.destroy();
			}
	    };

	};

	module.exports = vmapManager;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	var _logger = __webpack_require__(3);
	var _prefix = 'apnVmapVast->MarkersHandler';

	var markersHandler = function (vjs) {
		var _vjs = vjs;
		var _player = null;
		
		// default setting
		var defaultSetting = {
			markerStyle: {
				'width': '7px',
				'border-radius': '30%',
				'background-color': 'red'
			},
			markerTip: {
				display: true,
				text: function text(marker) {
					return (marker && marker.text) ? ("Break: " + marker.text) : '';
				},
				time: function time(marker) {
					return marker.time;
				}
			},
			breakOverlay: {
				display: false,
				displayTime: 3,
				text: function text(marker) {
					return "Break overlay: " + marker.overlayText;
				},
				style: {
					'width': '100%',
					'height': '20%',
					'background-color': 'rgba(0,0,0,0.7)',
					'color': 'white',
					'font-size': '17px'
			    }
			},
			onMarkerClick: function onMarkerClick() {},
			onMarkerReached: function onMarkerReached() {},
			markers: []
		};

		// create a non-colliding random number
		function generateUUID() {
			var d = new Date().getTime();
			var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
				var r = ((d + Math.random() * 16) % 16) | 0;
				d = Math.floor(d / 16);
				return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);
			});
			return uuid;
		}

		var NULL_INDEX = -1;

		var markers = function(options) {
			var player = _player;

		    /**
		     * register the markers plugin (dependent on jquery)
		     */
		    var setting = _vjs.mergeOptions(defaultSetting, options),
		        markersMap = {},
		        markersList = [],
		        // list of markers sorted by time
		    currentMarkerIndex = NULL_INDEX,
		        markerTip = null,
		        breakOverlay = null,
		        overlayIndex = NULL_INDEX;

		    function sortMarkersList() {
		      // sort the list by time in asc order
		      markersList.sort(function (a, b) {
		        return setting.markerTip.time(a) - setting.markerTip.time(b);
		      });
		    }

		    function addMarkers(newMarkers) {
		      newMarkers.forEach(function (marker) {
						marker.key = generateUUID();
						
						marker.reacheTime = marker.time;
						_logger.log(_prefix, 'marker.reacheTime = ' + marker.reacheTime);
						marker.time = parseInt(marker.time + 0.5);

		        player.el().querySelector('.vjs-progress-holder').appendChild(createMarkerDiv(marker));

						// store marker in an internal hash map
						if (marker.reacheTime >= player.duration()) {
							marker.time = player.duration() - 0.6;
						}
						else {
							marker.time = marker.reacheTime;
						}
						_logger.log(_prefix, 'in markerList marker.time = ' + marker.time);
		        markersMap[marker.key] = marker;
		        markersList.push(marker);
		      });

		      sortMarkersList();
		    }
		    

		    function getPosition(marker) {
		      return setting.markerTip.time(marker) / player.duration() * 100;
		    }

		    function createMarkerDiv(marker) {
		      var markerDiv = _vjs.dom.createEl('div', {
		        className: 'vjs-marker ' + (marker.class || "")
		      }, {
		        'data-marker-key': marker.key,
		        'data-marker-time': setting.markerTip.time(marker)
		      });

		      Object.keys(setting.markerStyle).forEach(function (key) {
		        markerDiv.style[key] = setting.markerStyle[key];
		      });
		      var pos = getPosition(marker);
		      if (pos >= 100) {
		    	  pos = 99.5;
		      }
					_logger.log(_prefix, 'marker.time = ' + marker.time + ', position = ' + pos + '%');
		      markerDiv.style.left = pos + '%';
		      try {
			      var rect = markerDiv.getBoundingClientRect();
			      markerDiv.style.marginLeft = rect.width / 2 + 'px';
		      }
		      catch(e) {}

		      // bind click event to seek to marker time
		      markerDiv.addEventListener('click', function () {
		        var preventDefault = false;
		        if (typeof setting.onMarkerClick === "function") {
		          // if return false, prevent default behavior
		          preventDefault = setting.onMarkerClick(marker) === false;
		        }

		        if (!preventDefault) {
		          var key = this.getAttribute('data-marker-key');
		          player.currentTime(setting.markerTip.time(markersMap[key]));
		        }
		      });

		      if (setting.markerTip.display) {
		        registerMarkerTipHandler(markerDiv);
		      }

		      return markerDiv;
		    }

		    function updateMarkers() {
		      // update UI for markers whose time changed
		      markersList.forEach(function (marker) {
		        var markerDiv = player.el().querySelector(".vjs-marker[data-marker-key='" + marker.key + "']");
		        var markerTime = setting.markerTip.time(marker);

		        if (markerDiv.getAttribute('data-marker-time') !== markerTime) {
		          markerDiv.style.left = getPosition(marker) + '%';
		          markerDiv.setAttribute('data-marker-time', markerTime);
		        }
		      });
		      sortMarkersList();
		    }

		    function removeMarkers(indexArray) {
		      // reset overlay
		      if (!!breakOverlay) {
		        overlayIndex = NULL_INDEX;
		        breakOverlay.style.visibility = "hidden";
		      }
		      currentMarkerIndex = NULL_INDEX;

		      var deleteIndexList = [];
		      indexArray.forEach(function (index) {
		        var marker = markersList[index];
		        if (marker) {
		          // delete from memory
		          delete markersMap[marker.key];
		          deleteIndexList.push(index);

		          // delete from dom
		          var el = player.el().querySelector(".vjs-marker[data-marker-key='" + marker.key + "']");
		          el.parentNode.removeChild(el);
		        }
		      });

		      // clean up markers array
		      deleteIndexList.reverse();
		      deleteIndexList.forEach(function (deleteIndex) {
		        markersList.splice(deleteIndex, 1);
		      });

		      // sort again
		      sortMarkersList();
		    }

		    // attach hover event handler
		    function registerMarkerTipHandler(markerDiv) {
		      markerDiv.addEventListener('mouseover', function () {
		        var marker = markersMap[markerDiv.getAttribute('data-marker-key')];
		        if (!!markerTip) {
		          markerTip.querySelector('.vjs-tip-inner').innerText = setting.markerTip.text(marker);
		          // margin-left needs to minus the padding length to align correctly with the marker
		          markerTip.style.left = getPosition(marker) + '%';
		          markerTip.style.marginLeft = -parseFloat(markerTip.getBoundingClientRect().width / 2) + parseFloat(markerDiv.getBoundingClientRect().width / 4) + 'px';
		          markerTip.style.visibility = 'visible';
		        }
		      });

		      markerDiv.addEventListener('mouseout', function () {
		        if (!!markerTip) {
		          markerTip.style.visibility = "hidden";
		        }
		      });
		    }

		    function initializeMarkerTip() {
		      markerTip = _vjs.dom.createEl('div', {
		        className: 'vjs-tip',
		        innerHTML: "<div class='vjs-tip-arrow'></div><div class='vjs-tip-inner'></div>"
		      });
		      player.el().querySelector('.vjs-progress-holder').appendChild(markerTip);
		    }

		    // show or hide break overlays
		    function updateBreakOverlay() {
		      if (!setting.breakOverlay.display || currentMarkerIndex < 0) {
		        return;
		      }

		      var currentTime = player.currentTime();
		      var marker = markersList[currentMarkerIndex];
		      var markerTime = setting.markerTip.time(marker);

		      if (currentTime >= markerTime && currentTime <= markerTime + setting.breakOverlay.displayTime) {
		        if (overlayIndex !== currentMarkerIndex) {
		          overlayIndex = currentMarkerIndex;
		          if (breakOverlay) {
		            breakOverlay.querySelector('.vjs-break-overlay-text').innerHTML = setting.breakOverlay.text(marker);
		          }
		        }

		        if (breakOverlay) {
		          breakOverlay.style.visibility = "visible";
		        }
		      } else {
		        overlayIndex = NULL_INDEX;
		        if (breakOverlay) {
		          breakOverlay.style.visibility = "hidden";
		        }
		      }
		    }

		    // problem when the next marker is within the overlay display time from the previous marker
		    function initializeOverlay() {
		      breakOverlay = _vjs.dom.createEl('div', {
		        className: 'vjs-break-overlay',
		        innerHTML: "<div class='vjs-break-overlay-text'></div>"
		      });
		      Object.keys(setting.breakOverlay.style).forEach(function (key) {
		        if (breakOverlay) {
		          breakOverlay.style[key] = setting.breakOverlay.style[key];
		        }
		      });
		      player.el().appendChild(breakOverlay);
		      overlayIndex = NULL_INDEX;
		    }

		    function onTimeUpdate() {
		      onUpdateMarker();
		      updateBreakOverlay();
		      if (options.onTimeUpdateAfterMarkerUpdate) {
		    	  options.onTimeUpdateAfterMarkerUpdate();
		      }
		    }

		    function onUpdateMarker() {
		      /*
		        check marker reached in between markers
		        the logic here is that it triggers a new marker reached event only if the player
		        enters a new marker range (e.g. from marker 1 to marker 2). Thus, if player is on marker 1 and user clicked on marker 1 again, no new reached event is triggered)
		      */
		      if (!markersList.length) {
		        return;
		      }

		      var getNextMarkerTime = function getNextMarkerTime(index) {
		        if (index < markersList.length - 1) {
		          return setting.markerTip.time(markersList[index + 1]);
		        }
		        // next marker time of last marker would be end of video time
		        return player.duration();
		      };
		      var currentTime = player.currentTime();
		      var newMarkerIndex = NULL_INDEX;

		      var nextMarkerTime;
		      if (currentMarkerIndex !== NULL_INDEX) {
		        // check if staying at same marker
		        nextMarkerTime = getNextMarkerTime(currentMarkerIndex);
		        if (currentTime >= setting.markerTip.time(markersList[currentMarkerIndex]) && currentTime < nextMarkerTime) {
		          return;
		        }

		        // check for ending (at the end current time equals player duration)
		        if (currentMarkerIndex === markersList.length - 1 && currentTime === player.duration()) {
		          return;
		        }
		      }

		      // check first marker, no marker is selected
		      if (currentTime < setting.markerTip.time(markersList[0])) {
		        newMarkerIndex = NULL_INDEX;
		      } else {
		        // look for new index
		        for (var i = 0; i < markersList.length; i++) {
		          nextMarkerTime = getNextMarkerTime(i);
		          if (currentTime >= setting.markerTip.time(markersList[i]) && currentTime < nextMarkerTime) {
		            newMarkerIndex = i;
		            break;
		          }
		        }
		      }

					var adjustMarkerTime = function(marker) {
						var obj = {time: marker.reacheTime};
						_logger.log(_prefix, 'adjustMarkerTime marker.reacheTime = ' + marker.reacheTime);
						return obj;
					};
		      // set new marker index
		      if (newMarkerIndex !== currentMarkerIndex) {
		        // trigger event if index is not null
		        if (newMarkerIndex !== NULL_INDEX && options.onMarkerReached) {
		        	// support for postroll
		        	if (Math.abs(player.duration() - setting.markerTip.time(markersList[newMarkerIndex])) < 3) {
		        		player.one('ended', function() {
		  	  	          options.onMarkerReached(adjustMarkerTime(markersList[newMarkerIndex]), newMarkerIndex);
		        		});
		        	}
		        	else {
		  	          options.onMarkerReached(adjustMarkerTime(markersList[newMarkerIndex]), newMarkerIndex);
		        	}
		        }
		        currentMarkerIndex = newMarkerIndex;
		      }
		    }

		    // setup the whole thing
		    function initialize() {
		      if (setting.markerTip.display) {
		        initializeMarkerTip();
		      }

		      // remove existing markers if already initialized
		      //player.markers.removeAll();
		      addMarkers(options.markers);

		      if (setting.breakOverlay.display) {
		        initializeOverlay();
		      }
		      onTimeUpdate();
		      player.on("timeupdate", onTimeUpdate);
		      player.off("loadedmetadata");
		    }

		    if (setting.metadataLoaded || player.duration() > 0) {
		    	setTimeout(function() {
			    	initialize();
		    	}, 0);
		    }
		    else {
			    // setup the plugin after we loaded video's meta data
			    player.on("loadedmetadata", function () {
			      initialize();
			    });
		    }

		    // exposed plugin API
		    player.markers = {
		      allowReplay: function() {
		    	  currentMarkerIndex = NULL_INDEX;
		      },
		      getMarkers: function getMarkers() {
		        for (var i = 0; i < markersList.length; i++) {
							markersList[i].time = markersList[i].reacheTime;
		        }
		        return markersList;
		      },
		      next: function next() {
		        // go to the next marker from current timestamp
		        var currentTime = player.currentTime();
		        for (var i = 0; i < markersList.length; i++) {
		          var markerTime = setting.markerTip.time(markersList[i]);
		          if (markerTime > currentTime) {
		            player.currentTime(markerTime);
		            break;
		          }
		        }
		      },
		      prev: function prev() {
		        // go to previous marker
		        var currentTime = player.currentTime();
		        for (var i = markersList.length - 1; i >= 0; i--) {
		          var markerTime = setting.markerTip.time(markersList[i]);
		          // add a threshold
		          if (markerTime + 0.5 < currentTime) {
		            player.currentTime(markerTime);
		            return;
		          }
		        }
		      },
		      add: function add(newMarkers) {
		        // add new markers given an array of index
		        addMarkers(newMarkers);
		      },
		      remove: function remove(indexArray) {
		        // remove markers given an array of index
		        removeMarkers(indexArray);
		      },
		      removeAll: function removeAll() {
		        var indexArray = [];
		        for (var i = 0; i < markersList.length; i++) {
		          indexArray.push(i);
		        }
		        removeMarkers(indexArray);
		      },
		      updateTime: function updateTime() {
		        // notify the plugin to update the UI for changes in marker times
		        updateMarkers();
		      },
		      reset: function reset(newMarkers) {
		        // remove all the existing markers and add new ones
		        player.markers.removeAll();
		        addMarkers(newMarkers);
		      },
		      destroy: function destroy() {
		        // unregister the plugins and clean up even handlers
		        player.markers.removeAll();
		        if (breakOverlay) {
		        	breakOverlay.remove();
		        }
		        if (markerTip) {
		        	markerTip.remove();
		        }
		        player.off("timeupdate", onTimeUpdate);
		        delete player.markers;
		      }
		    };
		};
		
	    this.init = function (player) {
	    	_player = player;
	    	_vjs.registerPlugin('markers', markers);
	    };
	    
	    this.markers = function(timeMarkers) {
	    	_player.markers(timeMarkers);
	    };
	};

	module.exports = markersHandler;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

	/**
	 * Client Side Logging module.
	 * @module Logging
	 */


	//Note that we have an excessive amount of try/catch blocks in this code. 
	//That is intentional. Logging should never break the features which are using it

	var TRACE_LEVEL_SILENT = 0;
	var TRACE_LEVEL_ALWAYS = 1;
	var TRACE_LEVEL_ERROR = 2;
	var TRACE_LEVEL_WARN = 3;
	var TRACE_LEVEL_INFO = 4;
	var TRACE_LEVEL_LOG = 5;
	var TRACE_LEVEL_DEBUG = 6;
	var TRACE_LEVEL_VERBOSE = 6;

	var LOCAL_STORAGE_KEY_NAME = "AppNexus_Page_Debug_Log_Level";

	//not an actual debug level, but used as a shortcut so we always
	//know what the max debug level is
	var TRACE_LEVEL_ALL = TRACE_LEVEL_DEBUG;
	var TRACE_LEVEL_DEFAULT = TRACE_LEVEL_SILENT;

	//the current debug level to use
	var _curDebugLevel = TRACE_LEVEL_DEFAULT;

	//the debug level that was set via querystring
	var _debugLevelQueryString = TRACE_LEVEL_DEFAULT;

	//the debug level that was set via localStorage
	var _debugLevelLocalStorage = TRACE_LEVEL_DEFAULT;

	//the debug level that was set via call to setDebugLevel
	var _debugLevelFunctionSet = TRACE_LEVEL_DEFAULT;

	function getCurrentTimeString() {
	    var dateToReturn = "";
	    try {
	        var curDate = new Date();
	        //  try{
	        //     dateToReturn = curDate.toISOString();
	        // }catch(ex){
	        dateToReturn = curDate.getHours() + ":" + curDate.getMinutes() + ":" + curDate.getSeconds() + "." + curDate.getMilliseconds();

	        //}
	    } catch (e) {}
	    return dateToReturn;

	}

	function getTraceMethodName(messageLogLevel) {
	    switch (messageLogLevel) {
	        case 0:
	            break;
	        case 1:
	            return 'always';
	        case 2:
	            return 'error';
	        case 3:
	            return 'warn';
	        case 4:
	            return 'info';
	        case 5:
	            return 'log';
	        case 6:
	            return 'debug';
	        case 7:
	            return 'verbose';
	        default:
	            break;
	    }
	}

	function traceMessageAtLevel(messageLogLevel, args) {

	    try {
	        //if method has been defined, and the correct debug level has been set, log it
	        if (typeof messageLogLevel !== 'undefined' && okToLogMessage(messageLogLevel)) {
	            if (console) {
	                var messagePrefix = "[APN";
	                var methodToUse = getTraceMethodName(messageLogLevel);

	                //if console message doesn't exist, use 'log' and
	                //set the original method in the message prefix 
	                if (!console[methodToUse]) {
	                    messagePrefix += "-" + methodToUse;
	                    methodToUse = 'log';
	                }
	                messagePrefix += "]";
	                messagePrefix += "[" + getCurrentTimeString() + "]";

	                args.splice(0, 0, messagePrefix);
	                //from http://tobyho.com/2012/07/27/taking-over-console-log/
	                if (console[methodToUse].apply) {
	                    console[methodToUse].apply(console, args);
	                } else {
	                    var message = Array.prototype.slice.apply(args).join('');
	                    console[methodToUse](message);
	                }
	            }
	        }
	    } catch (e) {}
	}


	//get a named parameter from the querystring
	function getParameterByName(name) {
	    //accesing window might fail at the browser level, we can't really test for it,
	    //so there are a few nested try/catch blocks here
	    try {
	        var urlToSearch = '';
	        //try checking the topmost window, and if not, use current window
	        try {
	            urlToSearch = window.top.location.search;
	        } catch (e) {
	            try {
	                urlToSearch = window.location.search;
	            } catch (e) {}
	        }

	        var regexS = '[\\?&]' + name + '=([^&#]*)';
	        var regex = new RegExp(regexS);
	        var results = regex.exec(urlToSearch);
	        if (results === null) {
	            return '';
	        }
	        return decodeURIComponent(results[1].replace(/\+/g, ' '));
	    } catch (e) {
	        return '';
	    }
	}

	function parseDebugLevelInput(incomingDebugLevel) {
	    var debugLevelToReturn = TRACE_LEVEL_DEFAULT;
	    try {
	        if (typeof incomingDebugLevel !== "undefined") {
	            var debugLevelToParseInt = parseInt(incomingDebugLevel);
	            //if level is an integer, treat it as such
	            if (!isNaN(debugLevelToParseInt)) {
	                debugLevelToReturn = debugLevelToParseInt;
	            } else {
	                if (typeof incomingDebugLevel === "boolean") {
	                    if (incomingDebugLevel) {
	                        debugLevelToReturn = TRACE_LEVEL_ALL;
	                    } else {
	                        debugLevelToReturn = TRACE_LEVEL_SILENT;
	                    }
	                } else {
	                    //not an integer or boolean, treat it as a string
	                    incomingDebugLevel = incomingDebugLevel.toUpperCase();
	                    if (incomingDebugLevel === "TRUE") {
	                        debugLevelToReturn = TRACE_LEVEL_ALL;
	                    } else {
	                        if (incomingDebugLevel === "FALSE") {
	                            debugLevelToReturn = TRACE_LEVEL_SILENT;
	                        }
	                    }
	                }
	            }
	        }
	    } catch (e) {}

	    return debugLevelToReturn;
	}

	function getLogLevelFromLocalStorage() {
	    try {
	        if (localStorage) {
	            return localStorage.getItem(LOCAL_STORAGE_KEY_NAME);
	        }
	    } catch (e) {
	        //default debug level is returned if the key doesn't exist.
	        //https://developer.mozilla.org/en-US/docs/Web/API/Storage/getItem
	        return TRACE_LEVEL_DEFAULT;
	    }
	}

	//determine the maximum debug level from the page URL
	function setDebugLevelFromPage() {
	    try {
	        //keep track of the new level
	        _debugLevelQueryString = parseDebugLevelInput(getParameterByName("ast_debug").toUpperCase());
	        _debugLevelLocalStorage = parseDebugLevelInput(getLogLevelFromLocalStorage());

	        //the highest (least restrictive debug level) always wins
	        _curDebugLevel = Math.max(Math.max(_debugLevelQueryString, _debugLevelLocalStorage), _curDebugLevel);

	    } catch (e) {}
	}

	function handleSetDebugLevel(newDebugLevel) {
	    try {
	        //keep track of the new level
	        _debugLevelFunctionSet = parseDebugLevelInput(newDebugLevel);

	        //the highest (least restrictive debug level) always wins
	        _curDebugLevel = Math.max(Math.max(_debugLevelQueryString, _debugLevelFunctionSet), _curDebugLevel);

	    } catch (e) {}
	}

	function okToLogMessage(level) {
	    return level <= _curDebugLevel; // getReqestedMaxDebugLevel();
	}


	//DEPRECATED
	function tryLogMessageLegacy(level, message, source) {
	    try {
	        var messageToLog = "[APN-" + level + "-" + new Date().toISOString() + "] ";
	        if (source !== null && source && source.length > 0) {
	            messageToLog += source + ">";
	        }
	        messageToLog += message;

	        if (okToLogMessage(level)) {
	            console.log(messageToLog);
	        }
	    } catch (ex) {
	        if (okToLogMessage(level)) {
	            console.log(ex);
	        }
	    }
	}

	module.exports = {


	    /**
	     * Call the appropriate trace method at the given level 
	     * @param (string) debugLevel = Level to debug at
	     */
	    traceAtLevel: function() {
	        try {
	            if (arguments.length > 0) {
	                var targetTraceLevel = arguments[0];
	                var argsWithoutTraceLevel = Array.prototype.slice.call(arguments, 1);
	                traceMessageAtLevel.call(this, targetTraceLevel, argsWithoutTraceLevel);
	            }
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "always" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "log" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.log style logging.
	     */
	    always: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_ALWAYS, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },


	    /**
	     * If the logging level for type "error" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "error" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.error style logging.
	     */
	    error: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_ERROR, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "log" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "log" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.log style logging.
	     */
	    log: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_LOG, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "warn" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "warn" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.warn style logging.
	     */
	    warn: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_WARN, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "info" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "info" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.info style logging.
	     */
	    info: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_INFO, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "debug" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "debug" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.debug style logging.
	     */
	    debug: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_DEBUG, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "verbose" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "debug" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.debug style logging.
	     */
	    verbose: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_VERBOSE, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * @deprecated - use other logging methods in this library
	     * Writes an entry to the console log if the current debug level is set to "Error", "Warn" or Debug"
	     * @param (string) message = text to be written to the log
	     * @param (string) source = optional string which identifies the source of the debug statement
	     *      - if present, then it will be prepended to front of the string
	     *      - example 1:  debug("hello") ==> <timestamp> hello
	     *      - example 2:  debug("hello", "TM") ==> <timestamp> TM>hello
	     */
	    handleLogDebugLegacySupport: function(message, source) {
	        /*
	        var mainArguments = Array.prototype.slice.call(arguments);
	        mainArguments.unshift("DEBUG");
	        */
	        try {
	            tryLogMessageLegacy(TRACE_LEVEL_LOG, message, source);
	        } catch (e) {}
	    },

	    /**
	     * Sets debug level for logger
	     * @param (string) level = Debug level to use
	     */
	    setDebugLevel: function(newLevel) {
	        try {
	            handleSetDebugLevel(newLevel);
	        } catch (e) {}
	    },


	    /**
	     * Checks if specified trace level will be emitted given the current trace level settings.
	     * @param (Number) levelToCheck = Debug level to check
	     */
	    isTraceLevelActive: function(levelToCheck) {
	        try {
	            return okToLogMessage(levelToCheck);
	        } catch (e) {
	            return false;
	        }
	    },

	    /** @constant {number} */
	    TRACE_LEVEL_ALWAYS: TRACE_LEVEL_ALWAYS,

	    /** @constant {number} */
	    TRACE_LEVEL_ERROR: TRACE_LEVEL_ERROR,

	    /** @constant {number} */
	    TRACE_LEVEL_WARN: TRACE_LEVEL_WARN,

	    /** @constant {number} */
	    TRACE_LEVEL_INFO: TRACE_LEVEL_INFO,

	    /** @constant {number} */
	    TRACE_LEVEL_LOG: TRACE_LEVEL_LOG,

	    /** @constant {number} */
	    TRACE_LEVEL_DEBUG: TRACE_LEVEL_DEBUG,

	    /** @constant {number} */
	    TRACE_LEVEL_VERBOSE: TRACE_LEVEL_VERBOSE
	};


	//look in the query string for debug level
	setDebugLevelFromPage();


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	//var _molPlugin = require("!raw!@appnexus/videoads-vast-vpaid-plugin");
	var _vastParser = __webpack_require__(5);
	var _utils = __webpack_require__(16);

	var _logger = __webpack_require__(3);
	var _prefix = 'apnVmapVast->breakManager';

	var breakManager = function (adBreakData, vjsPlayer, options, notificationCallback) {
		var _notifCallback = notificationCallback;
		var _options = options;
		var _player = vjsPlayer;
		var _defaultAdCancelTimeout = 3000;	
		var _breakData = adBreakData;
		var _currenrAdBreakXmlData;
		var _adIdx = -1;
		var _breakStarted = false;
		var _adStarted = false;
		var _breakDuration;
		var _timeOffset;
		
		var _currentAdSequence;
		var _currentAdSequenceIdx;
		var _currentAdSequencePlaying;
		var _ignoreEvents = false;
		var _errorHappened = false;
		
		var _mainSource;
		
		var _cover = document.getElementById('apn-break-cover');
		var _spinnerDiv = document.getElementById('apn-break-spinner');
		var _showSpinner = false;
		var _adIndicator = document.getElementById('apn-ad-indicator');
		
		// initialize break graphics 
		if (!_cover) {
			_cover = document.createElement('div');
			_cover.id = 'apn-break-cover';
			_cover.style.width = '100%';
			_cover.style.height = '100%';
			_cover.style.backgroundColor = 'black';
			_cover.style.position = 'absolute';
			_player.el().appendChild(_cover);
		}
		_cover.style.display = 'none';
		if (!_spinnerDiv) {
			_spinnerDiv = document.createElement('div');
			_spinnerDiv.id = 'apn-break-spinner';
			_spinnerDiv.className = 'vjs-loading-spinner';
			_spinnerDiv.style.display = 'none';
			_player.el().appendChild(_spinnerDiv);
		}
		if (!_adIndicator) {
			_adIndicator = document.createElement('p');	
			_adIndicator.id = 'apn-ad-indicator';
			_adIndicator.className = 'vjs-overlay';
			_adIndicator.style.display = 'none';
			_adIndicator.style.left = '10px';
			_player.el().appendChild(_adIndicator);
		}
		_adIndicator.innerHTML = "";
		
		function showCover(show) {
			_logger.log(_prefix, (show ? "Show" : "Hide") + " ad cover with spinner");
			if (show) {
	    		_cover.style.display = 'block';
	    		_showSpinner = true;
	    		setTimeout(function() {
	    			if (_showSpinner && _player.bigPlayButton.el_.style.display !== 'block') {
	    	    		_spinnerDiv.style.display = 'block';
	    			}
	    		}, 1000);
	    		//_player.el().classList.add('vjs-ad-playing', 'vjs-vast-ad-loading', 'vjs-waiting');
	    		_player.el().classList.add('vjs-waiting');
			}
			else {
	    		_spinnerDiv.style.display = 'none';
	    		_showSpinner = false;
	    		_cover.style.display = 'none';
	    		//_player.el().classList.remove('vjs-ad-playing', 'vjs-vast-ad-loading', 'vjs-waiting');
	    		_player.el().classList.remove('vjs-waiting');
			}
		}
		
		function substituteErrorInfo(urls, obj) {
			for (var i = 0; i < urls.length; i++) {
				urls[i] = urls[i].replace('[ERROR_CODE]', obj.errorCode);
				urls[i] = urls[i].replace('[ERROR_MESSAGE]', obj.message);
			}
		}
		
		function getTrackingUrls(eventName) {
			var urls = null;
			if (_breakData.trackings && _breakData.trackings.length > 0) {
				for (var i = 0; i < _breakData.trackings.length; i++) {
					if (_breakData.trackings[i].event === eventName) {
						urls = _breakData.trackings[i].uris;
						break;
					}
				}
			}
			return urls;
		}
		
		function trackEvent(eventName, obj) {
			var urls = getTrackingUrls(eventName);
			if (urls && urls.length > 0) {
				if (eventName === 'error') {
					substituteErrorInfo(urls, obj);
				}
				_utils.trackUrls(urls);
			}
		}
		
		function traceMessage(event) {
			_logger.log(_prefix, 'trace event message: ' + event.data.message);
			if (_options.pageNotificationCallback) {
				_options.pageNotificationCallback('message', event.data.message);
			}
		}
		
		function traceEvent(event) {
			_logger.log(_prefix, 'trace event: ' + event.data.event);
			if (_options.pageNotificationCallback) {
				_options.pageNotificationCallback('event', event.data.event);
			}
		}
		
		_player.on('trace.message', traceMessage);
		_player.on('trace.event', traceEvent);

		_player.on('vast.adStart', function() {
			if (_ignoreEvents || _adStarted) {
				return;
			}
			_adIndicator.style.display = 'block';
			_notifCallback(_breakData.breakId, {name: 'BreakAdStarted', data: {adSequence: _currentAdSequence, adId: _currenrAdBreakXmlData.adId}});
			_logger.log(_prefix, "Sequence: " + _currentAdSequence + ", adId: " + _currenrAdBreakXmlData.vastSeqData[_currentAdSequenceIdx].adId + 
					", step in sequence = " + (_currentAdSequenceIdx + 1));
			showCover(false);
			_breakStarted = true;
			_adStarted = true;
			_currentAdSequencePlaying = true;
			_player.trigger({type: 'trace.message', data: {message: 'Ad successfully started'}});
			_options.playerSettings.autostart = true;
		});
		
		_player.on('vast.adError', function(e) {
			if (_ignoreEvents) {
				return;
			}
			_errorHappened = true;
			if (!e.error) {
				e.error = {
					code: 'Unknown',
					message: ''
				};
			}
			_notifCallback(_breakData.breakId, {name: 'BreakAdError', 
				data: {adSequence: _currentAdSequence, adId: _currenrAdBreakXmlData.adId, errorCode: e.error.code, message: e.error.message}});
			_logger.log(_prefix, "Sequence: " + _currentAdSequence + ", adId: " + _currenrAdBreakXmlData.vastSeqData[_currentAdSequenceIdx].adId + 
					", step in sequence = " + (_currentAdSequenceIdx + 1));
			_player.trigger({type: 'trace.message', data: {message: 'Ad failed. error code - ' + e.error.code + '. error message - ' + e.error.message}});
		});
		
		_player.on('vast.adsCancel', function() {
		});
		
		_player.on('vast.adSkip', function() {
			if (_ignoreEvents) {
				return;
			}
			_notifCallback(_breakData.breakId, {name: 'BreakAdSkipped', data: {adSequence: _currentAdSequence, adId: _currenrAdBreakXmlData.adId}});
			_logger.log(_prefix, "Sequence: " + _currentAdSequence + ", adId: " + _currenrAdBreakXmlData.vastSeqData[_currentAdSequenceIdx].adId + 
					", step in sequence = " + (_currentAdSequenceIdx + 1));
			_player.trigger({type: 'trace.message', data: {message: 'Ad skipped'}});
		});
		
		_player.on('vast.reset', function () {
		});
		
		_player.on('vast.contentEnd', function () {
			if (_ignoreEvents) {
				return;
			}
			_notifCallback(_breakData.breakId, {name: 'BreakAdComplete', data: {adSequence: _currentAdSequence, adId: _currenrAdBreakXmlData.adId}});
			_logger.log(_prefix, "Sequence: " + _currentAdSequence + ", adId: " + _currenrAdBreakXmlData.vastSeqData[_currentAdSequenceIdx].adId + 
					", step in sequence = " + (_currentAdSequenceIdx + 1));
			_player.trigger({type: 'trace.message', data: {message: 'Ad content complete'}});
		});

		_player.on('adFinished', function () {
			_notifCallback(_breakData.breakId, {name: 'BreakAdStopped', data: {adSequence: _currentAdSequence, adId: _currenrAdBreakXmlData.adId}});
			_logger.log(_prefix, "Sequence: " + _currentAdSequence + ", adId: " + _currenrAdBreakXmlData.vastSeqData[_currentAdSequenceIdx].adId + 
					", step in sequence = " + (_currentAdSequenceIdx + 1));
			_ignoreEvents = true;
			_player.trigger({type: 'trace.message', data: {message: (_errorHappened ? '*** AD TERMINATED' : '*** AD FINISHED')}});
			_options.playerSettings.muted = _player.muted();
			prepareNextAd();
		});

		var playAd = function(xml) {
			//_player.pause();
			var clientParams = {
	      	  		// VAST xml
	      	  		adTagXML: function(callback) { 
	      	  			setTimeout(function() {
	      	  				callback(null, xml);
	      	  			}, 0);
	      	  		},
	      	  		playAdAlways: false,
	      	  		//Note: As requested we set the preroll timeout at the same place than the adsCancelTimeout
	      	  		adCancelTimeout: (_options && _options.timeouts && _options.timeouts.adStartTimeout) ? _options.timeouts.adStartTimeout : _defaultAdCancelTimeout,
	      	  		adsEnabled: true,
	      	  		verbosity: 4,
	      	  		playsInBreak: true,
	      	  		breakDuration: parseInt(_breakDuration),
	      	  		timeOffset: parseInt(_timeOffset),
	      	  		initialPlayback: (_options.playerSettings.autostart ? 'auto' : 'click'),
	      	  		initialAudio: (_options.playerSettings.muted ? 'off' : 'on')
	            };
			if (_options && _options.skippable && _options.skippable.hasOwnProperty('enabled') && !_options.skippable.enabled) {
				clientParams.disableSkippability = true;
			}
			if (_options && _options.skippable && _options.skippable.skipText) {
				clientParams.skipText = _options.skippable.skipText;
			}
			if (_options && _options.skippable && _options.skippable.skipButtonText) {
				clientParams.skipButtonText = _options.skippable.skipButtonText;
			}
			if (_options && _options.clickThruEnabled === false) {
				clientParams.disableClickThru = true;
			}
			if (_options && _options.wrapperLimit &&  _options.wrapperLimit > 0) {
				clientParams.wrapperLimit = _options.wrapperLimit;
			}
			
			_ignoreEvents = false;
			//_errorHappened = false;
			_adStarted = false;
			_player.trigger({type: 'trace.message', data: {message: '*** AD STARTING Creative ' + _currenrAdBreakXmlData.vastSeqData[_currentAdSequenceIdx].adId +
				' (SLOT: ' + _currentAdSequence + ', waterfall step# ' + (_currentAdSequenceIdx + 1) + ')'}});
	  	  	_player.vastClient(clientParams);
	  	  	
	  	  	if (clientParams.initialPlayback !== 'click') {
	      	  	setTimeout(function() {
	      	  		//_player.trigger('vast.firstPlay');
	      	  		//_player.currentSource(_mainSource);
	      	  		if (_errorHappened) {
	      	  			_errorHappened = false;
	      	  			_player.trigger('vast.firstPlay');
	      	  		}
	      	  		else {
	      	  			//_player.play(); 
	      	  			_player.trigger('vast.firstPlay');
	      	  		}
	      	  		//_player.trigger('break.playAd');
	      	  	}, 0);
	  	  	}
	  	  	
	  	  	//_adIndicator.style.display = 'block';
		};
		
		function prepareNextAd() {
			showCover(true);
	    	var adBreakXmlData = getNextAdXml();
	    	if (adBreakXmlData) {
	    		if (!adBreakXmlData.sequence) {
	    			_currentAdSequence++;
	    		}
	    		else {
	    			_currentAdSequence = adBreakXmlData.sequence;
	    		}
	    		if (_currentAdSequenceIdx === 0) {
	    			// new sequence
	        		_timeOffset += _currenrAdBreakXmlData.duration;
	        		_adIdx++;
	    		}
	    		_currenrAdBreakXmlData = adBreakXmlData;
	    		_adIndicator.innerHTML = 'Ad ' + _adIdx + ' of ' + _breakData.vastXmls.length;
	    		playAd(_currenrAdBreakXmlData.vastSeqData[_currentAdSequenceIdx].vastXml);
	    	}
	    	else {
	    		_adIndicator.style.display = 'none';
	    		showCover(false);
	    		_adIdx = -1;
	    		_player.off('vast.adStart');
	    		_player.off('vast.adError');
	    		_player.off('vast.adsCancel');
	    		_player.off('vast.adSkip');
	    		_player.off('vast.reset');
	    		_player.off('vast.contentEnd');
	    		_player.off('adFinished');
	    		
	    		_player.off('trace.message', traceMessage);
	    		_player.off('trace.event', traceEvent);
	    		
	    		_notifCallback(_breakData.breakId, {name: 'BreakComplete'});
	    		if (!_breakStarted) {
	    			trackEvent('error', {code: 900, message: 'All Ads in the break failed'});
	    		}
	    		else {
	    			trackEvent('breakEnd');
	    		}
	    	}
		}
		
		function getNextAdXml() {
			if (_breakData.vastXmls && _breakData.vastXmls.length > 0) {
				if (!_currentAdSequence) {
					return _breakData.vastXmls[0];
				}
				if (!_currentAdSequencePlaying) {
					// try to get next ad for waterfall
					if (_currentAdSequenceIdx < _currenrAdBreakXmlData.vastSeqData.length - 1) {
						_currentAdSequenceIdx++;
						return _currenrAdBreakXmlData;
					}
				}
				_currentAdSequencePlaying = false;
				_currentAdSequenceIdx = 0;
				for (var i = 0; i < _breakData.vastXmls.length; i++) {
					if (_breakData.vastXmls[i].sequence > _currentAdSequence) {
						return _breakData.vastXmls[i];
					}
				}
			}
			return null;
		}
		
		function getVastXmls() {
			_breakDuration = 0;
			_breakData.vastXmls = [];
			var vastSeqData = [];
			if (_breakData.adSource && _breakData.adSource.vastData) {
				for (var sequence in _breakData.adSource.vastData) {
					if (_breakData.adSource.vastData[sequence].length > 0) {
						vastSeqData = [];
						var seqDuration = 0;
						for (var i = 0; i < _breakData.adSource.vastData[sequence].length; i++) {
							// prepare unwrapped VAST xml
							var vastData = _breakData.adSource.vastData[sequence][i];
							var adId = vastData.adId;
							var vastXml = _vastParser.getUnwrappedVastTag(vastData, null, null, null, null, null, null);
							if (!vastXml) {
								_logger.warn(_prefix, "Failed to get unwrapped xml from internal vast object");
							}
							else {
								vastSeqData.push({vastXml: vastXml, adId: adId, duration: vastData.durationMsecs / 1000.0});
								seqDuration = Math.max(vastData.durationMsecs, seqDuration);
							}
						}
						if (vastSeqData.length > 0) {
							_breakDuration += seqDuration;
							_breakData.vastXmls.push({sequence: parseInt(sequence), vastSeqData: vastSeqData, duration: seqDuration / 1000.0});
						}
					}
				}
				_breakDuration /= 1000.0;	// msecs to secs
				if (_breakData.vastXmls.length > 0) {
					_breakData.vastXmls.sort(function(a, b) {
						return a.sequence - b.sequence;
					});
				}
			}
			else if (_breakData.xml && _breakData.xml.length > 0) {
				vastSeqData.push({vastXml: _breakData.xml, adId: '<unknown>', duration: 0});
				_breakData.vastXmls.push({sequence: 1, vastSeqData: vastSeqData, duration: 0});
			}
		}
		
		getVastXmls();
		
	    this.start = function () {
	    	_timeOffset = 0;
	    	var adBreakXmlData = getNextAdXml();
	    	if (adBreakXmlData) {
	    		_mainSource = _player.currentSource();
	    		if (!adBreakXmlData.sequence) {
	    			_currentAdSequence = 1;
	    		}
	    		else {
	    			_currentAdSequence = adBreakXmlData.sequence;
	    		}
	    		_currentAdSequenceIdx = 0;
	    		_currentAdSequencePlaying = false;
	    		_currenrAdBreakXmlData = adBreakXmlData;
	    		_adIdx = 1;
	    		_adIndicator.innerHTML = 'Ad 1 of ' + _breakData.vastXmls.length;
	    		//_adIndicator.style.display = 'block';
	    		showCover(true);
	    		_notifCallback(_breakData.breakId, {name: 'BreakStarted'});
	    		trackEvent('breakStart');
	    		playAd(_currenrAdBreakXmlData.vastSeqData[_currentAdSequenceIdx].vastXml);
	    	}
	    	else {
	    		trackEvent('error', {code: 900, message: 'No Ads in the break'});
	    		_notifCallback(_breakData.breakId, {name: 'BreakError', data: {errorCode: 900, message: 'No available AD VAST XML for ad break'}});
	    	}
	    };
		
	    this.stop = function () {
	    	_breakData.vastXmls = [];
	    	if (_adIdx >= 0) {
	    		_player.trigger('vast.adsCancel');
	    	}
	    };

	};

	module.exports = breakManager;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * VAST Parser module.
	 * @module VastParser
	 */

	var VastXMLParserHelper = __webpack_require__(6);

	var APN_CompanionAds = __webpack_require__(7);
	var APN_Icons = __webpack_require__(8);

	var uaParser = __webpack_require__(9);
	var ua = uaParser();

	var VastParser = function (id, nMsecTimeout, options) {

	    var _logger = __webpack_require__(3);
	    var _prefix = 'VAST Parser';

	    var _callback = null;
	    var _options = options;
	    var _wrapperLimit = _options && _options.wrapperLimit && _options.wrapperLimit > 0 ? _options.wrapperLimit : 5;
	    var _curWrapperLevel = 0;
	    var _sourceVastXml = null;
	    var _id = id;
	    var _nTimeOut = nMsecTimeout && nMsecTimeout > 0 ? nMsecTimeout : 1000;	// 1 second default
	    var _arrMediaFiles = [],
	    	_mezzanine = null,
	    	_arrInteractiveCreatives = [],
	        _arrTrackings = {},
	        _arrImpressions = [],
	        _arrClickUrls = [],
	        _arrClickTrackings = [],
	        _arrErrorUrls = [],
	        _arrInternalErrorUrls = [],
	        _sExtensions = '',
	        _adParameters = '',
	        _nMsecDuration = 0,
	        _strSkipOffset = '';
	    
	    var _errors303 = null;
	    var _arrError303Urls = [];

	    var _arrTrackingsMerge = {},
	        _arrImpressionsMerge = [],
	        _arrClickUrlsMerge = [],
	        _arrClickTrackingsMerge = [],
	        _arrErrorUrlsMerge = [],
	    	_arrViewableImpressionsMerge = {viewable: [], notViewable: [], undetermined: []};

	    var _helper = new VastXMLParserHelper();
	    var _startTime = null;
	    var _withWrapper = false;
	    var _vastVersion = '';
	    var _conditionalAd = false;
	    var _fallbackOnNoAd;

	    var _adTree = [];
	    var _currTreeIdx = -1;

	    var _terminated = false;

	    var _capabilityDetection = __webpack_require__(10);

	    var _waterfall = false;
	    var _vastObjects = [];
	    var _topLevel = false;
	    var _notifyurls = {};
	    var _curNotifyUrl = '';
	    var _buyerMemberIds = {};
	    var _curBuyerMemberId = '';
	    var _viewabilityConfigs = {};
	    var _curViewabilityConfig = '';
	    var _creativeIds = {};
	    var _curCreativeId = '';

	    var _csmCount = 0;
	    var _rtbCount = 0;
	    
	    var _vmap = options.vmap;

	    var _finalVastUri = '';//VIDLA-2240 to keep final VAST URI

	    _logger.always(_prefix, 'Version 3.1.17');

	    function getVASTVersion(vastNode) {
	        var version = 'unknown';
	        if (vastNode) {
	            version = _helper.getNodeAttributeValue(vastNode, 'version');
	            version = version.trim();
	            if (version.length > 3) {
	                version = version.substr(0, 3);
	            }
	        }
	        return version;
	    }

	    function substituteErrorCode(arrErrorUrls, errorCode) {
	        if (arrErrorUrls && arrErrorUrls.length > 0) {
	            for (var i = 0; i < arrErrorUrls.length; i++) {
	                arrErrorUrls[i] = arrErrorUrls[i].replace('[ERRORCODE]', errorCode);
	            }
	        }
	    }

	    function traceTreePath(idx, message) {
	        var curIdx = idx;
	        var text = 'AD DETECTED=' + (message.substr(0, 7) === 'SUCCESS' ? 'SUCCESS' : 'NONE') + ' :: Reason=' + message +
	            ', playerTechnology=' + (_options.hasOwnProperty('playerTechnology') ? JSON.stringify(_options.playerTechnology) : 'unknown') +
	            ', platform=' + _capabilityDetection.getPlatformType() + ', Ad tree path=';
	        var tree = '';
	        while (curIdx !== -1) {
	            var ad = _adTree[curIdx].children[0];
	            if (ad) {
	                var val = _helper.getNodeAttributeValue(ad, 'id');
	                if (tree.length > 0) {
	                    tree = ' -> ' + tree;
	                }
	                tree = val + tree;
	            }
	            curIdx = _adTree[curIdx].parentIdx;
	        }
	        _logger.info(_prefix, text + tree);
	    }

	    function processWrapper(parentNode) {
	        var node = _helper.getSubNode(parentNode, 'VASTAdTagURI');
	        if (!node) {
	            traceTreePath(_currTreeIdx, 'INVALID WRAPPER NODE');
	            if (_adTree.length === 0) {
	                reportError('300', 'invalid wrapper node');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        var url = _helper.getNodeValues(node);
	        if (!url || url.length === 0) {
	            traceTreePath(_currTreeIdx, 'EMPTY VASTAdTagURI');
	            if (_adTree.length === 0) {
	                reportError('300', 'Invalid VASTAdTagURI node value');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }

	        if (_terminated) {
	            traceTreePath(_currTreeIdx, 'terminated');
	            _callback(false, _id, 'terminated', null, _curNotifyUrl);		// terminated
	            return;
	        }

	        _withWrapper = true;
	        
	        if (_vastVersion >= '4.0') {
	        	var val = _helper.getNodeAttributeBooleanValue(parentNode, 'followAdditionalWrappers', true);
	        	_adTree[_currTreeIdx].state.followAdditionalWrappers = val;
	        	
	        	val = _helper.getNodeAttributeBooleanValue(parentNode, 'allowMultipleAds', false);
	        	_adTree[_currTreeIdx].state.allowMultipleAds = val;
	        	
	        	val = _helper.getNodeAttributeValue(parentNode, 'fallbackOnNoAd');
	        	if (val !== '') {
	        		_fallbackOnNoAd = _helper.getNodeAttributeBooleanValue(parentNode, 'fallbackOnNoAd');
	        	}
	        }

	        //keep final URI for VIDLA-2240
	        _finalVastUri = url;

	        var UrlLoader = __webpack_require__(11);
	        UrlLoader.load(url,
	            function (error, responseText) {
	                if (_terminated) {
	                    traceTreePath(_currTreeIdx, 'terminated');
	                    _callback(false, _id, 'terminated', null, _curNotifyUrl);		// terminated
	                    return;
	                }
	                if (error || responseText.length === 0) {
	                    traceTreePath(_currTreeIdx, 'VASTAdTagURI TIMED OUT: ' + url);
	                    if (_adTree.length === 0) {
	                        reportError('301', 'Timeout of VAST URI provided in wrapper element');
	                    }
	                    else {
	                        processNextAd();
	                    }
	                }
	                else {
	                    _topLevel = false;
	                    parseXML(responseText);
	                }
	            }, _options.adServerTimeout ? _options.adServerTimeout : _nTimeOut);
	    }

	    function isInArray(arr, value) {
	        for (var i = 0; i < arr.length; i++) {
	            if (arr[i] === value) {
	                return true;
	            }
	        }
	        return false;
	    }

	    function addErrorUrls(parentNode, arrErrorUrls) {
	        if (parentNode) {
	            var nodes = _helper.getSubNodes(parentNode, 'Error');
	            if (nodes) {
	                for (var i = 0; i < nodes.length; i++) {
	                    var node = nodes[i];
	                    var url = _helper.getNodeValues(node);
	                    if (url && !isInArray(arrErrorUrls, url)) {
	                        arrErrorUrls.push(url);
	                    }
	                }
	            }
	        }
	    }

	    function addImpressions(parentNode, arrImpressions) {
	        if (parentNode) {
	            var nodes = _helper.getSubNodes(parentNode, 'Impression');
	            if (nodes) {
	                for (var i = 0; i < nodes.length; i++) {
	                    var node = nodes[i];
	                    var url = _helper.getNodeValues(node);
	                    if (url && !isInArray(arrImpressions, url)) {
	                        arrImpressions.push(url);
	                    }
	                }
	            }
	        }
	    }

	    function addTrackings(parentNode, arrTrackings) {
	        //var _nMsecDuration;
	        if (parentNode) {
	            var linear = _helper.getSubNode(parentNode, 'Linear', 0);
	            if (linear) {

	                //comment out by VIDLA-163
	                //var duration_node = _helper.getSubNode(linear, 'Duration');
	                //if (duration_node) {
	                //var str = _helper.getNodeValue(duration_node);
	                //_nMsecDuration = getMsecTime(str, -1);
	                //}


	                var node = _helper.getSubNode(linear, 'TrackingEvents');
	                if (node) {
	                    var nodes = _helper.getSubNodes(node, 'Tracking');
	                    if (nodes) {
	                        for (var i = 0; i < nodes.length; i++) {
	                            node = nodes[i];
	                            var url = _helper.getNodeValues(node);
	                            if (url) {


	                                var event = _helper.getNodeAttributeValue(node, 'event');

	                                //VIDLA-422 progress event also can be multiple in wrapper case
	                                if (event === 'progress') {
	                                    var offset = _helper.getNodeAttributeValue(node, 'offset');
	                                    if (offset) {
	                                        //event = 'progress_' + getMsecTime(offset,_nMsecDuration);
	                                        event = 'progress_' + offset;
	                                    } else {
	                                        event = '';
	                                    }
	                                }
	                                if (event) {
	                                    if (arrTrackings.hasOwnProperty(event)) {
	                                        if (!isInArray(arrTrackings[event], url)) {
	                                            arrTrackings[event].push(url);
	                                        }
	                                    }
	                                    else {
	                                        arrTrackings[event] = [];
	                                        arrTrackings[event].push(url);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }

	    function addExtensions(parentNode, treeIdx) {
	        if (parentNode) {
	            var node = _helper.getSubNode(parentNode, 'Extensions');
	            if (node && node.innerHTML && node.innerHTML.length > 0) {
	                _adTree[treeIdx].state.sExtensions = _adTree[treeIdx].state.sExtensions + node.innerHTML.toString();
	            }
	            else if (node && node.textContent && node.textContent.length > 0) {
	                _adTree[treeIdx].state.sExtensions = _adTree[treeIdx].state.sExtensions + node.textContent.toString();
	            }
	        }
	    }

	    function addCompanions(parentNode, treeIdx) {
	        if (parentNode) {
	            var node = _helper.getSubNode(parentNode, 'CompanionAds');
	            if (node &&
	                ((node.innerHTML && node.innerHTML.length > 0) ||
	                (node.textContent && node.textContent.length > 0))) {
	                APN_CompanionAds.parse(_adTree[treeIdx].state.companions, node, _helper);
	            }
	        }
	    }

	    function addIcons(parentNode, treeIdx) {
	        if (parentNode) {
	            var node = _helper.getSubNode(parentNode, 'Icons');
	            if (node &&
	                ((node.innerHTML && node.innerHTML.length > 0) ||
	                (node.textContent && node.textContent.length > 0))) {
	                APN_Icons.parse(_adTree[treeIdx].state.icons, node, _helper);
	            }
	        }
	    }

	    function addClickUrls(parentNode, arrClickUrls, arrClickTrackings) {
	        if (parentNode) {
	            var linear = _helper.getSubNode(parentNode, 'Linear', 0);
	            if (linear) {
	                var url = null;
	                var parentNode2 = _helper.getSubNode(linear, 'VideoClicks');
	                if (parentNode2) {
	                    var node = _helper.getSubNode(parentNode2, 'ClickThrough');
	                    if (node) {
	                        url = _helper.getNodeValues(node);
	                        if (url && !isInArray(arrClickUrls, url)) {
	                            arrClickUrls.push(url);
	                        }
	                    }
	                    var nodes = _helper.getSubNodes(parentNode2, 'ClickTracking');
	                    if (nodes) {
	                        for (var i = 0; i < nodes.length; i++) {
	                            node = nodes[i];
	                            url = _helper.getNodeValues(node);
	                            if (url && !isInArray(arrClickTrackings, url)) {
	                                arrClickTrackings.push(url);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }

	    function addViewableImpression(parentNode, arrViewableImpression) {
	        if (parentNode) {
	            var viewImps = _helper.getSubNode(parentNode, 'ViewableImpression', 0);
	            if (viewImps) {
	                var url = null;
	                var node = null;
	                var i;
	                var subNodes = _helper.getSubNodes(viewImps, 'Viewable');
	                if (subNodes && subNodes.length > 0) {
	                    for (i = 0; i < subNodes.length; i++) {
	                        node = subNodes[i];
	                        url = _helper.getNodeValues(node);
	                        if (url && !isInArray(arrViewableImpression.viewable, url)) {
	                        	arrViewableImpression.viewable.push(url);
	                        }
	                    }
	                }
	                subNodes = _helper.getSubNodes(viewImps, 'NotViewable');
	                if (subNodes && subNodes.length > 0) {
	                    for (i = 0; i < subNodes.length; i++) {
	                        node = subNodes[i];
	                        url = _helper.getNodeValues(node);
	                        if (url && !isInArray(arrViewableImpression.notViewable, url)) {
	                        	arrViewableImpression.notViewable.push(url);
	                        }
	                    }
	                }
	                subNodes = _helper.getSubNodes(viewImps, 'ViewUndetermined');
	                if (subNodes && subNodes.length > 0) {
	                    for (i = 0; i < subNodes.length; i++) {
	                        node = subNodes[i];
	                        url = _helper.getNodeValues(node);
	                        if (url && !isInArray(arrViewableImpression.undetermined, url)) {
	                        	arrViewableImpression.undetermined.push(url);
	                        }
	                    }
	                }
	            }
	        }
	    }

	    function getMsecTime(strTime, duration) {
	        var nPos = strTime.indexOf('%');
	        if (nPos > 0) {
	            if (duration && duration > 0) {
	                return Number(strTime.substring(0, nPos));
	            }
	            else {
	                return 0;
	            }
	        } else {
	            nPos = strTime.indexOf('.');
	            var msecs = nPos > 0 ? Number(strTime.substring(nPos + 1)) : 0;
	            if (nPos > 0) {
	                strTime = strTime.substring(0, nPos);
	            }
	            var arr = strTime.split(':');
	            if (arr.length === 3) {
	                return (Number(arr[0]) * 3600 + Number(arr[1]) * 60 + Number(arr[2])) * 1000 + msecs;
	            }
	            else {
	                return 0;
	            }
	        }
	    }

	    function isCapable(type, codec) {
	        return _capabilityDetection.canPlay(type, codec);
	    }

	    function isFlashOnlyType(type) {
	        return type === 'video/x-flv' || type === 'video/x-f4v' || type === 'video/f4v' ||
	            type === 'application/x-shockwave-flash';
	    }

	    function isHtml5OnlyType(type) {
	        return type === 'video/webm' || type === 'video/ogg' || type === 'application/javascript' ||
	            type === 'application/x-javascript';
	    }

	    function isVpaidType(type) {
	        return type === 'application/x-shockwave-flash' || type === 'application/javascript' ||
	            type === 'application/x-javascript';
	    }

	    function isOptionsValidated(type) {
	        if (_options.playerTechnology && Array.isArray(_options.playerTechnology) && _options.playerTechnology.length > 0) {
	            var supported = false;
	            for (var i = 0; i < _options.playerTechnology.length; i++) {
	                var tech = _options.playerTechnology[i].toLowerCase();
	                if (!isFlashOnlyType(type.toLowerCase()) && !isHtml5OnlyType(type.toLowerCase())) {
	                    supported = true;
	                    break;
	                }
	                if (tech === 'flash' && !isHtml5OnlyType(type.toLowerCase())) {
	                    supported = true;
	                    break;
	                }
	                if (tech === 'html5' && !isFlashOnlyType(type.toLowerCase())) {
	                    supported = true;
	                    break;
	                }
	            }
	            if (!supported) {
	                return false;
	            }
	        }
	        if (_options.hasOwnProperty('supportVpaid') && !_options.supportVpaid) {
	            if (isVpaidType(type.toLowerCase())) {
	                return false;
	            }
	        }
	        return true;
	    }

	    function configureMediaRendition(node, url, num, mediaTypes) {
	        var rendition = null;
	        if (node) {
	            rendition = {};
	            rendition.type = _helper.getNodeAttributeValue(node, 'type');
	            if (mediaTypes.indexOf(rendition.type) === -1) {
	                mediaTypes.push(rendition.type);
	            }
	            // check capability
	            if (!rendition.type || rendition.type.length === 0) {
	                return null;
	            }
	            var codec = _helper.getNodeAttributeValue(node, 'codec');
	            if (codec && codec.length > 0) {
	            	codec = codec.trim();
	            	codec = codec.length > 2 ? codec : '';	// protection against bad data such as '0'
	            	if (codec.length > 0) {
	                    rendition.codec = codec;
	            	}
	            }
	            if (!isCapable(rendition.type, codec)) {
	                return null;
	            }
	            if (_options) {
	                if (!isOptionsValidated(rendition.type)) {
	                    return null;
	                }
	            }
	            rendition.url = url;
	            rendition.variation = 'Media#' + num;
	            rendition.delivery = _helper.getNodeAttributeValue(node, 'delivery');
	            var bitrate = _helper.getNodeAttributeNumberValue(node, 'bitrate', -1);
	            if (bitrate !== -1) {
	                rendition.bitrate = bitrate;
	            }
	            rendition.width = _helper.getNodeAttributeNumberValue(node, 'width');
	            rendition.height = _helper.getNodeAttributeNumberValue(node, 'height');
	            var valNode = _helper.getNodeAttributeValue(node, 'scalable');
	            if (valNode.length > 0) {
	                rendition.scalable = _helper.getNodeAttributeBooleanValue(node, 'scalable', true);
	            }
	            valNode = _helper.getNodeAttributeValue(node, 'maintainAspectRatio');
	            if (valNode.length > 0) {
	                rendition.maintainAspectRatio = _helper.getNodeAttributeBooleanValue(node, 'maintainAspectRatio', true);
	            }
	            var apiFramework = _helper.getNodeAttributeValue(node, 'apiFramework');
	            if (apiFramework && apiFramework.length > 0) {
	                rendition.apiFramework = apiFramework.toUpperCase();
	            }
	        }

	        return rendition;
	    }

	    function addMediaFilesAndDuration(parentNode) {
	        _nMsecDuration = 0;
	        _strSkipOffset = '';
	        _adParameters = '';
	        _arrMediaFiles = [];
	    	_mezzanine = null;
	    	_arrInteractiveCreatives = [];
	        var message = '';
	        var mediaTypes = [];
	        if (parentNode) {
	            var linear = _helper.getSubNode(parentNode, 'Linear', 0);
	            if (linear) {
	                var node = _helper.getSubNode(linear, 'Duration');
	                if (node) {
	                    var str = _helper.getNodeValue(node);
	                    _nMsecDuration = getMsecTime(str, -1);
	                }
	                var strSkipOffset = _helper.getNodeAttributeValue(linear, 'skipoffset');

	                //comment out by VIDLA-163
	                //if (strSkipOffset && strSkipOffset.length > 0) {
	                //    _nSkipOffset = getMsecTime(strSkipOffset, _nMsecDuration);
	                //}
	                _strSkipOffset = strSkipOffset;

	                //_adParameters = _helper.getSubNodeValue(linear, 'AdParameters', '');
	                _adParameters = _helper.getSubNodeWholeValue(linear, 'AdParameters', '');

	                node = _helper.getSubNode(linear, 'MediaFiles');
	                if (node) {
	                	var url;
	                    var nodes = _helper.getSubNodes(node, 'MediaFile');
	                    if (nodes) {
	                        for (var i = 0; i < nodes.length; i++) {
	                            node = nodes[i];
	                            url = _helper.getNodeValues(node);

	                            if (url.length > 0) {
	                                var rendition = configureMediaRendition(node, url, i, mediaTypes);

	                                if (rendition) {
	                                    _arrMediaFiles.push(rendition);
	                                }
	                            }
	                        }
	                        if (_arrMediaFiles.length === 0) {
	                            message = 'INCOMPATIBLE MEDIA TYPE, Available = ' + JSON.stringify(mediaTypes);
	                        }
	                        else {
	                        	// for VAST 4
	                            node = _helper.getSubNode(linear, 'MediaFiles');
	                        	_mezzanine = _helper.getSubNodeWholeValue(node, 'Mezzanine', '');
	                        	var interactiveNodes = _helper.getSubNodes(node, 'InteractiveCreativeFile');
	                        	if (interactiveNodes && interactiveNodes.length > 0) {
	                        		for (var j = 0; j < interactiveNodes.length; j++) {
	                        			var interactiveCreative = interactiveNodes[j];
	                        			url = _helper.getNodeValues(interactiveCreative);
	                        			if (url) {
	                        				var type = _helper.getNodeAttributeValue(interactiveCreative, 'type');
	                        				var framework = _helper.getNodeAttributeValue(interactiveCreative, 'apiFramework');
	                        				_arrInteractiveCreatives.push({url: url, type: type, apiFramework: framework});
	                        			}
	                        		}
	                        	}
	                        }
	                    }
	                    else {
	                        message = 'MISSING MEDIA FILES';
	                    }
	                }
	                else {
	                    message = 'MISSING MEDIA FILES';
	                }
	            }
	            else {
	                message = 'INVALID VAST STRUCTURE';
	            }
	        }
	        return message;
	    }

	    function trimXml(strVastXml) {
	        var nPos = strVastXml.indexOf('<');
	        var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
	        nPos = strXml.lastIndexOf('>');
	        if (nPos !== -1) {
	            strXml = strXml.substr(0, nPos + 1);
	        }
	        return strXml.trim();
	    }

	    function isValidVastVersion(vastVersion) {
	        return vastVersion === '2.0' || vastVersion === '3.0' || vastVersion === '4.0' || vastVersion === '4.1';
	    }

	    function reportError(errCode, message) {
	        var arrErrorForInternalAndExternal = _arrErrorUrls.concat(_arrInternalErrorUrls);//merge with internal error and external error
	        substituteErrorCode(arrErrorForInternalAndExternal, errCode);
	        if (_arrError303Urls && _arrError303Urls.length > 0) {
	        	substituteErrorCode(_arrError303Urls, '303');
	        	arrErrorForInternalAndExternal = arrErrorForInternalAndExternal.concat(_arrError303Urls);
	        }
	        _logger.error(_prefix, 'Error ' + errCode + ' - ' + message);
	        _callback(false, _id, 'vast' + errCode, arrErrorForInternalAndExternal, _curNotifyUrl);
	    }

	    function processNextAd() {

	        //push error urls to global variable _arrInternalErrorUrls which has empty array as an default, it will be used for reportError() to return array of error urls to _callback
	        //the _arrInternalErrorUrls will be emptied by processAd() when exit out of siblings and if there's no internal parsing error
	        var arrStateOfNode = _adTree[_currTreeIdx].state;
	        if (arrStateOfNode && Array.isArray(arrStateOfNode.arrErrorUrls)) {
	            arrStateOfNode.arrErrorUrls.forEach(function (element) {
	                _arrInternalErrorUrls.push(element);
	            });
	        }

	        if (_currTreeIdx >= 0) {
	            _adTree[_currTreeIdx].children[0] = null;
	            _adTree[_currTreeIdx].children.splice(0, 1);
	            if (_adTree[_currTreeIdx].children.length === 0) {
	                var parentIdx = _adTree[_currTreeIdx].parentIdx;
	                _adTree.splice(_currTreeIdx, 1);
	                _currTreeIdx = parentIdx;
	                if (_currTreeIdx === -1) {
	                    if (_waterfall && _vastObjects.length > 0) {
	                        _logger.info(_prefix, 'Waterfall: Vast XML node count detected: # csm nodes: ' + _csmCount + ', # rtb nodes: ' + _rtbCount);
	                        _callback(true, _id, _vastObjects, null);
	                    }
	                    else if (_vmap && _vastObjects.length > 0) {
	                        _logger.info(_prefix, 'VMAP: Ad XML node count detected: ' + _vastObjects.length);
	                        _callback(true, _id, _vastObjects, null);
	                    }
	                    else {
	                        reportError('900', 'no Ad available');
	                    }
	                    return;
	                }
	                else {
	                    processNextAd();
	                    return;
	                }
	            }
	            _curWrapperLevel = _currTreeIdx;
	            _adTree[_currTreeIdx].state = preapareAdStateData();
	            processAd(_adTree[_currTreeIdx].children[0]);
	        }
	    }

	    function preapareAdStateData() {
	        var state = {
	            arrTrackings: {},
	            arrImpressions: [],
	            arrClickUrls: [],
	            arrClickTrackings: [],
	            arrErrorUrls: [],
	            sExtensions: '',
	            sequence: _vmap ? 0 : 1,
	            companions: {required: 'unknown', companions: []},
	            icons: [],
	            arrViewableImpressions: {viewable: [], notViewable: [], undetermined: []}
	        };
	        return state;
	    }

	    function saveNotificationUrl(adNode) {
	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (id.length > 0) {
	            var url = _helper.getNodeAttributeValue(adNode, 'notifyurl');
	            if (url && url.length > 0) {
	                _notifyurls[id] = url;
	            }
	        }
	    }

	    function saveCreativeId(adNode) {
	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (id.length > 0) {
	            var crId = _helper.getNodeAttributeValue(adNode, 'creativeId');
	            if (crId && crId.length > 0) {
	                _creativeIds[id] = crId;
	            }
	        }
	    }

	    function saveBuyerMemberId(adNode) {
	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (id.length > 0) {
	            var buyerId = _helper.getNodeAttributeValue(adNode, 'buyerMemberId');
	            if (buyerId && buyerId.length > 0) {
	                _buyerMemberIds[id] = buyerId;
	            }
	        }
	    }

	    function saveViewabilityConfig(adNode) {
	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (id.length > 0) {
	            var config = _helper.getNodeAttributeValue(adNode, 'viewabilityConfig');
	            if (config && config.length > 0) {
	                _viewabilityConfigs[id] = config;
	            }
	        }
	    }
	    
	    function saveNoAdsErrors() {
	    	if (_errors303 && _errors303.length > 0) {
	    		for (var i = 0; i < _errors303.length; i++) {
	                var node = _errors303[i];
	                var url = _helper.getNodeValues(node);
	                if (url && !isInArray(_arrError303Urls, url)) {
	                	_arrError303Urls.push(url);
	                }
	    		}
	    	}
	    }

	    function parseXML(strVastXml) {
	        _startTime = (new Date()).getTime();
	    	_arrError303Urls = [];	// make sure we keep error url for last vast

	        _sourceVastXml = strVastXml;
	        var strXml = trimXml(strVastXml);
	        if (strXml.length === 0) {
	            traceTreePath(_currTreeIdx, 'EMPTY VAST');
	            if (_adTree.length === 0) {
	                reportError('110', 'no bid response for mediation');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        var xmlDoc = null;
	        if (typeof window.DOMParser !== 'undefined') {
	            xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
	            if (xmlDoc.documentElement.nodeName === 'parsererror') {
	                try {
	                    _logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
	                }
	                catch (e) {
	                }
	                traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	                if (_adTree.length === 0) {
	                    reportError('100', 'VAST XML parsing error');
	                }
	                else {
	                    processNextAd();
	                }
	                return;
	            }
	        }
	        else if (typeof window.ActiveXObject !== 'undefined') {
	            try {
	                xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
	                xmlDoc.loadXML(strXml);
	                if (xmlDoc.parseError.errorCode !== 0) {
	                    _logger.error(_prefix, xmlDoc.parseError);
	                    traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	                    if (_adTree.length === 0) {
	                        reportError('100', xmlDoc.parseError.errorCode + ', Error reason = ' + xmlDoc.parseError.reason);
	                    }
	                    else {
	                        processNextAd();
	                    }
	                    return;
	                }
	            }
	            catch (ex) {
	                _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
	                traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	                if (_adTree.length === 0) {
	                    reportError('100', 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)');
	                }
	                else {
	                    processNextAd();
	                }
	                return;
	            }
	        }
	        else {
	            _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)');
	            traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	            if (_adTree.length === 0) {
	                reportError('100', 'Failed to get vast xml');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        if (!xmlDoc) {
	            traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	            if (_adTree.length === 0) {
	                reportError('102', 'VAST XML parsing error');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        var vastNode = _helper.getSubNode(xmlDoc, 'VAST');
	        if (!vastNode || !vastNode.firstChild) {
	            traceTreePath(_currTreeIdx, 'EMPTY VAST');
	            if (_adTree.length === 0) {
	                reportError('110', 'no bid response for mediation');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        
	    	_errors303 = _helper.getSubNodes(vastNode, 'Error');
	 
	        var vastVersion = getVASTVersion(vastNode);
	        if (isValidVastVersion(vastVersion)) {
	            if (_topLevel) {
	                _waterfall = _helper.getNodeAttributeBooleanValue(vastNode, 'apn_waterfall');
	                if (_waterfall) {
	                    _options.waterfall = true;
	                }
	            }
	            var ads = _helper.getSubNodes(vastNode, 'Ad');
	            if (!ads || ads.length === 0) {
	            	saveNoAdsErrors();
	                traceTreePath(_currTreeIdx, 'NO AD NODE');
	                if (_adTree.length === 0) {
	                    reportError('900', 'no Ad available');
	                }
	                else {
	                    processNextAd();
	                }
	                return;
	            }
	            var children = [];
	            for (var i = 0; i < ads.length; i++) {
	            	if (_topLevel) {
	                	// make unique Ad id attribute
	            		var adIdTop = _helper.getNodeAttributeValue(ads[i], 'id');
	            		if (adIdTop) {
	            			adIdTop += ('_suffix' + i);
	            			ads[i].id = adIdTop;
	            		}
	            	}
	            	
	            	if (_vastVersion >= '4.0' && _currTreeIdx > 0) {
	            		if (!_adTree[_currTreeIdx].state.allowMultiAds) {
	            			var sequence = _helper.getNodeAttributeValue(ads[i], 'sequence');
	            			if (sequence) {
	            				continue;
	            			}
	            			if (children.length > 0) {
	            				break;
	            			}
	            		}
	            	}
	                children.push(ads[i]);
	                if (_waterfall && _topLevel) {
	                    saveNotificationUrl(ads[i]);
	                }
	                if (_topLevel) {
	                    saveBuyerMemberId(ads[i]);
	                    saveCreativeId(ads[i]);
	                    saveViewabilityConfig(ads[i]);
	                }
	            }
	            if (children.length === 0) {
	            	saveNoAdsErrors();
	                traceTreePath(_currTreeIdx, 'NO VALID AD NODES');
	                if (_adTree.length === 0) {
	                    reportError('900', 'no Ad available');
	                }
	                else {
	                    processNextAd();
	                }
	            	return;
	            }
	            var treeElem = {parentIdx: _currTreeIdx, currentIdx: 0, children: children, state: preapareAdStateData()};
	            _adTree.push(treeElem);
	            treeElem.currentIdx = _adTree.length - 1;
	            _currTreeIdx = treeElem.currentIdx;
	            processAd(_adTree[_currTreeIdx].children[0], vastVersion);
	        }
	        else {
	            traceTreePath(_currTreeIdx, 'INVALID VAST VERSION: ' + vastVersion);
	            if (_adTree.length === 0) {
	                reportError('102', 'VAST version not supported');
	            }
	            else {
	                processNextAd();
	            }
	        }
	    }

	    function mergeTrackings(idx) {
	        for (var event in _adTree[idx].state.arrTrackings) {
	            for (var i = 0; i < _adTree[idx].state.arrTrackings[event].length; i++) {
	                if (_arrTrackingsMerge.hasOwnProperty(event)) {
	                    if (!isInArray(_arrTrackingsMerge[event], _adTree[idx].state.arrTrackings[event][i])) {
	                        _arrTrackingsMerge[event].push(_adTree[idx].state.arrTrackings[event][i]);
	                    }
	                }
	                else {
	                    _arrTrackingsMerge[event] = [];
	                    _arrTrackingsMerge[event].push(_adTree[idx].state.arrTrackings[event][i]);
	                }
	            }
	        }
	        return _arrTrackingsMerge;
	    }

	    function mergeTreeTrackings(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeTrackings(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrTrackingsMerge;
	    }

	    function mergeImpressions(idx) {
	        for (var i = 0; i < _adTree[idx].state.arrImpressions.length; i++) {
	            if (!isInArray(_arrImpressionsMerge, _adTree[idx].state.arrImpressions[i])) {
	                _arrImpressionsMerge.push(_adTree[idx].state.arrImpressions[i]);
	            }
	        }
	        return _arrImpressionsMerge;
	    }

	    function mergeTreeImpressions(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeImpressions(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrImpressionsMerge;
	    }

	    function mergeClickUrls(idx) {
	        for (var i = 0; i < _adTree[idx].state.arrClickUrls.length; i++) {
	            if (!isInArray(_arrClickUrlsMerge, _adTree[idx].state.arrClickUrls[i])) {
	                _arrClickUrlsMerge.push(_adTree[idx].state.arrClickUrls[i]);
	            }
	        }
	        return _arrClickUrlsMerge;
	    }

	    function mergeTreeClickUrls(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeClickUrls(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrClickUrlsMerge;
	    }

	    function mergeClickTrackings(idx) {
	        for (var i = 0; i < _adTree[idx].state.arrClickTrackings.length; i++) {
	            if (!isInArray(_arrClickTrackingsMerge, _adTree[idx].state.arrClickTrackings[i])) {
	                _arrClickTrackingsMerge.push(_adTree[idx].state.arrClickTrackings[i]);
	            }
	        }
	        return _arrClickTrackingsMerge;
	    }

	    function mergeTreeClickTrackings(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeClickTrackings(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrClickTrackingsMerge;
	    }

	    function mergeErrorUrls(idx) {
	        for (var i = 0; i < _adTree[idx].state.arrErrorUrls.length; i++) {
	            if (!isInArray(_arrErrorUrlsMerge, _adTree[idx].state.arrErrorUrls[i])) {
	                _arrErrorUrlsMerge.push(_adTree[idx].state.arrErrorUrls[i]);
	            }
	        }
	        return _arrErrorUrlsMerge;
	    }

	    function mergeTreeErrorUrls(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeErrorUrls(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrErrorUrlsMerge;
	    }

	    function mergeExtensions(idx) {
	        if (_adTree[idx].state.sExtensions.length > 0) {
	            _sExtensions = _sExtensions + _adTree[idx].state.sExtensions;
	        }
	        return _sExtensions;
	    }

	    function mergeTreeExtensions(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeExtensions(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _sExtensions;
	    }

	    function mergeCompanions(treeIdx) {
	        var idx = treeIdx;
	        while (idx > 0) {
	            var parentIdx = _adTree[idx].parentIdx;
	            APN_CompanionAds.mergeCompanions(_adTree[parentIdx].state.companions, _adTree[idx].state.companions);
	            idx = parentIdx;
	        }
	        if (_adTree[idx].state.companions.required === 'unknown') {
	            delete _adTree[idx].state.companions.required;
	        }
	        return _adTree[idx].state.companions;
	    }

	    function mergeTreeCompanions(treeIdx) {
	        var arrCompanions = {required: 'unknown', companions: []};
	        var idx = treeIdx;
	        while (idx >= 0) {
	            APN_CompanionAds.mergeCompanions(arrCompanions, _adTree[idx].state.companions);
	            idx = _adTree[idx].parentIdx;
	        }
	        return arrCompanions;
	    }

	    function isProgramExist(arrIcons, program) {
	        for (var i = 0; i < arrIcons.length; i++) {
	            if (arrIcons[i].program.toLowerCase() === program.toLowerCase()) {
	                return true;
	            }
	        }
	        return false;
	    }

	    function removeProgram(arrIcons, program) {
	        for (var i = 0; i < arrIcons.length; i++) {
	            if (arrIcons[i].program.toLowerCase() === program.toLowerCase()) {
	                //arrIcons[i].splice(i, 1);
	                arrIcons.splice(i, 1);//one of arrIcons should be removed if it has same program for VIDLA-625
	                return;
	            }
	        }
	    }

	    function mergeIcons(treeIdx) {
	        var idx = treeIdx;
	        while (idx > 0) {
	            var parentIdx = _adTree[idx].parentIdx;
	            for (var i = 0; i < _adTree[idx].state.icons.length; i++) {
	                // avoid duplicate icons with same program (replace if exist)
	                if (isProgramExist(_adTree[parentIdx].state.icons, _adTree[idx].state.icons[i].program)) {
	                    removeProgram(_adTree[parentIdx].state.icons, _adTree[idx].state.icons[i].program);
	                }
	                _adTree[parentIdx].state.icons.push(_adTree[idx].state.icons[i]);
	            }
	            idx = parentIdx;
	        }
	        return _adTree[idx].state.icons;
	    }

	    function mergeTreeIcons(treeIdx) {
	        var arrIcons = [];
	        var idx = treeIdx;
	        while (idx >= 0) {
	            for (var i = 0; i < _adTree[idx].state.icons.length; i++) {
	                // avoid duplicate icons with same program
	                if (!isProgramExist(arrIcons, _adTree[idx].state.icons[i].program)) {
	                    arrIcons.push(_adTree[idx].state.icons[i]);
	                }
	            }
	            idx = _adTree[idx].parentIdx;
	        }
	        return arrIcons;
	    }

	    function aggregateCompanions(companionsObj) {
	        // get companions with resources and without resorces
	        var resCompanions = [];
	        var noresCompanions = [];
	        var companions = companionsObj.companions;
	        if (!companionsObj.companions) {
	            return companionsObj;
	        }
	        var companion;
	        var i, j;
	        for (i = companions.length - 1; i >= 0; i--) {
	            companion = companions[i];
	            if (companion.StaticResource || companion.IFrameResource || companion.HTMLResource) {
	                var sameSize = false;
	                for (j = 0; j < resCompanions.length; j++) {
	                    if (companion.width === resCompanions[j].width &&
	                        companion.height === resCompanions[j].height) {
	                        sameSize = true;
	                        break;
	                    }
	                }
	                if (!sameSize) {
	                    resCompanions.push(companion);
	                }
	            }
	            else {
	                noresCompanions.push(companion);
	            }
	        }

	        // aggregate companions without resorces into companions with resources
	        for (i = 0; i < noresCompanions.length; i++) {
	            for (j = 0; j < resCompanions.length; j++) {
	                if (noresCompanions[i].width === resCompanions[j].width && noresCompanions[i].height === resCompanions[j].height) {
	                    if ((noresCompanions[i].id && noresCompanions[i].id === resCompanions[j].id) || (!noresCompanions[i].id)) {
	                        // add click trackings
	                        if (noresCompanions[i].CompanionClickTracking) {
	                            if (!resCompanions[j].CompanionClickTracking) {
	                                resCompanions[j].CompanionClickTracking = [];
	                            }
	                            resCompanions[j].CompanionClickTracking = resCompanions[j].CompanionClickTracking.concat(noresCompanions[i].CompanionClickTracking);
	                        }
	                        // add view trackings
	                        if (noresCompanions[i].TrackingEvents) {
	                            if (!resCompanions[j].TrackingEvents) {
	                                resCompanions[j].TrackingEvents = [];
	                            }
	                            resCompanions[j].TrackingEvents = resCompanions[j].TrackingEvents.concat(noresCompanions[i].TrackingEvents);
	                        }
	                    }
	                }
	            }
	        }
	        var ret = {companions: resCompanions};
	        if (companionsObj.required) {
	            ret.required = companionsObj.required;
	        }
	        return ret;
	    }
	    
	    function getCategories(node) {
	    	var categories = [];
	    	var nodes = _helper.getSubNodes(node, 'Category');
	    	if (nodes && nodes.length > 0) {
	    		for (var i = 0; i < nodes.length; i++) {
	    			var val = _helper.getNodeValues(nodes[i]);
	    			if (val && val.length > 0) {
	    				// if category value is not present ignore this category node
	        			var authority = _helper.getNodeAttributeValue(nodes[i], 'authority');
	        			categories.push({category: val, authority: authority});
	    			}
	    		}
	    	}
	    	return categories.length > 0 ? categories : null;
	    }

	    function mergeViewableImpressions(idx) {
	    	var i;
	        for (i = 0; i < _adTree[idx].state.arrViewableImpressions.viewable.length; i++) {
	            if (!isInArray(_arrViewableImpressionsMerge.viewable, _adTree[idx].state.arrViewableImpressions.viewable[i])) {
	            	_arrViewableImpressionsMerge.viewable.push(_adTree[idx].state.arrViewableImpressions.viewable[i]);
	            }
	        }
	        for (i = 0; i < _adTree[idx].state.arrViewableImpressions.notViewable.length; i++) {
	            if (!isInArray(_arrViewableImpressionsMerge.notViewable, _adTree[idx].state.arrViewableImpressions.notViewable[i])) {
	            	_arrViewableImpressionsMerge.notViewable.push(_adTree[idx].state.arrViewableImpressions.notViewable[i]);
	            }
	        }
	        for (i = 0; i < _adTree[idx].state.arrViewableImpressions.undetermined.length; i++) {
	            if (!isInArray(_arrViewableImpressionsMerge.undetermined, _adTree[idx].state.arrViewableImpressions.undetermined[i])) {
	            	_arrViewableImpressionsMerge.undetermined.push(_adTree[idx].state.arrViewableImpressions.undetermined[i]);
	            }
	        }
	        return _arrViewableImpressionsMerge;
	    }

	    function mergeTreeViewableImpressions(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	        	mergeViewableImpressions(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrViewableImpressionsMerge;
	    }
	    
	    function getUniversalAdId(node) {
	    	var creatieves = _helper.getSubNodes(node, 'Creative');
	    	if (creatieves && creatieves.length > 0) {
	    		for (var i = 0; i < creatieves.length; i++) {
	    			var linear = _helper.getSubNode(creatieves[i], 'Linear');
	    			if (linear) {
	        			var universalAdId = _helper.getSubNode(creatieves[i], 'UniversalAdId');
	        			return universalAdId;
	    			}
	    		}
	    	}
	    	return null;
	    }
	    
	    function getAdVerifications(node) {
	    	var verifications = [];
	    	var adVer = _helper.getSubNode(node, 'AdVerifications');
	    	if (adVer) {
	    		var nodes = _helper.getSubNodes(adVer, 'Verification');
	    		if (nodes && nodes.length > 0) {
	    			for (var i = 0; i < nodes.length; i++) {
	    				var verification = nodes[i];
	    				var vendor = _helper.getNodeAttributeValue(verification, 'vendor');
	    				var jsResources = [];
	    				var flashResources = [];
	    				var val;
	    				var attr;
	    				var j;
	    				var resources = _helper.getSubNodes(verification, 'JavaScriptResource');
	    				if (resources && resources.length > 0) {
	    					for (j = 0; j < resources.length; j++) {
	    						val = _helper.getNodeValues(resources[j]);
	    						var attrFr = _helper.getNodeAttributeValue(resources[j], 'apiFramework');
	    						var attrBr = _helper.getNodeAttributeBooleanValue(resources[j], 'browserOptional');
	    						jsResources.push({url: val, framework: attrFr, browserOptional: attrBr});
	    					}
	    				}
	    				resources = _helper.getSubNodes(verification, 'FlashResource');
	    				if (resources && resources.length > 0) {
	    					for (j = 0; j < resources.length; j++) {
	    						val = _helper.getNodeValues(resources[j]);
	    						attr = _helper.getNodeAttributeValue(resources[j], 'apiFramework');
	    						flashResources.push({url: val, framework: attr});
	    					}
	    				}
	                    var viewableImpression = _helper.getSubNodeWholeValue(verification, 'ViewableImpression');
	                    var trackingEvents = {};
	                    var hasTrackings = false;
	    				var trEvents = _helper.getSubNode(verification, 'TrackingEvents');
	    				if (trEvents) {
	                        var trackings = _helper.getSubNodes(trEvents, 'Tracking');
	                        if (trackings && trackings.length > 0) {
	                            for (j = 0; j < trackings.length; j++) {
	                                val = _helper.getNodeValues(trackings[j]);
	                                var event = _helper.getNodeAttributeValue(trackings[j], 'event');
	                                if (event && val) {
	                                    hasTrackings = true;
	                                    if (trackingEvents.hasOwnProperty(event)) {
	                                        trackingEvents[event].push(val);
	                                    }
	                                    else {
	                                        trackingEvents[event] = [val];
	                                    }
	                                }
	                            }                              
	                        }
	    				}
	                    var verificationParameters = _helper.getSubNodeWholeValue(verification, 'VerificationParameters');
	    				var verData = {};
	    				if (vendor) {
	    					verData.vendor = vendor;
	    				}
	    				if (jsResources.length > 0) {
	    					verData.jsResources = jsResources;
	    				}
	    				if (flashResources.length > 0) {
	    					verData.flashResources = flashResources;
	    				}
	    				if (viewableImpression) {
	    					verData.viewableImpression = viewableImpression;
	                    }
	                    if (hasTrackings) {
	                        verData.trackingEvents = trackingEvents;
	                    }
	                    if (verificationParameters) {
	                        verData.verificationParameters = verificationParameters;
	                    }
	    				verifications.push(verData);
	    			}
	    		}
	    	}
	    	
	    	return verifications.length > 0 ? verifications : null;
	    }
	    
	    function normalizeAdId(id) {
	    	var retId = id;
	    	var idx = retId.indexOf('_suffix');
	    	if (idx > 0) {
	    		retId = retId.substring(0, idx);
	    	}
	    	return retId;
	    }

	    function processAd(adNode, vastVersion) {
	        var inLineWrapperNode = _helper.getSubNode(adNode, 'Wrapper');
	        var isWrapper = inLineWrapperNode !== null;
	        if (!isWrapper) {
	            inLineWrapperNode = _helper.getSubNode(adNode, 'InLine');
	        }
	        
	        if (!inLineWrapperNode) {
	        	saveNoAdsErrors();
	            traceTreePath(_currTreeIdx, 'MISSING WRAPPER / INLINE NODE');
	            processNextAd();
	            return;
	        }

	        _curWrapperLevel++;
	        // wrapper limit is number of Wrapper nodes + InLine node
	        if (_curWrapperLevel > _wrapperLimit) {
	            traceTreePath(_currTreeIdx, 'Reach Wrapper limit');
	            processNextAd();
	            return;
	        }

	        if (vastVersion > _vastVersion) {
	            _vastVersion = vastVersion;
	        }

	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (_notifyurls.hasOwnProperty(id)) {
	            _curNotifyUrl = _notifyurls[id];
	        }
	        if (_creativeIds.hasOwnProperty(id)) {
	            _curCreativeId = _creativeIds[id];
	        }
	        if (_buyerMemberIds.hasOwnProperty(id)) {
	            _curBuyerMemberId = _buyerMemberIds[id];
	        }
	        if (_viewabilityConfigs.hasOwnProperty(id)) {
	            _curViewabilityConfig = _viewabilityConfigs[id];
	        }
	        // worried only about top level ad sequence attribute
	        if (_currTreeIdx === 0) {
	            var seq = _helper.getNodeAttributeValue(adNode, 'sequence');
	            if (seq) {
	                _adTree[_currTreeIdx].state.sequence = parseInt(seq);
	            }
	            var conditional = _helper.getNodeAttributeValue(adNode, 'conditionalAd');
	            if (conditional) {
	            	_conditionalAd = _helper.getNodeAttributeBooleanValue(adNode, 'conditionalAd');
	            }
	        }

	        addErrorUrls(inLineWrapperNode, _adTree[_currTreeIdx].state.arrErrorUrls);
	        addImpressions(inLineWrapperNode, _adTree[_currTreeIdx].state.arrImpressions);
	        addTrackings(inLineWrapperNode, _adTree[_currTreeIdx].state.arrTrackings);
	        addClickUrls(inLineWrapperNode, _adTree[_currTreeIdx].state.arrClickUrls, _adTree[_currTreeIdx].state.arrClickTrackings);
	        addExtensions(inLineWrapperNode, _currTreeIdx);
	        addCompanions(inLineWrapperNode, _currTreeIdx);
	        addIcons(inLineWrapperNode, _currTreeIdx);
	        addViewableImpression(inLineWrapperNode, _adTree[_currTreeIdx].state.arrViewableImpressions);

	        _arrInternalErrorUrls = [];//clear _arrInternalErrorUrls at this time, all same sibiling's error will be gathered by processNextAd()

	        if (isWrapper) {
	        	if (_vastVersion >= '4.0' && _currTreeIdx > 0) {
	        		if (!_adTree[_currTreeIdx - 1].state.followAdditionalWrappers) {
	                    traceTreePath(_currTreeIdx, 'Additional Wrappers are not allowed');
	                    processNextAd();
	                    return;
	        		}
	        	}
	            processWrapper(inLineWrapperNode);
	        }
	        else {
	            var message = addMediaFilesAndDuration(inLineWrapperNode);
	            if (_arrMediaFiles.length === 0 || message.length > 0) {
	                traceTreePath(_currTreeIdx, message);
	                processNextAd();
	                return;
	            }
	            _arrTrackingsMerge = JSON.parse(JSON.stringify(_arrTrackings));
	            _arrImpressionsMerge = _arrImpressions.slice(0);
	            _arrClickUrlsMerge = _arrClickUrls.slice(0);
	            _arrClickTrackingsMerge = _arrClickTrackings.slice(0);
	            _arrErrorUrlsMerge = _arrErrorUrls.slice(0);
	            _sExtensions = '';

	            var strTrackingUrls = JSON.stringify(mergeTreeTrackings(_adTree[_currTreeIdx].parentIdx));
	            var strImpressionUrls = JSON.stringify(mergeTreeImpressions(_adTree[_currTreeIdx].parentIdx));
	            var strClickUrls = JSON.stringify(mergeTreeClickUrls(_adTree[_currTreeIdx].parentIdx));
	            var strClickTrackingUrls = JSON.stringify(mergeTreeClickTrackings(_adTree[_currTreeIdx].parentIdx));
	            var strErrorUrls = JSON.stringify(mergeTreeErrorUrls(_adTree[_currTreeIdx].parentIdx));
	            var strExtensions = mergeTreeExtensions(_adTree[_currTreeIdx].parentIdx);
	            var strCompanions = JSON.stringify(mergeTreeCompanions(_adTree[_currTreeIdx].parentIdx));
	            var strIcons = JSON.stringify(mergeTreeIcons(_adTree[_currTreeIdx].parentIdx));
	            _sExtensions = '';
	            var companions = mergeCompanions(_currTreeIdx);
	            companions = aggregateCompanions(companions);
	            var vastObj = {
	                vastVersion: _vastVersion,
	                withWrapper: _withWrapper,
	                mediaFiles: _arrMediaFiles,
	                trackingUrls: mergeTrackings(_currTreeIdx),
	                impressionUrls: mergeImpressions(_currTreeIdx),
	                clickUrls: mergeClickUrls(_currTreeIdx),
	                clickTrackingUrls: mergeClickTrackings(_currTreeIdx),
	                errorUrls: mergeErrorUrls(_currTreeIdx),
	                durationMsecs: _nMsecDuration,
	                skipOffset: _strSkipOffset,
	                extensions: mergeExtensions(_currTreeIdx),
	                adParameters: _adParameters,
	                vastXml: _sourceVastXml,			// inline vast xml
	                extTrackingUrls: strTrackingUrls,
	                extImpressionUrls: strImpressionUrls,
	                extClickUrls: strClickUrls,
	                extClickTrackingUrls: strClickTrackingUrls,
	                extErrorUrls: strErrorUrls,
	                extExtensions: strExtensions,
	                adId: normalizeAdId(id),
	                sequence: _adTree[0].state.sequence,
	                companionAds: companions,
	                extCompanions: strCompanions,
	                icons: mergeIcons(_currTreeIdx),
	                extIcons: strIcons,
	                finalVastUri: _finalVastUri //VIDLA-2240
	            };
	            
	            // vast 4 data
	            if (_vastVersion.substr(0, 1) > '3') {
	        		var universalAdId = getUniversalAdId(inLineWrapperNode);
	        		if (universalAdId) {
	                    var idRegistry = _helper.getNodeAttributeValue(universalAdId, 'idRegistry');
	                    var idValue = _helper.getNodeAttributeValue(universalAdId, 'idValue');
	                    if (idRegistry.length === 0 || idValue.length === 0) {
	                        traceTreePath(_currTreeIdx, 'universalAdId is invalid');
	                        processNextAd();
	                        return;
	                    }
	                    vastObj.universalAdId = {idRegistry: idRegistry, idValue: idValue};
	                }
	        		
	            	vastObj.conditionalAd = _conditionalAd;
	            	var categories = getCategories(inLineWrapperNode);
	            	if (categories) {
	            		for (var j = 0; j < categories.length; j++) {
	            			if (!categories[j].category || !categories[j].authority) {
	                            traceTreePath(_currTreeIdx, 'invalid Category node');
	                            processNextAd();
	                            return;
	            			}
	            		}
	                	vastObj.categories = categories;
	            	}
	            	
	                var strViewableImpressions = JSON.stringify(mergeTreeViewableImpressions(_adTree[_currTreeIdx].parentIdx));
	            	var viewImpressions = mergeViewableImpressions(_currTreeIdx);
	            	// use only not empty (with not empty arrays) viewImpressions object
	            	if (viewImpressions && 
	            		(viewImpressions.viewable.length + viewImpressions.notViewable.length + viewImpressions.undetermined.length) > 0) {
	                	vastObj.extViewableImpression = strViewableImpressions;
	                	vastObj.viewableImpression = viewImpressions;
	            	}
	            	
	            	var adVerifications = getAdVerifications(inLineWrapperNode);
	        		if (adVerifications && adVerifications.length > 0) {
	                	vastObj.adVerifications = adVerifications;
	        		}
	        		
	        		if (_mezzanine) {
	        			vastObj.mezzanine = _mezzanine;
	        		}
	        		if (_arrInteractiveCreatives && _arrInteractiveCreatives.length > 0) {
	        			vastObj.interactiveCreativeFiles = _arrInteractiveCreatives;
	        		}
	        		
	        		if (_fallbackOnNoAd !== undefined) {
	        			vastObj.fallbackOnNoAd = _fallbackOnNoAd;
	        		}
	            }
	            
	            if (_waterfall && _curNotifyUrl.length > 0) {
	                vastObj.notifyurl = _curNotifyUrl;
	            }
	            if (_curCreativeId.length > 0) {
	                vastObj.creative_id = _curCreativeId;
	            }
	            if (_curBuyerMemberId.length > 0) {
	                vastObj.buyerMemberId = _curBuyerMemberId;
	            }
	            if (_curViewabilityConfig.length > 0) {
	                vastObj.viewabilityConfig = _curViewabilityConfig;
	            }
	            // becaurse waterfall xml always unwrapped, we can set rtb flag base on current ad node
	            var rtb = false;
	            if (_waterfall) {
	                var rtbAttr = _helper.getNodeAttributeValue(adNode, 'rtb');
	                if (rtbAttr && rtbAttr === 'true') {
	                    rtb = true;
	                    vastObj.rtb = true;
	                }
	            }
	            if (_terminated) {
	                traceTreePath(_currTreeIdx, 'terminated');
	                _callback(false, _id, 'terminated', null, _curNotifyUrl);		// terminated
	                return;
	            }
	            var mediaTypes = [];
	            for (var i = 0; i < _arrMediaFiles.length; i++) {
	                if (mediaTypes.indexOf(_arrMediaFiles[i].type) === -1) {
	                    mediaTypes.push(_arrMediaFiles[i].type);
	                }
	            }
	            traceTreePath(_currTreeIdx, 'SUCCESS, Available=' + JSON.stringify(mediaTypes));
	            if (_waterfall) {
	                _vastObjects.push(vastObj);
	                if (rtb) {
	                    _rtbCount++;
	                }
	                else {
	                    _csmCount++;
	                }
	                processNextAd();
	            }
	            else if (_vmap) {
	            	vastObj.vastXml = getXmlForSequence(vastObj.vastXml, vastObj.sequence);
	            	_vastObjects.push(vastObj);
	                processNextAd();
	            }
	            else {
	                _callback(true, _id, vastObj, null);
	            }
	        }
	    }
	    
	    function getXmlForSequence(xml, sequence) {
	        var xmlDoc = (new DOMParser()).parseFromString(xml, 'text/xml');
	        var vastNode = _helper.getSubNode(xmlDoc, 'VAST');
	        var adNodes = _helper.getSubNodes(vastNode, 'Ad');
	        for (var i = 0; i < adNodes.length;) {
	        	var adSequence = _helper.getNodeAttributeValue(adNodes[i], 'sequence');
	        	if (adSequence && parseInt(adSequence) !== sequence) {
	        		// delete ad with different sequence attribute
	        		vastNode.removeChild(adNodes[i]);
	        	}
	        	else {
	        		i++;
	        	}
	        }
	    	var browser = ua.browser.name.toLowerCase();    
	        var xmlOut;
	        if (browser === 'ie') {
	        	xmlOut = (new XMLSerializer()).serializeToString(xmlDoc.childNodes[0]);
	        }
	        else {
	            xmlOut = xmlDoc.childNodes[0].outerHTML; 
	        }
	        return xmlOut;
	    }

	    function prepareExternalTrackers(videoTrackers, impTracker) {

	        var url;
	        var i;
	        var arr;
	        var name;
	        if (impTracker) {
	            _arrImpressions.push(impTracker.trim());
	        }
	        if (videoTrackers) {
	            if (Array.isArray(videoTrackers) && videoTrackers.length === 1) {
	                // new format
	                var trackers = videoTrackers[0];
	                if (trackers.impression_urls) {
	                    for (i = 0; i < trackers.impression_urls.length; i++) {
	                        url = trackers.impression_urls[i].trim();
	                        _arrImpressions.push(url);
	                    }
	                }
	                if (trackers.error_urls) {
	                    for (i = 0; i < trackers.error_urls.length; i++) {
	                        url = trackers.error_urls[i].trim();
	                        _arrErrorUrls.push(url);
	                    }
	                }
	                if (trackers.video_click_urls) {
	                    for (i = 0; i < trackers.video_click_urls.length; i++) {
	                        url = trackers.video_click_urls[i].trim();
	                        _arrClickTrackings.push(url);
	                    }
	                }
	                for (name in trackers.video_events) {
	                    arr = trackers.video_events[name];
	                    for (i = 0; i < arr.length; i++) {
	                        url = arr[i].trim();
	                        if (_arrTrackings.hasOwnProperty(name)) {
	                            if (!isInArray(_arrTrackings[name], url)) {
	                                _arrTrackings[name].push(url);
	                            }
	                        }
	                        else {
	                            _arrTrackings[name] = [url];
	                        }
	                    }
	                }
	            }
	            else {
	                for (name in videoTrackers) {
	                    if (name === 'service') {	// ignore not vast related trackers
	                        continue;
	                    }
	                    if (Array.isArray(videoTrackers[name])) {
	                        arr = videoTrackers[name];
	                        for (i = 0; i < arr.length; i++) {
	                            url = arr[i].trim();
	                            if (name === 'click') {
	                                _arrClickTrackings.push(url);
	                            }
	                            else if (name === 'error') {
	                                _arrErrorUrls.push(url);
	                            }
	                            else if (name === 'impression') {
	                                _arrImpressions.push(url);
	                            }
	                            else {
	                                if (_arrTrackings.hasOwnProperty(name)) {
	                                    if (!isInArray(_arrTrackings[name], url)) {
	                                        _arrTrackings[name].push(url);
	                                    }
	                                }
	                                else {
	                                    _arrTrackings[name] = [url];
	                                }
	                            }
	                        }
	                    }
	                    else {
	                        url = videoTrackers[name].trim();
	                        if (name === 'click') {
	                            _arrClickTrackings.push(url);
	                        }
	                        else if (name === 'error') {
	                            _arrErrorUrls.push(url);
	                        }
	                        else if (name === 'impression') {
	                            _arrImpressions.push(url);
	                        }
	                        else {
	                            if (_arrTrackings.hasOwnProperty(name)) {
	                                if (!isInArray(_arrTrackings[name], url)) {
	                                    _arrTrackings[name].push(url);
	                                }
	                            }
	                            else {
	                                _arrTrackings[name] = [url];
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }

	    this.parse = function (strVastXml, videoTrackers, impTracker, callback) {
	        _callback = callback;
	        prepareExternalTrackers(videoTrackers, impTracker);
	        _topLevel = true;
	        parseXML(strVastXml);
	    };

	    this.terminate = function () {
	        _terminated = true;
	    };
	};

	var VastModifier = __webpack_require__(14);

	var VastMerger = __webpack_require__(15);

	module.exports = {
	    /** Describe Parser Main Entry Point Here.
	     * @param {string} strVastXml - VAST xml.
	     * @param {function} fnCallback - Callback function.
	     *        Callback parameters:
	     *            succ: true if success, false otherwise
	     *            sourceId: mediation element identificator
	     *            data: object is success, error code otherwise
	     *            arrErrorUrl: null if success, list of tracking url parsed from vast xml untill parsing has failed
	     * @param {object} id - mediation element identificator.
	     * @param {number} nMsecTimeout - time out in miliseconds for loading wrapper xml.
	     * @param {object} videoTrackers - video_trackings field from impbus request.
	     * @param {string} videoTrackers - imp_tracking_url field from impbus request.
	     * @param {object} options - publisher options.
	     * 		  If adServerTimeout is present in options, VAST parser uses adServerTimeout value for loading wrapper xml instead of nMsecTimeout.
	     */
	    parse: function (strVastXml, fnCallback, id, nMsecTimeout, videoTrackers, impTracker, options) {
	        var parserObj = new VastParser(id, nMsecTimeout, options);
	        parserObj.parse(strVastXml, videoTrackers, impTracker,
	            function (succ, sourceId, data, arrErrorUrls, notifUrl) {
	                if (fnCallback) {
	                    fnCallback(succ, sourceId, data, arrErrorUrls, notifUrl);
	                }
	                parserObj = null;
	            });
	        return parserObj;
	    },

	    /** Describe Vast Unwrapping Entry Point Here.
	     * @param {object} parserData - object returned after successful parsing.
	     * @param {string} adToken - optional ad identificator used for debug mode
	     * @return {string} - unwrapped VAST xml.
	     */
	    getUnwrappedVastTag: function (parserData, adToken, notifyUrl, contentSource, buyerMemberId, viewabilityConfig, additionalTrackers, creativeId) {
	        if (!parserData || !parserData.vastXml) {
	            return null;
	        }
	        var obj = new VastModifier(parserData, adToken, notifyUrl, contentSource, buyerMemberId, viewabilityConfig, additionalTrackers, creativeId);
	        var xml = obj.addTrackers();
	        obj = null;
	        return xml;
	    },

	    /** Describe Vast Merging VAST XMLs Entry Point Here.
	     * @param {object} xmlListData - object containes XMLs and additional data:
	     *                    xml: VAST XML
	     *                    notifyUrl: notification url from impbus response
	     *                    buyerMemberId: buyer member idenfificator from impbus response
	     * @return {string} - merged VAST xml.
	     */
	    getMergedVastTag: function (xmlList) {
	        if (!xmlList || xmlList.length === 0) {
	            return null;
	        }
	        var obj = new VastMerger(xmlList);
	        var xml = obj.getVastXml();
	        obj = null;
	        return xml;
	    }
	};


/***/ }),
/* 6 */
/***/ (function(module, exports) {

	var XMLParserHelper = function () {
	    this.getSubNodes = function (node, subNodeName) {
	        var nodes = node.getElementsByTagName(subNodeName);
	        if (nodes.length > 0) {
	            return nodes;
	        }
	        return null;
	    };

	    this.getSubNode = function (node, subNodeName, index) {
	        if (!index) {
	            index = 0;
	        }
	        var nodes = node.getElementsByTagName(subNodeName);
	        if (nodes.length > index) {
	            return nodes[index];
	        }
	        return null;
	    };

	    this.getNodeValue = function (node) {
	        if (node.childNodes.length === 0) {
	            return '';
	        }
	        var val = node.childNodes[0].nodeValue;
	        if (val) {
	            return val.trim();
	        }
	        return '';
	    };

	    this.getNodeValues = function (node) {
	        if (node.childNodes.length === 0) {
	            return '';
	        }
	        var wholeVal = '';
	        for (var i = 0; i < node.childNodes.length; i++) {
	            var val = node.childNodes[i].nodeValue;
	            if (val) {
	            	wholeVal += val;
	            }
	        }
	        return wholeVal.trim();
	    };

	    this.getNodeAttributeValue = function (node, attributeName) {
	        var val = node.getAttribute(attributeName);
	        if (val === null) {
	            val = '';
	        }
	        return val;
	    };

	    this.getNodeAttributeNumberValue = function (node, attributeName, defaultValue) {
	        if (!defaultValue) {
	            defaultValue = 0;
	        }
	        var answer = defaultValue;
	        var val = this.getNodeAttributeValue(node, attributeName);

	        if (val.length > 0) {
	            if (val.indexOf('.') >= 0) {
	                answer = parseFloat(val);
	            }
	            else {
	                answer = parseInt(val);
	            }
	        }

	        return answer;
	    };

	    this.getNodeAttributeBooleanValue = function (node, attributeName, defaultValue) {
	        if (!defaultValue) {
	            defaultValue = false;
	        }
	        var answer = defaultValue;
	        var val = this.getNodeAttributeValue(node, attributeName);

	        if (val.length > 0) {
	            var char = val.toLowerCase().charAt(0);
	            answer = (char === 't');
	        }

	        return answer;
	    };

	    this.getSubNodeValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
	        var subnode = this.getSubNode(parentNode, subNodeName);
	        if (subnode !== null) {
	            return this.getNodeValue(subnode);
	        }
	        return defaultValue;
	    };

	    this.getSubNodeWholeValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
	        var subnode = this.getSubNode(parentNode, subNodeName);
	        if (subnode !== null) {
	            return this.getNodeValues(subnode);
	        }
	        return defaultValue;
	    };

	    this.getSubNodeBooleanValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? 'false' : defaultValue;

	        var value = this.getSubNodeValue(parentNode, subNodeName);
	        if (value.length > 0 && value.toLowerCase().charAt(0) === 't') {
	            return true;
	        }
	        if (value.length > 0 && value.toLowerCase().charAt(0) === 'f') {
	            return false;
	        }
	        return defaultValue;
	    };
	};

	module.exports = XMLParserHelper;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

	var CompanionAds = {

	    parse: function (companionAdsDest, companionAdsNode, helper) {
	        var req = helper.getNodeAttributeValue(companionAdsNode, 'required');
	        if (req && req.length > 0) {
	            companionAdsDest.required = req;
	        }

	        var nodes = helper.getSubNodes(companionAdsNode, 'Companion');
	        if (nodes) {
	            for (var i = 0; i < nodes.length; i++) {
	                var node = nodes[i];
	                //var companion = JSON.parse(JSON.stringify(APN_Companion));
	                var companion = {};

	                // required attributes
	                var width = helper.getNodeAttributeNumberValue(node, 'width', -1);
	                var height = helper.getNodeAttributeNumberValue(node, 'height', -1);
	                if (width <= 0 || height <= 0) {
	                    continue;
	                }
	                companion.width = width;
	                companion.height = height;

	                // optional attributes and subnodes
	                var val = helper.getNodeAttributeValue(node, 'id');
	                if (val) {
	                    companion.id = val;
	                }

	                val = helper.getNodeAttributeNumberValue(node, 'assetWidth', -1);
	                if (val > 0) {
	                    companion.assetWidth = val;
	                }

	                val = helper.getNodeAttributeNumberValue(node, 'assetHeight', -1);
	                if (val > 0) {
	                    companion.assetHeight = val;
	                }

	                val = helper.getNodeAttributeNumberValue(node, 'expandedWidth', -1);
	                if (val > 0) {
	                    companion.expandedWidth = val;
	                }

	                val = helper.getNodeAttributeNumberValue(node, 'expandedHeight', -1);
	                if (val > 0) {
	                    companion.expandedHeight = val;
	                }

	                val = helper.getNodeAttributeValue(node, 'apiFramework');
	                if (val) {
	                    companion.apiFramework = val;
	                }

	                val = helper.getNodeAttributeValue(node, 'adSlotID');
	                if (val) {
	                    companion.adSlotID = val;
	                }

	                var pxratio = helper.getNodeAttributeNumberValue(node, 'pxratio', 1.0);
	                if (pxratio !== 1.0) {
	                	companion.pxratio = pxratio;
	                }
	                
	                val = helper.getNodeAttributeValue(node, 'required');
	                if (val) {
	                    companion.required = val;
	                }

	                val = helper.getSubNodeValue(node, 'AltText');
	                if (val) {
	                    companion.AltText = val;
	                }

	                val = helper.getSubNodeValue(node, 'AdParameters');
	                if (val) {
	                    companion.AdParameters = val;
	                }

	                var resource = helper.getSubNode(node, 'StaticResource');
	                if (resource) {
	                    val = helper.getNodeAttributeValue(resource, 'creativeType');
	                    if (val) {
	                        // validate capability
	                        var flashOnlyType = val === 'video/x-flv' || val === 'video/x-f4v' || val === 'video/f4v' || val === 'application/x-shockwave-flash';
	                        var isMobile = false;
	                        if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
	                            isMobile = true;
	                        }
	                        if (isMobile && flashOnlyType) {
	                            // ignore this companion
	                            continue;
	                        }

	                        var staticResource = {type: val};
	                        val = helper.getNodeValues(resource);
	                        if (val) {
	                            staticResource.src = val;
	                            companion.StaticResource = staticResource;
	                        }
	                    }
	                }

	                val = helper.getSubNodeWholeValue(node, 'IFrameResource');
	                if (val) {
	                    companion.IFrameResource = val;
	                }

	                val = helper.getSubNodeWholeValue(node, 'HTMLResource');
	                if (val) {
	                    companion.HTMLResource = val;
	                }

	                val = helper.getSubNodeValue(node, 'CompanionClickThrough');
	                if (val) {
	                    companion.CompanionClickThrough = val;
	                }

	                var j;
	                var trackingNode;
	                var url;
	                var clickTrackinEvents = helper.getSubNodes(node, 'CompanionClickTracking');
	                if (clickTrackinEvents) {
	                    companion.CompanionClickTracking = [];
	                    for (j = 0; j < clickTrackinEvents.length; j++) {
	                        trackingNode = clickTrackinEvents[j];
	                        url = helper.getNodeValues(trackingNode);
	                        if (url) {
	                            companion.CompanionClickTracking.push(url);
	                        }
	                    }
	                }

	                var trackinEvents = helper.getSubNodes(node, 'Tracking');
	                if (trackinEvents) {
	                    companion.TrackingEvents = [];
	                    for (j = 0; j < trackinEvents.length; j++) {
	                        trackingNode = trackinEvents[j];
	                        var event = helper.getNodeAttributeValue(trackingNode, 'event');
	                        url = helper.getNodeValues(trackingNode);
	                        if (event && url) {
	                            companion.TrackingEvents.push({eventType: event, url: url});
	                        }
	                    }
	                }

	                companionAdsDest.companions.push(companion);
	            }
	        }
	    },

	    mergeCompanions: function (companionAdsDest, companionAds) {
	        if (companionAdsDest.required === 'unknown') {
	            companionAdsDest.required = companionAds.required;
	        }
	        companionAdsDest.companions = companionAdsDest.companions.concat(companionAds.companions);
	    },

	    createCompanionNode: function (xmlDoc, data) {
	        var companion = xmlDoc.createElement('Companion');
	        var i;
	        var elem;
	        var attr;
	        var cdata;

	        var arrAttrs = ['id', 'width', 'height', 'assetWidth', 'assetHeight', 'expandedWidth', 'expandedHeight',
	            'apiFramework', 'adSlotID', 'required'];
	        for (i = 0; i < arrAttrs.length; i++) {
	            if (data.hasOwnProperty(arrAttrs[i])) {
	                attr = xmlDoc.createAttribute(arrAttrs[i]);
	                attr.value = data[arrAttrs[i]];
	                companion.setAttributeNode(attr);
	            }
	        }

	        if (data.hasOwnProperty('StaticResource')) {
	            elem = xmlDoc.createElement('StaticResource');
	            attr = xmlDoc.createAttribute('creativeType');
	            attr.value = data.StaticResource.type;
	            elem.setAttributeNode(attr);
	            cdata = xmlDoc.createCDATASection(data.StaticResource.src);
	            elem.appendChild(cdata);
	            companion.appendChild(elem);
	        }

	        var arrNodes = ['AdParameters', 'IFrameResource', 'HTMLResource', 'CompanionClickThrough'];
	        for (i = 0; i < arrNodes.length; i++) {
	            if (data.hasOwnProperty(arrNodes[i])) {
	                elem = xmlDoc.createElement(arrNodes[i]);
	                cdata = xmlDoc.createCDATASection(data[arrNodes[i]]);
	                elem.appendChild(cdata);
	                companion.appendChild(elem);
	            }
	        }

	        if (data.hasOwnProperty('AltText')) {
	            elem = xmlDoc.createElement('AltText');
	            try {
	                elem.innerHTML = data.AltText;
	            }
	            catch (ex) {
	                // IE 11 does not allow set innerHTML property
	                try {
	                    elem.textContent = data.AltText;
	                }
	                catch (ex2) {

	                }
	            }
	            companion.appendChild(elem);
	        }

	        if (data.hasOwnProperty('CompanionClickTracking')) {
	            for (i = 0; i < data.CompanionClickTracking.length; i++) {
	                var tracking = xmlDoc.createElement('CompanionClickTracking');
	                cdata = xmlDoc.createCDATASection(data.CompanionClickTracking[i]);
	                tracking.appendChild(cdata);
	                companion.appendChild(tracking);
	            }
	        }

	        if (data.hasOwnProperty('TrackingEvents')) {
	            elem = xmlDoc.createElement('TrackingEvents');
	            // enumerate trackers
	            for (i = 0; i < data.TrackingEvents.length; i++) {
	                var event = xmlDoc.createElement('Tracking');
	                attr = xmlDoc.createAttribute('event');
	                attr.value = data.TrackingEvents[i].eventType;
	                event.setAttributeNode(attr);
	                cdata = xmlDoc.createCDATASection(data.TrackingEvents[i].url);
	                event.appendChild(cdata);
	                elem.appendChild(event);
	            }
	            companion.appendChild(elem);
	        }

	        return companion;
	    }
	};

	module.exports = CompanionAds;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	var Icons = {

	    parse: function (IconsDest, IconsNode, helper) {
	        var nodes = helper.getSubNodes(IconsNode, 'Icon');
	        if (nodes) {
	            for (var i = 0; i < nodes.length; i++) {
	                var node = nodes[i];
	                var icon = {};

	                // required attributes
	                var width = helper.getNodeAttributeNumberValue(node, 'width', -1);
	                var height = helper.getNodeAttributeNumberValue(node, 'height', -1);
	                var program = helper.getNodeAttributeValue(node, 'program');
	                var xPosition = helper.getNodeAttributeValue(node, 'xPosition');
	                var yPosition = helper.getNodeAttributeValue(node, 'yPosition');
	                if (width <= 0 || height <= 0 || program.length === 0 || xPosition.length === 0 || yPosition.length === 0) {
	                    continue;
	                }
	                icon.width = width;
	                icon.height = height;
	                icon.program = program;
	                icon.xPosition = xPosition;
	                icon.yPosition = yPosition;

	                // optional attributes and subnodes
	                var val = helper.getNodeAttributeValue(node, 'apiFramework');
	                if (val) {
	                    icon.apiFramework = val;
	                }

	                var pxratio = helper.getNodeAttributeNumberValue(node, 'pxratio', 1.0);
	                if (pxratio !== 1.0) {
	                	icon.pxratio = pxratio;
	                }
	                
	                val = helper.getNodeAttributeValue(node, 'offset');
	                if (val) {
	                    // validate
	                    if (isNaN(Date.parse('January 1, 1970 ' + val))) {
	                        // invalid time format
	                        continue;
	                    }
	                    icon.offset = val;
	                }

	                val = helper.getNodeAttributeValue(node, 'duration');
	                if (val) {
	                    // validate
	                    if (isNaN(Date.parse('January 1, 1970 ' + val))) {
	                        // invalid time format
	                        continue;
	                    }
	                    icon.duration = val;
	                }

	                var resource = helper.getSubNode(node, 'StaticResource');
	                if (resource) {
	                    val = helper.getNodeAttributeValue(resource, 'creativeType');
	                    if (val) {
	                        // validate capability
	                        var flashOnlyType = val === 'video/x-flv' || val === 'video/x-f4v' || val === 'video/f4v' || val === 'application/x-shockwave-flash';
	                        var isMobile = false;
	                        if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
	                            isMobile = true;
	                        }
	                        if (isMobile && flashOnlyType) {
	                            // ignore this companion
	                            continue;
	                        }

	                        var staticResource = {type: val};
	                        val = helper.getNodeValues(resource);
	                        if (val) {
	                            staticResource.src = val;
	                            icon.StaticResource = staticResource;
	                        }
	                    }
	                }

	                val = helper.getSubNodeWholeValue(node, 'IFrameResource');
	                if (val) {
	                    icon.IFrameResource = val;
	                }

	                val = helper.getSubNodeWholeValue(node, 'HTMLResource');
	                if (val) {
	                    icon.HTMLResource = val;
	                }
	                
	                // icon must contain a resource
	                if (!icon.StaticResource && !icon.IFrameResource && !icon.HTMLResource) {
	                	continue;
	                }

	                var iconClicks = helper.getSubNode(node, 'IconClicks');
	                if (iconClicks) {
	                    val = helper.getSubNodeValue(node, 'IconClickThrough');
	                    if (val) {
	                        icon.IconClickThrough = val;
	                    }

	                    //IconClickTracking can be multiple by a VAST3.0 spec 2.4.3.5 Icon Clicks and Tracking
	                    val = helper.getSubNodes(iconClicks, 'IconClickTracking');
	                    if (val) {
	                        icon.IconClickTracking = [];
	                        for (var cntIconClick = 0; cntIconClick < val.length; cntIconClick++) {
	                            icon.IconClickTracking.push(helper.getNodeValues(val[cntIconClick]));
	                        }
	                    }
	                }

	                /* VAST3 XML schema explains IconViewTracking can be multiple like below
	                 <xs:element name="IconViewTracking" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded">
	                 <xs:annotation>
	                 <xs:documentation>URLs to ping when icon is shown.</xs:documentation>
	                 </xs:annotation>
	                 </xs:element>
	                 */
	                var iconViewTracking = helper.getSubNodes(node, 'IconViewTracking');
	                if (iconViewTracking) {
	                    icon.IconViewTracking = [];
	                    for (var cntIconView = 0; cntIconView < iconViewTracking.length; cntIconView++) {
	                        icon.IconViewTracking.push(helper.getNodeValues(iconViewTracking[cntIconView]));
	                    }
	                }


	                var removeExistingProgram = function (IconsDest, program) {
	                    for (var cntIconDest = 0; cntIconDest < IconsDest.length; cntIconDest++) {
	                        if (IconsDest[cntIconDest].program === program) {
	                            IconsDest.splice(cntIconDest, 1);
	                        }
	                    }
	                };

	                //VIDLA-625 if same program exists in Icons node last one will be used.
	                removeExistingProgram(IconsDest, program);

	                IconsDest.push(icon);

	            }
	        }
	    },

	    createIconNode: function (xmlDoc, data) {
	        var icon = xmlDoc.createElement('Icon');
	        var i;
	        var elem;
	        var attr;
	        var cdata;

	        var arrAttrs = ['width', 'height', 'program', 'xPosition', 'yPosition', 'apiFramework', 'offset', 'duration'];
	        for (i = 0; i < arrAttrs.length; i++) {
	            if (data.hasOwnProperty(arrAttrs[i])) {
	                attr = xmlDoc.createAttribute(arrAttrs[i]);
	                attr.value = data[arrAttrs[i]];
	                icon.setAttributeNode(attr);
	            }
	        }

	        if (data.hasOwnProperty('StaticResource')) {
	            elem = xmlDoc.createElement('StaticResource');
	            attr = xmlDoc.createAttribute('creativeType');
	            attr.value = data.StaticResource.type;
	            elem.setAttributeNode(attr);
	            cdata = xmlDoc.createCDATASection(data.StaticResource.src);
	            elem.appendChild(cdata);
	            icon.appendChild(elem);
	        }

	        var arrNodes = ['IFrameResource', 'HTMLResource', 'IconViewTracking'];
	        for (i = 0; i < arrNodes.length; i++) {
	            if (data.hasOwnProperty(arrNodes[i])) {
	                elem = xmlDoc.createElement(arrNodes[i]);
	                cdata = xmlDoc.createCDATASection(data[arrNodes[i]]);
	                elem.appendChild(cdata);
	                icon.appendChild(elem);
	            }
	        }

	        if (data.hasOwnProperty('IconClickThrough') || data.hasOwnProperty('IconClickTracking')) {
	            var iconClicks = xmlDoc.createElement('IconClicks');
	            if (data.hasOwnProperty('IconClickThrough')) {
	                elem = xmlDoc.createElement('IconClickThrough');
	                cdata = xmlDoc.createCDATASection(data.IconClickThrough);
	                elem.appendChild(cdata);
	                iconClicks.appendChild(elem);
	            }
	            if (data.hasOwnProperty('IconClickTracking')) {
	                elem = xmlDoc.createElement('IconClickTracking');
	                cdata = xmlDoc.createCDATASection(data.IconClickTracking);
	                elem.appendChild(cdata);
	                iconClicks.appendChild(elem);
	            }
	            icon.appendChild(iconClicks);
	        }

	        return icon;
	    }
	};

	module.exports = Icons;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright © 2012-2016 Faisal Salman <fyzlman@gmail.com>
	 * Dual licensed under GPLv2 & MIT
	 *
	 * User-Agent Parser module.
	 * @module UserAgentParser
	*/

	var prefixOfLog = 'UserAgentParser';
	var APN_Logger = __webpack_require__(3);

	APN_Logger.always(prefixOfLog, 'Version 0.0.1');

	/////////////////
	// Constructor
	////////////////
	var UserAgentParser = function (uastring, extensions) {

		//////////////
		// Constants
		/////////////
		var EMPTY       = '',
		    UNKNOWN     = '?',
		    FUNC_TYPE   = 'function',
		    OBJ_TYPE    = 'object',
		    STR_TYPE    = 'string',
		    MODEL       = 'model',
		    NAME        = 'name',
		    TYPE        = 'type',
		    VENDOR      = 'vendor',
		    VERSION     = 'version',
		    CONSOLE     = 'console',
		    MOBILE      = 'mobile',
		    TABLET      = 'tablet',
		    SMARTTV     = 'smarttv',
		    WEARABLE    = 'wearable';

		///////////
		// Helper
		//////////
		var util = {
		    extend : function (regexes, extensions) {
		        var margedRegexes = {};
		        for (var i in regexes) {
		            if (extensions[i] && extensions[i].length % 2 === 0) {
		                margedRegexes[i] = extensions[i].concat(regexes[i]);
		            } else {
		                margedRegexes[i] = regexes[i];
		            }
		        }
		        return margedRegexes;
		    },
		    has : function (str1, str2) {
		      if (typeof str1 === 'string') {
		        return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
		      } else {
		        return false;
		      }
		    },
		    lowerize : function (str) {
		        return str.toLowerCase();
		    },
		    major : function (version) {
		        return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g,'').split('.')[0] : undefined;
		    },
		    trim : function (str) {
		      return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
		    }
		};

	    ///////////////
	    // Map helper
	    //////////////
	    var mapper = {

	        rgx : function () {

	            var result = {}, i = 0, j, k, p, q, matches, match, args = arguments;

	            // construct object barebones
	            for (p = 0; p < args[1].length; p++) {
	                q = args[1][p];
	                result[typeof q === OBJ_TYPE ? q[0] : q] = undefined;
	            }

	            // loop through all regexes maps
	            while (i < args.length && !matches) {

	                var regex = args[i],       // even sequence (0,2,4,..)
	                    props = args[i + 1];   // odd sequence (1,3,5,..)
	                j = k = 0;

	                // try matching uastring with regexes
	                while (j < regex.length && !matches) {

	                    matches = regex[j++].exec(this.getUA());

	                    if (!!matches) {
	                        for (p = 0; p < props.length; p++) {
	                            match = matches[++k];
	                            q = props[p];
	                            // check if given property is actually array
	                            if (typeof q === OBJ_TYPE && q.length > 0) {
	                                if (q.length === 2) {
	                                    if (typeof q[1] === FUNC_TYPE) {
	                                        // assign modified match
	                                        result[q[0]] = q[1].call(this, match);
	                                    } else {
	                                        // assign given value, ignore regex match
	                                        result[q[0]] = q[1];
	                                    }
	                                } else if (q.length === 3) {
	                                    // check whether function or regex
	                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
	                                        // call function (usually string mapper)
	                                        result[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
	                                    } else {
	                                        // sanitize match using given regex
	                                        result[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
	                                    }
	                                } else if (q.length === 4) {
	                                        result[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
	                                }
	                            } else {
	                                result[q] = match ? match : undefined;
	                            }
	                        }
	                    }
	                }
	                i += 2;
	            }
	            return result;
	        },

	        str : function (str, map) {

	            for (var i in map) {
	                // check if array
	                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
	                    for (var j = 0; j < map[i].length; j++) {
	                        if (util.has(map[i][j], str)) {
	                            return (i === UNKNOWN) ? undefined : i;
	                        }
	                    }
	                } else if (util.has(map[i], str)) {
	                    return (i === UNKNOWN) ? undefined : i;
	                }
	            }
	            return str;
	        }
	    };

	    ///////////////
	    // String map
	    //////////////
	    var maps = {

	        browser : {
	            oldsafari : {
	                version : {
	                    '1.0'   : '/8',
	                    '1.2'   : '/1',
	                    '1.3'   : '/3',
	                    '2.0'   : '/412',
	                    '2.0.2' : '/416',
	                    '2.0.3' : '/417',
	                    '2.0.4' : '/419',
	                    '?'     : '/'
	                }
	            }
	        },

	        device : {
	            amazon : {
	                model : {
	                    'Fire Phone' : ['SD', 'KF']
	                }
	            },
	            sprint : {
	                model : {
	                    'Evo Shift 4G' : '7373KT'
	                },
	                vendor : {
	                    'HTC'       : 'APA',
	                    'Sprint'    : 'Sprint'
	                }
	            }
	        },

	        os : {
	            windows : {
	                version : {
	                    'XP'        : ['NT 5.1', 'NT 5.2'],
	                    'Vista'     : 'NT 6.0',
	                    '7'         : 'NT 6.1',
	                    '8'         : 'NT 6.2',
	                    '8.1'       : 'NT 6.3',
	                    '10'        : ['NT 6.4', 'NT 10.0'],
	                    'RT'        : 'ARM'
	                }
	            }
	        }
	    };

	    //////////////
	    // Regex map
	    /////////////


	    var regexes = {

	        browser : [[

	            // Presto based
	            /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
	            /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,                      // Opera Mobi/Tablet
	            /(opera).+version\/([\w\.]+)/i,                                     // Opera > 9.80
	            /(opera)[\/\s]+([\w\.]+)/i                                          // Opera < 9.80
	            ], [NAME, VERSION], [

	            /(opios)[\/\s]+([\w\.]+)/i                                          // Opera mini on iphone >= 8.0
	            ], [[NAME, 'Opera Mini'], VERSION], [

	            /\s(opr)\/([\w\.]+)/i                                               // Opera Webkit
	            ], [[NAME, 'Opera'], VERSION], [

	            // Mixed
	            /(kindle)\/([\w\.]+)/i,                                             // Kindle
	            /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]+)*/i,
	                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer

	            // Trident based
	            /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,
	                                                                                // Avant/IEMobile/SlimBrowser/Baidu
	            /(?:ms|\()(ie)\s([\w\.]+)/i,                                        // Internet Explorer

	            // Webkit/KHTML based
	            /(rekonq)\/([\w\.]+)*/i,                                            // Rekonq
	            /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs)\/([\w\.-]+)/i
	                                                                                // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS
	            ], [NAME, VERSION], [

	            /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i                         // IE11
	            ], [[NAME, 'IE'], VERSION], [

	            /(edge)\/((\d+)?[\w\.]+)/i                                          // Microsoft Edge
	            ], [NAME, VERSION], [

	            /(yabrowser)\/([\w\.]+)/i                                           // Yandex
	            ], [[NAME, 'Yandex'], VERSION], [

	            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
	            ], [[NAME, /_/g, ' '], VERSION], [

	            /(micromessenger)\/([\w\.]+)/i                                      // WeChat
	            ], [[NAME, 'WeChat'], VERSION], [

	            /xiaomi\/miuibrowser\/([\w\.]+)/i                                   // MIUI Browser
	            ], [VERSION, [NAME, 'MIUI Browser']], [

	            /\swv\).+(chrome)\/([\w\.]+)/i                                      // Chrome WebView
	            ], [[NAME, /(.+)/, '$1 WebView'], VERSION], [

	            /android.+samsungbrowser\/([\w\.]+)/i,
	            /android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i        // Android Browser
	            ], [VERSION, [NAME, 'Android Browser']], [

	            /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i,
	                                                                                // Chrome/OmniWeb/Arora/Tizen/Nokia
	            /(qqbrowser)[\/\s]?([\w\.]+)/i
	                                                                                // QQBrowser
	            ], [NAME, VERSION], [

	            /(uc\s?browser)[\/\s]?([\w\.]+)/i,
	            /ucweb.+(ucbrowser)[\/\s]?([\w\.]+)/i,
	            /juc.+(ucweb)[\/\s]?([\w\.]+)/i
	                                                                                // UCBrowser
	            ], [[NAME, 'UCBrowser'], VERSION], [

	            /(dolfin)\/([\w\.]+)/i                                              // Dolphin
	            ], [[NAME, 'Dolphin'], VERSION], [

	            /((?:android.+)crmo|crios)\/([\w\.]+)/i                             // Chrome for Android/iOS
	            ], [[NAME, 'Chrome'], VERSION], [

	            /;fbav\/([\w\.]+);/i                                                // Facebook App for iOS
	            ], [VERSION, [NAME, 'Facebook']], [

	            /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
	            ], [VERSION, [NAME, 'Firefox']], [

	            /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i                       // Mobile Safari
	            ], [VERSION, [NAME, 'Mobile Safari']], [

	            /version\/([\w\.]+).+?(mobile\s?safari|safari)/i                    // Safari & Safari Mobile
	            ], [VERSION, NAME], [

	            /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
	            ], [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]], [

	            /(konqueror)\/([\w\.]+)/i,                                          // Konqueror
	            /(webkit|khtml)\/([\w\.]+)/i
	            ], [NAME, VERSION], [

	            // Gecko based
	            /(navigator|netscape)\/([\w\.-]+)/i                                 // Netscape
	            ], [[NAME, 'Netscape'], VERSION], [
	            /(swiftfox)/i,                                                      // Swiftfox
	            /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,
	                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
	            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/([\w\.-]+)/i,
	                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
	            /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,                          // Mozilla

	            // Other
	            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
	                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir
	            /(links)\s\(([\w\.]+)/i,                                            // Links
	            /(gobrowser)\/?([\w\.]+)*/i,                                        // GoBrowser
	            /(ice\s?browser)\/v?([\w\._]+)/i,                                   // ICE Browser
	            /(mosaic)[\/\s]([\w\.]+)/i                                          // Mosaic
	            ], [NAME, VERSION]
	        ],

	        device : [[

	            /\((ipad|playbook);[\w\s\);-]+(rim|apple)/i                         // iPad/PlayBook
	            ], [MODEL, VENDOR, [TYPE, TABLET]], [

	            /applecoremedia\/[\w\.]+ \((ipad)/                                  // iPad
	            ], [MODEL, [VENDOR, 'Apple'], [TYPE, TABLET]], [

	            /(apple\s{0,1}tv)/i                                                 // Apple TV
	            ], [[MODEL, 'Apple TV'], [VENDOR, 'Apple']], [

	            /(archos)\s(gamepad2?)/i,                                           // Archos
	            /(hp).+(touchpad)/i,                                                // HP TouchPad
	            /(hp).+(tablet)/i,                                                  // HP Tablet
	            /(kindle)\/([\w\.]+)/i,                                             // Kindle
	            /\s(nook)[\w\s]+build\/(\w+)/i,                                     // Nook
	            /(dell)\s(strea[kpr\s\d]*[\dko])/i                                  // Dell Streak
	            ], [VENDOR, MODEL, [TYPE, TABLET]], [

	            /(kf[A-z]+)\sbuild\/[\w\.]+.*silk\//i                               // Kindle Fire HD
	            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
	            /(sd|kf)[0349hijorstuw]+\sbuild\/[\w\.]+.*silk\//i                  // Fire Phone
	            ], [[MODEL, mapper.str, maps.device.amazon.model], [VENDOR, 'Amazon'], [TYPE, MOBILE]], [

	            /\((ip[honed|\s\w*]+);.+(apple)/i                                   // iPod/iPhone
	            ], [MODEL, VENDOR, [TYPE, MOBILE]], [
	            /\((ip[honed|\s\w*]+);/i                                            // iPod/iPhone
	            ], [MODEL, [VENDOR, 'Apple'], [TYPE, MOBILE]], [

	            /(blackberry)[\s-]?(\w+)/i,                                         // BlackBerry
	            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|huawei|meizu|motorola|polytron)[\s_-]?([\w-]+)*/i,
	                                                                                // BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Huawei/Meizu/Motorola/Polytron
	            /(hp)\s([\w\s]+\w)/i,                                               // HP iPAQ
	            /(asus)-?(\w+)/i                                                    // Asus
	            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
	            /\(bb10;\s(\w+)/i                                                   // BlackBerry 10
	            ], [MODEL, [VENDOR, 'BlackBerry'], [TYPE, MOBILE]], [
	                                                                                // Asus Tablets
	            /android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i
	            ], [MODEL, [VENDOR, 'Asus'], [TYPE, TABLET]], [

	            /(sony)\s(tablet\s[ps])\sbuild\//i,                                  // Sony
	            /(sony)?(?:sgp.+)\sbuild\//i
	            ], [[VENDOR, 'Sony'], [MODEL, 'Xperia Tablet'], [TYPE, TABLET]], [
	            /(?:sony)?(?:(?:(?:c|d)\d{4})|(?:so[-l].+))\sbuild\//i
	            ], [[VENDOR, 'Sony'], [MODEL, 'Xperia Phone'], [TYPE, MOBILE]], [

	            /\s(ouya)\s/i,                                                      // Ouya
	            /(nintendo)\s([wids3u]+)/i                                          // Nintendo
	            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [

	            /android.+;\s(shield)\sbuild/i                                      // Nvidia
	            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [

	            /(playstation\s[34portablevi]+)/i                                   // Playstation
	            ], [MODEL, [VENDOR, 'Sony'], [TYPE, CONSOLE]], [

	            /(sprint\s(\w+))/i                                                  // Sprint Phones
	            ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [

	            /(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i                         // Lenovo tablets
	            ], [VENDOR, MODEL, [TYPE, TABLET]], [

	            /(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i,                               // HTC
	            /(zte)-(\w+)*/i,                                                    // ZTE
	            /(alcatel|geeksphone|huawei|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]+)*/i
	                                                                                // Alcatel/GeeksPhone/Huawei/Lenovo/Nexian/Panasonic/Sony
	            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

	            /(nexus\s9)/i                                                       // HTC Nexus 9
	            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [

	            /(nexus\s6p)/i                                                      // Huawei Nexus 6P
	            ], [MODEL, [VENDOR, 'Huawei'], [TYPE, MOBILE]], [

	            /(microsoft);\s(lumia[\s\w]+)/i                                     // Microsoft Lumia
	            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

	            /[\s\(;](xbox(?:\sone)?)[\s\);]/i                                   // Microsoft Xbox
	            ], [MODEL, [VENDOR, 'Microsoft'], [TYPE, CONSOLE]], [
	            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
	            ], [[MODEL, /\./g, ' '], [VENDOR, 'Microsoft'], [TYPE, MOBILE]], [

	                                                                                // Motorola
	            /\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?(:?\s4g)?)[\w\s]+build\//i,
	            /mot[\s-]?(\w+)*/i,
	            /(XT\d{3,4}) build\//i,
	            /(nexus\s6)/i
	            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, MOBILE]], [
	            /android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i
	            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, TABLET]], [

	            /hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i            // HbbTV devices
	            ], [[VENDOR, util.trim], [MODEL, util.trim], [TYPE, SMARTTV]], [

	            /hbbtv.+maple;(\d+)/i
	            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, 'Samsung'], [TYPE, SMARTTV]], [

	            /\(dtv[\);].+(aquos)/i                                              // Sharp
	            ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [

	            /android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,
	            /((SM-T\w+))/i
	            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, TABLET]], [                  // Samsung
	            /smart-tv.+(samsung)/i
	            ], [VENDOR, [TYPE, SMARTTV], MODEL], [
	            /((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,
	            /(sam[sung]*)[\s-]*(\w+-?[\w-]*)*/i,
	            /sec-((sgh\w+))/i
	            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, MOBILE]], [

	            /sie-(\w+)*/i                                                       // Siemens
	            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [

	            /(maemo|nokia).*(n900|lumia\s\d+)/i,                                // Nokia
	            /(nokia)[\s_-]?([\w-]+)*/i
	            ], [[VENDOR, 'Nokia'], MODEL, [TYPE, MOBILE]], [

	            /android\s3\.[\s\w;-]{10}(a\d{3})/i                                 // Acer
	            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

	            /android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i                     // LG Tablet
	            ], [[VENDOR, 'LG'], MODEL, [TYPE, TABLET]], [
	            /(lg) netcast\.tv/i                                                 // LG SmartTV
	            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
	            /(nexus\s[45])/i,                                                   // LG
	            /lg[e;\s\/-]+(\w+)*/i
	            ], [MODEL, [VENDOR, 'LG'], [TYPE, MOBILE]], [

	            /android.+(ideatab[a-z0-9\-\s]+)/i                                  // Lenovo
	            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [

	            /linux;.+((jolla));/i                                               // Jolla
	            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

	            /((pebble))app\/[\d\.]+\s/i                                         // Pebble
	            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [

	            /android.+;\s(glass)\s\d/i                                          // Google Glass
	            ], [MODEL, [VENDOR, 'Google'], [TYPE, WEARABLE]], [

	            /android.+;\s(pixel c)\s/i                                          // Google Pixel C
	            ], [MODEL, [VENDOR, 'Google'], [TYPE, TABLET]], [

	            /android.+;\s(pixel xl|pixel)\s/i                                   // Google Pixel
	            ], [MODEL, [VENDOR, 'Google'], [TYPE, MOBILE]], [


	            /android.+(\w+)\s+build\/hm\1/i,                                    // Xiaomi Hongmi 'numeric' models
	            /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,               // Xiaomi Hongmi
	            /android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d\w)?)\s+build/i    // Xiaomi Mi
	            ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [

	            /android.+a000(1)\s+build/i                                         // OnePlus
	            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [

	            /\s(tablet)[;\/]/i,                                                 // Unidentifiable Tablet
	            /\s(mobile)(?:[;\/]|\ssafari)/i                                     // Unidentifiable Mobile
	            ], [[TYPE, util.lowerize], VENDOR, MODEL]
	        ],

	        engine : [[

	            /windows.+\sedge\/([\w\.]+)/i                                       // EdgeHTML
	            ], [VERSION, [NAME, 'EdgeHTML']], [

	            /(presto)\/([\w\.]+)/i,                                             // Presto
	            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,     // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m
	            /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,                          // KHTML/Tasman/Links
	            /(icab)[\/\s]([23]\.[\d\.]+)/i                                      // iCab
	            ], [NAME, VERSION], [

	            /rv\:([\w\.]+).*(gecko)/i                                           // Gecko
	            ], [VERSION, NAME]
	        ],

	        os : [[

	            // Windows based
	            /microsoft\s(windows)\s(vista|xp)/i                                 // Windows (iTunes)
	            ], [NAME, VERSION], [
	            /(windows)\snt\s6\.2;\s(arm)/i,                                     // Windows RT
	            /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s]+\w)*/i,                  // Windows Phone
	            /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i
	            ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [
	            /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i
	            ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [

	            // Mobile/Embedded OS
	            /\((bb)(10);/i                                                      // BlackBerry 10
	            ], [[NAME, 'BlackBerry'], VERSION], [
	            /(blackberry)\w*\/?([\w\.]+)*/i,                                    // Blackberry
	            /(tizen)[\/\s]([\w\.]+)/i,                                          // Tizen
	            /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]+)*/i,
	                                                                                // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki
	            /linux;.+(sailfish);/i                                              // Sailfish OS
	            ], [NAME, VERSION], [
	            /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i                 // Symbian
	            ], [[NAME, 'Symbian'], VERSION], [
	            /\((series40);/i                                                    // Series 40
	            ], [NAME], [
	            /mozilla.+\(mobile;.+gecko.+firefox/i                               // Firefox OS
	            ], [[NAME, 'Firefox OS'], VERSION], [

	            // Console
	            /(nintendo|playstation)\s([wids34portablevu]+)/i,                   // Nintendo/Playstation

	            // GNU/Linux based
	            /(mint)[\/\s\(]?(\w+)*/i,                                           // Mint
	            /(mageia|vectorlinux)[;\s]/i,                                       // Mageia/VectorLinux
	            /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]+)*/i,
	                                                                                // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware
	                                                                                // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus
	            /(hurd|linux)\s?([\w\.]+)*/i,                                       // Hurd/Linux
	            /(gnu)\s?([\w\.]+)*/i                                               // GNU
	            ], [NAME, VERSION], [

	            /(cros)\s[\w]+\s([\w\.]+\w)/i                                       // Chromium OS
	            ], [[NAME, 'Chromium OS'], VERSION],[

	            // Solaris
	            /(sunos)\s?([\w\.]+\d)*/i                                           // Solaris
	            ], [[NAME, 'Solaris'], VERSION], [

	            // BSD based
	            /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i                   // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly
	            ], [NAME, VERSION],[

	            /(haiku)\s(\w+)/i                                                  // Haiku
	            ], [NAME, VERSION],[

	            /(ip[honead]+)(?:.*os\s([\w]+)*\slike\smac|;\sopera)/i              // iOS
	            ], [[NAME, 'iOS'], [VERSION, /_/g, '.']], [

	            /(mac\sos\sx)\s?([\w\s\.]+\w)*/i,
	            /(macintosh|mac(?=_powerpc)\s)/i                                    // Mac OS
	            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [

	            // Other
	            /((?:open)?solaris)[\/\s-]?([\w\.]+)*/i,                            // Solaris
	            /(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i,                               // AIX
	            /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i,
	                                                                                // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS
	            /(unix)\s?([\w\.]+)*/i                                              // UNIX
	            ], [NAME, VERSION]
	        ]
	    };

		
	    if (!(this instanceof UserAgentParser)) {
	        return new UserAgentParser(uastring, extensions).getResult();
	    }

	    var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
	    var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;

	    this.getBrowser = function () {
	        var browser = mapper.rgx.apply(this, rgxmap.browser);
	        browser.major = util.major(browser.version);
	        return browser;
	    };
	    this.getDevice = function () {
	        return mapper.rgx.apply(this, rgxmap.device);
	    };
	    this.getEngine = function () {
	        return mapper.rgx.apply(this, rgxmap.engine);
	    };
	    this.getOS = function () {
	        return mapper.rgx.apply(this, rgxmap.os);
	    };
	    this.getResult = function () {
	        return {
	            ua      : this.getUA(),
	            browser : this.getBrowser(),
	            engine  : this.getEngine(),
	            os      : this.getOS(),
	            device  : this.getDevice()
	        };
	    };
	    this.getUA = function () {
	        return ua;
	    };
	    return this;
	};

	module.exports = UserAgentParser;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	var prefixOfLog = "CapabilityDetection";
	var APN_Logger = __webpack_require__(3);
	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog,message);
	};


	/**
	 * Capability Detection module.
	 * @module CapabilityDetection
	 */

	function isMobile(){
	    if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
	        return true;
	    }
	    return false;
	}

	function hasFlashPlugin(){
	    var flash_installed = typeof navigator.plugins !== 'undefined' && typeof navigator.plugins['Shockwave Flash'] === 'object';
	    if (!flash_installed) {
	        flash_installed = window.ActiveXObject && (new ActiveXObject('ShockwaveFlash.ShockwaveFlash'));
	    }
	    return flash_installed;
	}

	function isFlashOnlyType(type) {
	    return type === 'video/x-flv' || type === 'video/x-f4v' || type === 'video/f4v' ||
	        type === 'application/x-shockwave-flash';
	}

	function isHtml5VpaidType(type) {
	    return type === 'application/javascript' || type === 'application/x-javascript';
	}

	function isIphone() {
	    var isFlag = (/iphone/i.test(navigator.userAgent.toLowerCase()));
	    return isFlag;
	}

	function isIos() {
	    var isFlag = isIphone() || (/ipad/i.test(navigator.userAgent.toLowerCase()));
	    return isFlag;
	}

	function isAndroid() {
	    return (/android/i.test(navigator.userAgent.toLowerCase()));
	}

	module.exports = {
	    /** Checks for Flash support.
	     * @returns {boolean} True is flash is supported, false otherwise.
	     */
	    supportsFlash: function() {
	        return !isMobile() && hasFlashPlugin();
	    },

	    /** Detects browser on mobile devices.
	     * @returns {boolean} True is browser on mobile, false otherwise.
	     */
	    isBrowserOnMobile: function() {
	        return isMobile();
	    },

	    /** Detects browser.
	     * @returns {string} browser name.
	     */
	    getBrowserName: function() {
	        var ua = navigator.userAgent,
	            tem,
	            M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

	        if (/trident/i.test(M[1])) {
	            tem =/\brv[ :]+(\d+)/g.exec(ua) || [];
	            return 'IE';
	        }
	        if (M[1] === 'Chrome') {
	            tem = ua.match(/\bOPR\/(\d+)/);
	            if (tem !== null) {
	                return 'Opera';
	            }
	        }
	        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
	        if ((tem = ua.match(/version\/(\d+)/i)) !== null) {
	            M.splice(1,1,tem[1]);
	        }
	        return M[0];
	    },

	    /** Detects is video type playable for particular browser.
	     * @param {string} mimeType - media type from VAST xml.
	     * @param {string} codec - codec from VAST xml if present.
	     * @returns {boolean} True if playable, false otherwise.
	     */
	    canPlay: function(mimeType, codec) {

	        //VIDLA-139
	        //Edge browser can have error when calling canPlayType method in video element - this is suggested safe way for all browsers reffered by https://developer.microsoft.com/en-us/microsoft-edge/platform/documentation/dev-guide/html5/video/
	        var wrapperOfCanPlayType = function(vid, type, codec) {
	            debug("invoke canPlayType with video(" + vid + ") and type(" + type + ") and codec(" + codec + ")");
	            if (vid && vid.canPlayType) {
	                var result = vid.canPlayType(type + ';codecs="' + codec + '"');
	                debug("result : " + result);
	                return result;
	            } else {
	                debug("result : failed to invoke canPlayType with " + vid);
	                return "";
	            }
	        };

	        var alternativeCodec = null;
	        if (isFlashOnlyType(mimeType.toLowerCase())) {
	            return !isMobile() && hasFlashPlugin();
	        }
	        else if (isHtml5VpaidType(mimeType.toLowerCase())) {
	            return true;		// always allow to play html5 vpaid
	        }
	        else {
	            var type = mimeType.toLowerCase();
	            if (!codec || codec === '') {
	                if (type === 'video/mp4') {
	                    codec = 'avc1.42E01E,mp4a.40.2';
	                    //only test with video codec for alternativeCodec
	                    alternativeCodec = 'avc1.42E01E';//iphone7 + iOS10GM will return "maybe" for the "mp4a.40.2", so alternative codecs should be tested more to provide extra opportunity to be choosen by canPlayType
	                    //vid.canPlayType("video/mp4;codecs=avc1.42E01E,mp4a.40.2");
	                    //iphone 7 + iOS10GM : maybe
	                    //iphone 6 + iOS10GM : probably
	                }
	                else if (type === 'video/webm') {
	                    codec = 'vp8,vorbis';
	                }
	                else if (type === 'video/ogg') {
	                    codec = 'theora,vorbis';
	                }
	                else {
	                    return false;	// unknown video mime type
	                }
	            }
	            var vid = document.createElement('video');
	            //var response = vid.canPlayType(type + ';codecs="' + codec + '"');//VIDLA-139
	            var response = wrapperOfCanPlayType(vid, type, codec);



	            if (response === 'probably') {
	                return true;
	            }
	            if (response === 'maybe') {
	                if (type === 'video/webm') {
	                    return true;
	                }
	                //if alternativeCodec exists, do a test once again to give additoinal opportunity to be tested
	                //if (alternativeCodec && vid.canPlayType(type + ';codecs="' + alternativeCodec + '"') === "probably") {
	                //VIDLA-139
	                if (alternativeCodec && wrapperOfCanPlayType(vid, type, alternativeCodec) === "probably") {
	                    return true;
	                }
	            }
	            return false;
	        }
	    },

	    /** Returns information about device where ad is running.
	     * @returns {string} One of the following: desktop-flash, desktop-no-flash, mobile-Android, mobile-iOS, mobile-unknown.
	     */
	    getPlatformType: function() {
	        if (isMobile()) {
	            if (isAndroid()) {
	                return 'mobile-Android';
	            }
	            if (isIos()) {
	                return 'mobile-iOS';
	            }
	            return 'mobile-unknown';
	        }
	        else {
	            if (hasFlashPlugin()) {
	                return 'desktop-flash';
	            }
	            return 'desktop-no-flash';
	        }
	    }
	};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * URL Loader module.
	 * @module UrlLoader
	 */



	var _logger = __webpack_require__(3);

	function ajaxLoad(url, data, callback, timeout, options, command) {

	    var httpRequest;
	    var startTime = 0;
	    var duration = 0;
	    var calcDuration = false;
	    var logger = __webpack_require__(12);
	    var cacheManager = __webpack_require__(13);

	    var useWithCredentials = true;
	    
		var debug = function(message) {
		    logger.logDebug(message, 'URL Loader');
		};
	    
	    if (options &&  typeof options.withCredentials !== 'undefined') {
	        useWithCredentials = options.withCredentials;
	    } 

	    if (window.XMLHttpRequest) { // Mozilla, Safari, ...
	        httpRequest = new XMLHttpRequest();
	    } else if (window.ActiveXObject) { // IE
	        try {
	            httpRequest = new ActiveXObject('Msxml2.XMLHTTP');
	        } catch (msxmlErr) {
	            try {
	                httpRequest = new ActiveXObject('Microsoft.XMLHTTP');
	            } catch (msErr) {}
	        }
	    }


	    if (!httpRequest) {
	        if (callback) {
	            callback.call(this, '406', ''); // request is not acceptable
	        }
	        return;
	    }
	    
	    httpRequest.onreadystatechange = function() {
	        if (httpRequest.readyState === 4) {

	            if (httpRequest.status === 200) {
	                if (callback) {
	                    callback.call(this, undefined, httpRequest.responseText, httpRequest);
	                }
	                debug('duration: ' + duration + ', response length: ' + httpRequest.responseText.length);
	                if (calcDuration && httpRequest.responseText && httpRequest.responseText.length > 2048) {
	                	var nBandWidth = (httpRequest.responseText.length * 8.0 * 1000.0) / (Math.max(1.0, duration) * 1024.0);
	            		var intBandwidth = parseInt(nBandWidth.toString());
	                    debug('Bandwidth: ' + intBandwidth);
	                	try {
	                		cacheManager.setGenericData('anxBandwidth', intBandwidth);
	                		//localStorage.setItem('anxBandwidth', intBandwidth);
	                	}
	                	catch(ex) {
	                	}
	                }
	            } else {
	                if (httpRequest.status >= 400 && httpRequest.status < 600) {
	                    if (callback) {
	                        callback.call(this, httpRequest.status, '', httpRequest);
	                    }
	                }
	            }

	        }
	        else if (httpRequest.readyState === 2) {
	        	startTime = (new Date()).getTime();
	        }
	        else if (httpRequest.readyState === 3) {
	        	if (startTime > 0) {
	        		calcDuration = true;
	        		duration = (new Date()).getTime() - startTime;
	        	}
	        }
	    };

	    httpRequest.onerror = function() {
	        //if there is an error, it might be becase we are using withCredentials
	        //let's try one more time without that flag set.
	        //this won't send cookies, but it's better than no ad at all
	        if(useWithCredentials) {
	            var newOpts = options ? options : {};
	            newOpts.withCredentials = false;
	            ajaxLoad(url, data, callback, timeout, newOpts, command);
	        } else {
	            if (callback) {
	                var errorStatus = httpRequest.status === 0 ? '404' : httpRequest.status.toString();
	                callback.call(this, errorStatus, '', httpRequest);
	            }
	        }
	    };


	    httpRequest.ontimeout = function() {
	        //_logger.log('Server Timeout');
	        if (callback) {
	            callback.call(this, 'Timeout', '', httpRequest);
	        }
	    };

	    httpRequest.open(command, url);
	    if (timeout) {
	        httpRequest.timeout = timeout;
	    }
	    httpRequest.withCredentials = useWithCredentials;
	    startTime = 0;
	    if (command === 'POST') {
	    	httpRequest.send(data);
	    }
	    else {
	        httpRequest.send();
	    }
	}

	function createTrackingPixel(url, eventName) {
	    _logger.log('Logging Event: ' + eventName + ' at url:' + url);
	    new Image(1, 1).src = url;

	}



	module.exports = {
		    /** Load a URL.
		     * @param {string} url - Target URL to load. 
		     * @param {Function} callback - Function to call back once loading has either completed or encountered an error.
		     * @param {number} timeout - Timeout (in ms) to use for this URL Load.
		     */
		    load: function(url, callback, timeout) {
		        ajaxLoad(url, null, callback, timeout, {withCredentials:true}, 'GET');
		    },

		    /** Load a URL.
		     * @param {string} url - Target URL to load. 
		     * @param {string} data - request data 
		     * @param {Function} callback - Function to call back once loading has either completed or encountered an error.
		     * @param {number} timeout - Timeout (in ms) to use for this URL Load.
		     */
		    loadPost: function(url, data, callback, timeout) {
		        ajaxLoad(url, data, callback, timeout, {withCredentials:true}, 'POST');
		    },


	    /** Track Pixel.
	     * @param {String} url - Url of traking pixel to track. 
	     * @param {String} eventName - Name of event being tracked.
	     */
	    trackPixel: function(url, eventName) {
	        createTrackingPixel(url, eventName);
	    }
	};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * General Utilities module.
	 * @module GeneralUtilities
	 */

	var _logger = __webpack_require__(3);


	//////////////////////////////////////////////////////////////////////
	// CONSTANTS
	var MAX_OBJ_TO_STRING_RECURSION = 9;




	//////////////////////////////////////////////////////////////////////
	// VARIABLES


	//////////////////////////////////////////////////////////////////////
	// FUNCTIONS
	function getXmlResponseFromXhrObject(responseObj) {
	    if (responseObj) {
	        //if the response has parsed XML, trace it as an XML object
	        //otherwise, trace it as a string
	        if (responseObj.responseXML) {
	            return responseObj.responseXML;
	        } else {
	            return responseObj.responseText;
	        }
	    }
	}

	//////////////////////////////////////////////////////////////////////
	// EXPORTS
	module.exports = {
	    /**
	     * @deprecated - use @appnexus/videoads-util-logging
	     * Writes an entry to the console log if the current debug level is set to "Error", "Warn" or Debug"
	     * @param (string) message = text to be written to the log
	     * @param (string) source = optional string which identifies the source of the debug statement
	     *      - if present, then it will be prepended to front of the string
	     *      - example 1:  debug("hello") ==> <timestamp> hello
	     *      - example 2:  debug("hello", "TM") ==> <timestamp> TM>hello
	     */
	    debug: function() {
	        _logger.handleLogDebugLegacySupport.apply(this, arguments);

	    },

	    /**
	     * @deprecated - use @appnexus/videoads-util-logging
	     * Writes an entry to the console log if the current debug level is set to "Error", "Warn" or Debug"
	     * @param (string) message = text to be written to the log
	     * @param (string) source = optional string which identifies the source of the debug statement
	     *      - if present, then it will be prepended to front of the string
	     *      - example 1:  debug("hello") ==> <timestamp> hello
	     * 
	     */
	    logDebug: function() {
	        _logger.handleLogDebugLegacySupport.apply(this, arguments);

	    },

	    /**
	     * @deprecated - use @appnexus/videoads-util-logging
	     * Sets debug level for logger
	     * @param (string) level = Debug level to use
	     */
	    setDebugLevel: function(level) {
	        _logger.setDebugLevel(level);
	    },

	    /**
	     * Checks to see if a string or an array is not empty:
	     *  @param (object) arg = string or array which is being evaluated
	     *  @returns (boolean)
	     *      - true = arg is defined and the length > 0
	     *      - false = arg is null, undefined or has a length of zero
	     */
	    isNotEmpty: function(arg) {
	        var answer = false;
	        if (arg !== null && arg) {
	            answer = (arg.length > 0);
	        }

	        return answer;
	    },

	    /**
	     * @deprecated - since we now have the abilility to directly pass objects to our debug statements, we no longer need this
	     * returns a string version of an object
	     * if the value of a field is itself an object, then will stringify that object as well
	     */
	    objectToString: function(obj, recursionCount) {
	        /*
	                try{
	                    return JSON.stringify(obj);
	                }catch(ex){
	                    return "null"
	                }
	             */
	        var answer = "null";

	        //set default recurisonCount if it's not specified
	        recursionCount = typeof recursionCount !== 'undefined' ? recursionCount : 0;

	        if (obj !== null) {
	            answer = "OBJ[";
	            var props = "";
	            for (var key in obj) {
	                var val = obj[key];
	                if (typeof val === 'object') {
	                    recursionCount++;
	                    if (recursionCount < MAX_OBJ_TO_STRING_RECURSION) {
	                        try {
	                            val = this.objectToString(val);
	                        } catch (ex) {
	                            val = "err:" + ex;
	                        }
	                    } else {
	                        val = "err: max recursion hit";
	                    }
	                }
	                if (props.length > 0) {
	                    props += ",";
	                }
	                props += (key + "=" + val);
	            }
	            answer += props;
	            answer += "]";
	        }


	        return answer;

	    },

	    /**
	     *  Generates a alphanueric random string, up to 16 characters long containing the set [0-9,a-z].
	     *  Note: It is not guaranteed that this will start with a letter.
	     *  Note: These are not UUIDs/GUIDs, do not use as such in critcial situaitons.
	     *  Note: This is not guaranteed to be crypogtaphically secure.
	     *  @param (object) arg = string or array which is being evaluated
	     *  @returns (String)
	     *      - random character string
	     */
	    getRandomString: function() {
	        return Math.random().toString(36).substring(2);
	    },

	    /**
	     *  Trace a XML response in a XHR object at the "info" trace level (if enabled)
	     *  @param (Object) responseObjects = Single XHR Response object, or Array of XHR Response Objects to trace.
	     *  @param (String) tracePrefix = Text to print as part of trace statement.
	     *
	     */
	    traceVastFromXhr: function(responseObjects, tracePrefix) {
	        try {
	            if (responseObjects) {
	                //if we are passed an array, treat each item in array as a XHR Response
	                if (Array.isArray(responseObjects)) {
	                    if (responseObjects.length > 0) {
	                        // var responsesToTrace = [];
	                        var xmlUrlLoadingChain = [];

	                        //parse URL and payload out of each object
	                        for (var curResponseArrayPos in responseObjects) {
	                            // var curResponsePayload = {};
	                            // curResponsePayload.url = responseObjects[curResponseArrayPos].responseURL;
	                            // curResponsePayload.payloadObj = getXmlResponseFromXhrObject(responseObjects[curResponseArrayPos]);
	                            // responsesToTrace.push(curResponsePayload);

	                            xmlUrlLoadingChain.push(responseObjects[curResponseArrayPos].responseURL);
	                        }

	                        var finalXhrObject = responseObjects[responseObjects.length - 1];
	                        if (finalXhrObject) {
	                            var finalXmlTag = getXmlResponseFromXhrObject(finalXhrObject);
	                            var finalXmlTagUrl = finalXhrObject.responseURL;

	                            _logger.info(tracePrefix, "Tag load chain:", xmlUrlLoadingChain, "\n",
	                                "Final Tag URL: ", finalXmlTagUrl, "\n", "Final Tag: ", finalXmlTag);
	                        }
	                    }
	                } else {
	                    //if we didn't get an array, treat responseObjects as a single XHR responsw
	                    var responsePayloadToTrace = getXmlResponseFromXhrObject(responseObjects);
	                    _logger.info(tracePrefix, "Tag URL:", responseObjects.responseURL, "\n", "Tag:", responsePayloadToTrace);

	                }
	            } 
	        }catch (e) {}
	    }



	};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Cache Manager module.
	 * @module CacheManager
	 */

	var utils = __webpack_require__(12);


	var prefix = "Cache Manager";

	//////////////////////////////////////////////////////////////////////
	// CONSTANTS
	var TTL_DEFAULT_MIN = 2 * 20; // 2 hours expressed in minutes
	var MSEC_PER_MINUTE = 60 * 1000;
	var TTL_DEFAULT_MSEC = TTL_DEFAULT_MIN * MSEC_PER_MINUTE; // expressed in seconds

	//////////////////////////////////////////////////////////////////////
	// VARIABLES
	var _ttlMsec = TTL_DEFAULT_MSEC;

	var _genericDataStotagePrefix = "___appnexus_video_cachemanager_generic_data___";
	var adTokenStorageKey = "___appnexus_video_cachemanager_ad_token___";

	var backupInMemoryStorageObj = {};

	//storage types:
	//0 - localStorage
	//1 - cookie
	//2 - in memory
	var storageTypeToUse;

	if (isLocalStorageSupported()) {
	    storageTypeToUse = 0;
	} else {
	    if (isCookieStorageSupported()) {
	        storageTypeToUse = 1;
	    } else {
	        storageTypeToUse = 2;
	    }

	}

	utils.debug("Using Cache Method " + storageTypeToUse, prefix);

	//docCookies library from https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie
	var docCookies = {
	    getItem: function(sKey) {
	        if (!sKey) {
	            return null;
	        }
	        return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
	    },
	    setItem: function(sKey, sValue, vEnd, sPath, sDomain, bSecure) {
	        if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) {
	            return false;
	        }
	        var sExpires = "";
	        if (vEnd) {
	            switch (vEnd.constructor) {
	                case Number:
	                    sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
	                    break;
	                case String:
	                    sExpires = "; expires=" + vEnd;
	                    break;
	                case Date:
	                    sExpires = "; expires=" + vEnd.toUTCString();
	                    break;
	            }
	        }
	        document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
	        return true;
	    },
	    removeItem: function(sKey, sPath, sDomain) {
	        if (!this.hasItem(sKey)) {
	            return false;
	        }
	        document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
	        return true;
	    },
	    hasItem: function(sKey) {
	        if (!sKey) {
	            return false;
	        }
	        return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
	    },
	    keys: function() {
	        var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
	        for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) {
	            aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]);
	        }
	        return aKeys;
	    }
	};

	//write object to whatever storage method we are using, with specified key
	function writeToStorage(key, obj, dontExpire) {
	    switch (storageTypeToUse) {
	        case 0:
	            writeToLocalStorage(key, obj);
	            break;
	        case 1:
	            writeToCookieStorage(key, obj, dontExpire);
	            break;
	        default:
	        case 2:
	            writeToInMemoryStorage(key, obj);
	            break;
	    }
	}

	//get a object from the storage method we are using, that has the specified key
	function getFromStorage(key) {
	    switch (storageTypeToUse) {
	        case 0:
	            return getFromLocalStorage(key);
	        case 1:
	            return getFromCookieStorage(key);
	        default:
	        case 2:
	            return getFromInMemoryStorage(key);
	    }

	}

	//delete an object in the storaege method we are using, 
	function deleteFromStorage(key) {
	    switch (storageTypeToUse) {
	        case 0:
	            deleteFromLocalStorage(key);
	            break;
	        case 1:
	            deleteFromCookieStorage(key);
	            break;
	        default:
	        case 2:
	            deleteFromInMemoryStorage(key);
	            break;
	    }
	}

	function writeToLocalStorage(key, obj) {
	    if (localStorage) {
	        localStorage.setItem(key, obj);
	    }
	}

	function getFromLocalStorage(key) {
	    if (localStorage) {
	        return localStorage.getItem(key);
	    }
	}

	function deleteFromLocalStorage(key) {
	    if (localStorage) {
	        localStorage.removeItem(key);
	    }
	}

	function writeToCookieStorage(key, obj, dontExpire) {
	    docCookies.setItem(key, obj, (dontExpire ? Infinity : new Date((Date.now() + _ttlMsec)).toUTCString()));
	}

	function getFromCookieStorage(key) {
	    return docCookies.getItem(key);
	}

	function deleteFromCookieStorage(key) {
	    docCookies.removeItem(key);
	}

	function writeToInMemoryStorage(key, obj) {
	    if (backupInMemoryStorageObj) {
	        backupInMemoryStorageObj[key] = obj;
	    }
	}

	function getFromInMemoryStorage(key) {
	    if (backupInMemoryStorageObj) {
	        return backupInMemoryStorageObj[key];
	    }
	}

	function deleteFromInMemoryStorage(key) {
	    if (backupInMemoryStorageObj) {
	        delete backupInMemoryStorageObj[key];
	    }
	}

	//return true if localStorage is supported, false otherwise
	function isLocalStorageSupported() {

	    //if the browser is blocking 3rd party storage, accessing localStorage might throw an exception (VID-2089)
	    try {
	        if (localStorage) {
	            var testValue = "apntestls" + Math.random();
	            try {
	                //try writing and reading something
	                localStorage.setItem(testValue, testValue);
	                localStorage.removeItem(testValue);
	                return true;
	            } catch (e) {}
	        }
	    } catch (e) {}

	    return false;
	}


	//return true if localStorage is supported, false otherwise
	function isCookieStorageSupported() {
	    try {
	        if (document && document.cookie) {
	            var testValue = "apntestcookie" + Math.random();
	            try {
	                docCookies.setItem(testValue, testValue, Infinity);
	                var cookieWorked = docCookies.hasItem(testValue) && (docCookies.getItem(testValue) === testValue);
	                docCookies.removeItem(testValue);
	                return cookieWorked;
	            } catch (e) {}
	        }
	    } catch (e) {}

	    return false;
	}

	// caches the adObject - this will overwrite any existing cached ad
	// the cache will also be timestamp with the current time in milliseconds
	// for calculating time to live
	function addAdToCache(adObject, adId) {
	    var cacheObject = {};
	    cacheObject.timestamp = new Date().getTime();
	    cacheObject.ad = adObject;

	    try {
	        writeToStorage(adId, JSON.stringify(cacheObject));
	    } catch (e) {

	    }
	}

	// returns the ad stored in the cache if the cache has not expired
	// returns null if the cache has expired (based on the configured time-to-live) 
	// OR if there is no ad in the cache
	// NOTE:  It is not clear yet what to do with placement id - ignore it for now
	function getCachedAd(adId) {
	    var ts = new Date().getTime();

	    var retrievedCacheItem;

	    try {
	        var itemFromCache = getFromStorage(adId);
	        retrievedCacheItem = (itemFromCache && JSON.parse(itemFromCache));
	        // clear the cache, setting it back to default (or empty)
	        deleteFromStorage(adId);
	    } catch (e) {

	    }

	    // check to see if the ad cache exists and if the cache has not expired
	    if (retrievedCacheItem && retrievedCacheItem.timestamp && retrievedCacheItem.timestamp > 0) {
	        var cacheAge = ts - retrievedCacheItem.timestamp;
	        //if we have expired, return nothing
	        if (cacheAge <= _ttlMsec) {
	            return retrievedCacheItem.ad;
	        }
	    }

	    return null;
	}

	// clear the ad cache by creating a default ad cache object
	//NOTE:  It is not clear yet what to do with placement id - ignore it for now
	function clearAdCache(adId) {
	    try {
	        deleteFromStorage(adId);
	    } catch (e) {

	    }
	}

	// converts the time-to-live argument from minutes to milliseconds
	// to make it easier to compare timestamps
	function setTTL(ttlMinutes) {
	    _ttlMsec = ttlMinutes * MSEC_PER_MINUTE;
	}

	// gets the current token from the cache
	function getAdToken() {
	    var tokenToReturn;
	    var tokenFromCache;
	    tokenFromCache = getFromStorage(adTokenStorageKey);

	    if (tokenFromCache) {
	        tokenToReturn = parseInt(tokenFromCache);
	    } else {
	        //no token found, use default
	        tokenToReturn = 0;
	    }

	    //store new token in localStorage or local memory
	    writeToStorage(adTokenStorageKey, (tokenToReturn += 1), true);


	    return tokenToReturn;
	}

	function prependAppnexusIdToKey(incomingKey) {
	    return "apn_" + incomingKey;
	}

	module.exports = {

	    /**
	     * Set generic data in cache
	     * @param (string) key = key under which to store data
	     * @param (object) value = value to store.
	     * @return (boolean) true if value was succesfully stored, false otherwise
	     */
	    setGenericData: function(key, value) {
	        if (typeof key !== "undefined" && typeof value !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            try {
	                writeToStorage(key, value);
	                return true;
	            } catch (e) {

	            }
	        }
	        return false;
	    },

	    /**
	     * Get generic data from cache
	     * @param (string) key = key to retrive from data
	     * @return (object) object contaninig data from cache with given key, undefined if key not found.
	     */
	    getGenericData: function(key) {
	        if (typeof key !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            return getFromStorage(key);
	        }
	    },

	    /**
	     * Delete generic data from cache
	     * @param (string) key = key to delete from cache
	     */
	    deleteGenericData: function(key) {
	        if (typeof key !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            deleteFromStorage(key);
	        }
	    },

	    /**
	     * Force usage of a specifc cache storage method, This is an optional function, if it is not called we will attempt to use
	     * localStorage, with a in-memory object as backup. 0= use localStorage.  1 = use cookie.  2 = use in-memory storage
	     */
	    forceStorageMethod: function(storageType) {
	        storageTypeToUse = storageType;
	        utils.debug("Forced usage of cache method " + storageTypeToUse, prefix);
	    },

	    /**
	     * add the ad data to the cache
	     * @param (object) adObject = JSON object describing the contents of the VAST tag after it has been parsed and unwrapped
	     *      - this will become the input into the ad rendering logic
	     * @param (integer) adId = unique identifier for a specific ad cache
	     */
	    addAd: function(adObject, adId) {
	        if (adObject) {
	            addAdToCache(adObject, prependAppnexusIdToKey(adId));
	        }
	    },

	    /** Retrieves ad from the ad cache.  If none exists or if the cache has expired, null is returned
	     * @param (integer) adId = unique identifier for a specific ad cache
	     * @return (object) object containing results of VAST parsing if ad is cached; otherwise return null
	     */
	    getAd: function(adId) {
	        return getCachedAd(prependAppnexusIdToKey(adId));
	    },

	    /**
	     * Clears the cache, removing any cached ad
	     * @param (integer) adId = unique identifier for a specific ad cache
	     */
	    clearAd: function(adId) {
	        clearAdCache(prependAppnexusIdToKey(adId));
	    },

	    /** Sets the time-to-live settings for the ad cache
	     * @param (number) timeToLiveMinutes = specifies how long (in minutes) ad ad may remain in the cache before being discarded
	     */
	    setTimeToLive: function(timeToLiveMinutes) {
	        setTTL(timeToLiveMinutes);
	    },

	    /**
	     * Returns a token unique to this page which is used to identify an ad request.
	     */
	    getNextAdToken: function() {
	        // Remove unnecessary additional characters.
	        // return chars.substring(0, len);
	        return getAdToken();
	    }
	};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * VAST Parser module.
	 * @module VastParser
	 */

	var VastXMLParserHelper = __webpack_require__(6);

	var APN_CompanionAds = __webpack_require__(7);
	var APN_Icons = __webpack_require__(8);

	var VastModifier = function (parserData, adToken, notifyUrl, contentSource, buyerMemberId, viewabilityConfig, additionalTrackers, creativeId) {

	    var _logger = __webpack_require__(3);
	    var _prefix = 'VAST Parser';

	    var _parserData = parserData;
	    var _adToken = adToken;
	    var _notifyUrl = notifyUrl;
	    var _creativeId = creativeId;
	    var _buyerMemberId = buyerMemberId;
	    var _contentSource = contentSource;
	    var _viewabilityConfig = viewabilityConfig;
		var _additionalTrackers = additionalTrackers;
	    var _helper = new VastXMLParserHelper();

	    function trimXml(strVastXml) {
	        var nPos = strVastXml.indexOf('<');
	        var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
	        nPos = strXml.lastIndexOf('>');
	        if (nPos !== -1) {
	            strXml = strXml.substr(0, nPos + 1);
	        }
	        return strXml;
	    }

	    function prepareDocObject(strVastXml) {
	        var strXml = trimXml(strVastXml);
	        var xmlDoc = null;
	        if (typeof window.DOMParser !== 'undefined') {
	            xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
	            if (xmlDoc.documentElement.nodeName === 'parsererror') {
	                try {
	                    _logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
	                }
	                catch (e) {
	                }
	                return null;
	            }
	        }
	        else if (typeof window.ActiveXObject !== 'undefined') {
	            try {
	                xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
	                xmlDoc.loadXML(strXml);
	                if (xmlDoc.parseError.errorCode !== 0) {
	                    _logger.error(_prefix, xmlDoc.parseError);
	                    return null;
	                }
	            }
	            catch (ex) {
	                _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
	                return null;
	            }
	        }
	        else {
	            _logger.error(_prefix, 'Failed to get vast xml parser');
	            return null;
	        }
	        return xmlDoc;
	    }

	    var _xmlDoc = prepareDocObject(parserData.vastXml);

	    function updateVastVersion(vastVersion) {
	        if (_xmlDoc) {
	            var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
	            if (vastNode) {
	                var attr = _xmlDoc.createAttribute('version');
	                attr.value = vastVersion;
	                vastNode.setAttributeNode(attr);
	            }
	        }
	    }

	    updateVastVersion(parserData.vastVersion);

	    function appendAttributesToAdNode() {
	        if (_xmlDoc) {
	            var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
	            if (vastNode) {
	                var ads = _helper.getSubNodes(vastNode, 'Ad');
	                if (ads && ads.length > 0) {
	                    for (var i = 0; i < ads.length; i++) {
	                        if (_notifyUrl) {
	                            var attr = _xmlDoc.createAttribute('notifyurl');
	                            attr.value = _notifyUrl;
	                            ads[i].setAttributeNode(attr);
	                        }
	                        if (_contentSource && _contentSource === 'rtb') {
	                            var attr2 = _xmlDoc.createAttribute('rtb');
	                            attr2.value = 'true';
	                            ads[i].setAttributeNode(attr2);
	                        }
	                        var attr3 = _xmlDoc.createAttribute('sequence');
	                        attr3.value = _parserData.sequence.toString();
	                        ads[i].setAttributeNode(attr3);
	                        if (_buyerMemberId) {
	                            var attr4 = _xmlDoc.createAttribute('buyerMemberId');
	                            attr4.value = _buyerMemberId;
	                            ads[i].setAttributeNode(attr4);
	                        }
	                        if (_viewabilityConfig) {
	                            var attr5 = _xmlDoc.createAttribute('viewabilityConfig');
	                            attr5.value = _viewabilityConfig;
	                            ads[i].setAttributeNode(attr5);
	                        }
	                        if (_creativeId) {
	                            var attr6 = _xmlDoc.createAttribute('creativeId');
	                            attr6.value = _creativeId;
	                            ads[i].setAttributeNode(attr6);
	                        }
	                    }
	                }
	            }
	        }
	    }

	    appendAttributesToAdNode();

	    function addCdataBlock(parentNode, url) {
	        var cdata = _xmlDoc.createCDATASection(url);
	        parentNode.appendChild(cdata);
	    }

	    var _creativesNode = null;

	    function getLinearNode() {
	        if (_adToken) {
	            var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
	            var attr = _xmlDoc.createAttribute('adtoken');
	            attr.value = _adToken;
	            vastNode.setAttributeNode(attr);
	        }

	        var inLine = _helper.getSubNode(_xmlDoc, 'InLine');
	        if (!inLine) {
	            return null;	// VAST xml has no InLine node
	        }

	        var i;
	        var impNode;
	        if (_parserData.extImpressionUrls && typeof _parserData.extImpressionUrls === 'string') {
	            var impTrackers = JSON.parse(_parserData.extImpressionUrls);
	            if (Array.isArray(impTrackers) && impTrackers.length > 0) {
	                for (i = 0; i < impTrackers.length; i++) {
	                    impNode = _xmlDoc.createElement('Impression');
	                    addCdataBlock(impNode, impTrackers[i]);
	                    inLine.appendChild(impNode);
	                }
	            }
	            delete _parserData.extImpressionUrls;
	        }
	    	if (_additionalTrackers && _additionalTrackers.impressions) {
	    		for (i = 0; i < _additionalTrackers.impressions.length; i++) {
	    			if (_additionalTrackers.impressions[i]) {
		            	impNode = _xmlDoc.createElement('Impression');
		            	addCdataBlock(impNode, _additionalTrackers.impressions[i]);
		            	inLine.appendChild(impNode);
	    			}
	    		}
	    	}
	        	
	    	var errNode;
	        if (_parserData.extErrorUrls && typeof _parserData.extErrorUrls === 'string') {
	            var errTrackers = JSON.parse(_parserData.extErrorUrls);
	            if (Array.isArray(errTrackers) && errTrackers.length > 0) {
	                for (i = 0; i < errTrackers.length; i++) {
	                    errNode = _xmlDoc.createElement('Error');
	                    addCdataBlock(errNode, errTrackers[i]);
	                    inLine.appendChild(errNode);
	                }
	            }
	            delete _parserData.extErrorUrls;
	        }
	    	if (_additionalTrackers && _additionalTrackers.errors) {
	    		for (i = 0; i < _additionalTrackers.errors.length; i++) {
	    			if (_additionalTrackers.errors[i]) {
		            	errNode = _xmlDoc.createElement('Error');
		            	addCdataBlock(errNode, _additionalTrackers.errors[i]);
		            	inLine.appendChild(errNode);
	    			}
	    		}
	    	}
	    	
	        if (_parserData.extViewableImpression && typeof _parserData.extViewableImpression === 'string') {
	            var viewableImpressions = JSON.parse(_parserData.extViewableImpression);
	            var viNode = _xmlDoc.createElement('ViewableImpression');
	            if (Array.isArray(viewableImpressions.viewable) && viewableImpressions.viewable.length > 0) {
	                for (i = 0; i < viewableImpressions.viewable.length; i++) {
	                    var viewableNode = _xmlDoc.createElement('Viewable');
	                    addCdataBlock(viewableNode, viewableImpressions.viewable[i]);
	                    viNode.appendChild(viewableNode);
	                }
	            }
	            if (Array.isArray(viewableImpressions.notViewable) && viewableImpressions.notViewable.length > 0) {
	                for (i = 0; i < viewableImpressions.notViewable.length; i++) {
	                    var notViewableNode = _xmlDoc.createElement('NotViewable');
	                    addCdataBlock(notViewableNode, viewableImpressions.notViewable[i]);
	                    viNode.appendChild(notViewableNode);
	                }
	            }
	            if (Array.isArray(viewableImpressions.undetermined) && viewableImpressions.undetermined.length > 0) {
	                for (i = 0; i < viewableImpressions.undetermined.length; i++) {
	                    var undeterminedNode = _xmlDoc.createElement('ViewUndetermined');
	                    addCdataBlock(undeterminedNode, viewableImpressions.undetermined[i]);
	                    viNode.appendChild(undeterminedNode);
	                }
	            }
	            inLine.appendChild(viNode);
	            delete _parserData.extViewableImpression;
	        }
	        	
	        var uaParser = __webpack_require__(9);
	        var ua = uaParser();
	        var browser = ua.browser.name.toLowerCase();
	        if (_parserData.extExtensions && typeof _parserData.extExtensions === 'string') {
	            var extensions = _parserData.extExtensions;
	            if (extensions.length > 0) {
	                var extensionsNode = _helper.getSubNode(inLine, 'Extensions');
	                if (!extensionsNode) {
	                    extensionsNode = _xmlDoc.createElement('Extensions');
	                    inLine.appendChild(extensionsNode);
	                    if (browser === 'ie') {
	                    	extensionsNode.textContent = extensions;
	                    }
	                    else {
	                        extensionsNode.innerHTML = extensions;
	                    }
	                }
	                else {
	                    if (browser === 'ie') {
	                    	extensionsNode.textContent = extensionsNode.textContent.toString() + extensions;
	                    }
	                    else {
	                        extensionsNode.innerHTML = extensionsNode.innerHTML.toString() + extensions;
	                    }
	                }
	            }
	            delete _parserData.extExtensions;
	        }

	        _creativesNode = _helper.getSubNode(inLine, 'Creatives');
	        if (!_creativesNode) {
	            _creativesNode = _xmlDoc.createElement('Creatives');
	            inLine.appendChild(_creativesNode);
	        }
	        var linearNode = _helper.getSubNode(_creativesNode, 'Linear');
	        if (!linearNode) {
	            var creativeNode = _xmlDoc.createElement('Creative');
	            _creativesNode.appendChild(creativeNode);
	            linearNode = _xmlDoc.createElement('Linear');
	            creativeNode.appendChild(linearNode);
	        }
	        return linearNode;
	    }

	    function iconAlreadyExist(iconsNode, program) {
	        var icons = _helper.getSubNodes(iconsNode, 'Icon');
	        if (icons && icons.length > 0) {
	            for (var i = 0; i < icons.length; i++) {
	                var programAttr = _helper.getNodeAttributeValue(icons[i], 'program');
	                if (programAttr.toLowerCase() === program.toLowerCase()) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    }

	    function appendTrackings(linearNode) {
	        var i;
	        if (_parserData.extTrackingUrls && typeof _parserData.extTrackingUrls === 'string' &&
	            _parserData.extTrackingUrls.length > 5) {
	            var videoTrackers = JSON.parse(_parserData.extTrackingUrls);
	            var trackersNode = _helper.getSubNode(linearNode, 'TrackingEvents');
	            if (!trackersNode) {
	                trackersNode = _xmlDoc.createElement('TrackingEvents');
	                linearNode.appendChild(trackersNode);
	            }
	            // enumerate video trackers
	            for (var name in videoTrackers) {
	                var urls = videoTrackers[name];
	                for (i = 0; i < urls.length; i++) {
	                    var trackerNode = _xmlDoc.createElement('Tracking');
	                    var attr = _xmlDoc.createAttribute('event');
	                    attr.value = name;
	                    trackerNode.setAttributeNode(attr);
	                    //trackerNode.textContent = urls[i];
	                    addCdataBlock(trackerNode, urls[i]);
	                    trackersNode.appendChild(trackerNode);
	                }
	            }
	            delete _parserData.extTrackingUrls;
	        }

	        var videoClicksNode;
	        if (_parserData.extClickUrls && typeof _parserData.extClickUrls === 'string') {
	            var videoClicks = JSON.parse(_parserData.extClickUrls);
	            if (Array.isArray(videoClicks) && videoClicks.length > 0) {
	                videoClicksNode = _helper.getSubNode(linearNode, 'VideoClicks');
	                if (!videoClicksNode) {
	                    videoClicksNode = _xmlDoc.createElement('TrackingEvents');
	                    linearNode.appendChild(videoClicksNode);
	                }
	                if (!_helper.getSubNode(videoClicksNode, 'ClickThrough')) {
	                    var clickNode = _xmlDoc.createElement('ClickThrough');
	                    //clickNode.textContent = videoClicks[0];
	                    addCdataBlock(clickNode, videoClicks[0]);
	                    videoClicksNode.appendChild(clickNode);
	                }
	            }
	            delete _parserData.extClickUrls;
	        }

	        if (_parserData.extClickTrackingUrls && typeof _parserData.extClickTrackingUrls === 'string') {
	            var clickTrackings = JSON.parse(_parserData.extClickTrackingUrls);
	            if (Array.isArray(clickTrackings) && clickTrackings.length > 0) {
	                videoClicksNode = _helper.getSubNode(linearNode, 'VideoClicks');
	                if (!videoClicksNode) {
	                    videoClicksNode = _xmlDoc.createElement('VideoClicks');
	                    linearNode.appendChild(videoClicksNode);
	                }
	                for (i = 0; i < clickTrackings.length; i++) {
	                    var clickTrackingNode = _xmlDoc.createElement('ClickTracking');
	                    //clickTrackingNode.textContent = clickTrackings[i];
	                    addCdataBlock(clickTrackingNode, clickTrackings[i]);
	                    videoClicksNode.appendChild(clickTrackingNode);
	                }
	            }
	            delete _parserData.extClickTrackingUrls;
	        }

	        if (_parserData.extIcons && typeof _parserData.extIcons === 'string') {
	            var icons = JSON.parse(_parserData.extIcons);
	            if (Array.isArray(icons) && icons.length > 0) {
	                var iconsNode = _helper.getSubNode(linearNode, 'Icons');
	                if (!iconsNode) {
	                    iconsNode = _xmlDoc.createElement('Icons');
	                    linearNode.appendChild(iconsNode);
	                }
	                for (i = 0; i < icons.length; i++) {
	                    // avoid duplicate icons with same program
	                    if (!iconAlreadyExist(iconsNode, icons[i].program)) {
	                        var iconNode = APN_Icons.createIconNode(_xmlDoc, icons[i]);
	                        if (iconNode) {
	                            iconsNode.appendChild(iconNode);
	                        }
	                    }
	                }
	            }
	            delete _parserData.extIcons;
	        }
	    }

	    function appendNewCompanion(companionAdsNode, newCompanion) {
	        // get companions with resources
	        var companionNode, j;
	        var companionAdsObj = {companions: []};
	        APN_CompanionAds.parse(companionAdsObj, companionAdsNode, _helper);
	        var resCompanions = companionAdsObj.companions;
	        if (newCompanion.StaticResource || newCompanion.IFrameResource || newCompanion.HTMLResource) {
	            var sameSize = false;
	            for (j = 0; j < resCompanions.length; j++) {
	                if (newCompanion.width === resCompanions[j].width &&
	                    newCompanion.height === resCompanions[j].height) {
	                    sameSize = true;
	                    break;
	                }
	            }
	            if (!sameSize) {
	                companionNode = APN_CompanionAds.createCompanionNode(_xmlDoc, newCompanion);
	                companionAdsNode.appendChild(companionNode);
	            }
	        }
	        else {
	            // aggregate companion without resorces into companions with resources
	            var needUpdate = false;
	            for (j = 0; j < resCompanions.length; j++) {
	                if (newCompanion.width === resCompanions[j].width && newCompanion.height === resCompanions[j].height) {
	                    if ((newCompanion.id && newCompanion.id === resCompanions[j].id) || (!newCompanion.id)) {
	                        // add click trackings
	                        if (newCompanion.CompanionClickTracking) {
	                            if (!resCompanions[j].CompanionClickTracking) {
	                                resCompanions[j].CompanionClickTracking = [];
	                            }
	                            resCompanions[j].CompanionClickTracking = resCompanions[j].CompanionClickTracking.concat(newCompanion.CompanionClickTracking);
	                        }
	                        // add view trackings
	                        if (newCompanion.TrackingEvents) {
	                            if (!resCompanions[j].TrackingEvents) {
	                                resCompanions[j].TrackingEvents = [];
	                            }
	                            resCompanions[j].TrackingEvents = resCompanions[j].TrackingEvents.concat(newCompanion.TrackingEvents);
	                        }
	                        needUpdate = true;
	                        break;
	                    }
	                }
	            }
	            if (needUpdate) {
	                while (companionAdsNode.firstChild) {
	                    companionAdsNode.removeChild(companionAdsNode.firstChild);
	                }
	                for (var i = 0; i < resCompanions.length; i++) {
	                    companionNode = APN_CompanionAds.createCompanionNode(_xmlDoc, resCompanions[i]);
	                    companionAdsNode.appendChild(companionNode);
	                }
	            }
	        }
	    }

	    function appendCompanions() {
	        if (_parserData.extCompanions && typeof _parserData.extCompanions === 'string') {
	            var companions = JSON.parse(_parserData.extCompanions);
	            if (Array.isArray(companions.companions) && companions.companions.length > 0) {
	                var companionAdsNode = _helper.getSubNode(_creativesNode, 'CompanionAds');
	                if (!companionAdsNode) {
	                    companionAdsNode = _xmlDoc.createElement('CompanionAds');
	                    _creativesNode.appendChild(companionAdsNode);
	                }
	                var attr;
	                if (companions.required !== 'unknown') {
	                    attr = _xmlDoc.createAttribute('required');
	                    attr.value = companions.required;
	                    companionAdsNode.setAttributeNode(attr);
	                }
	                for (var i = 0; i < companions.companions.length; i++) {
	                    appendNewCompanion(companionAdsNode, companions.companions[i]);
	                }
	            }
	        }
	    }

	    this.addTrackers = function () {
	        if (!_xmlDoc) {
	            return '';
	        }
	        var linearNode = getLinearNode();
	        if (!linearNode) {
	            return '';
	        }
	        appendTrackings(linearNode);
	        if (_creativesNode) {
	            appendCompanions();
	        }
	        var strOut;
	        var uaParser = __webpack_require__(9);
	        var ua = uaParser();
	        var browser = ua.browser.name.toLowerCase();
	        if (browser === 'edge') {
	            // VIDLA-683. Edge is loosing nested CDATA during serialization to string.
	            strOut = _xmlDoc.childNodes[0].outerHTML;
	        }
	        else if (browser === 'ie') {
	            // VIDLA-683. IE is loosing nested CDATA during parsing XML string to DOM.
	            // We have to restore nested CDATA for AdParameters if needed.
	            var nodes = _xmlDoc.getElementsByTagName('AdParameters');
	            for (var i = 0; i < nodes.length; i++) {
	                if (nodes[i].textContent.indexOf(']]>') > 0 && nodes[i].textContent.substr(0, 9) !== '<![CDATA[') {
	                    nodes[i].textContent = nodes[i].textContent.replace(/]]>/g, "]]]]><![CDATA[>");
	                    nodes[i].textContent = '<![CDATA[' + nodes[i].textContent + ']]>';
	                }
	            }
	            strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
	            strOut = strOut.replace(/&lt;/g, '<');
	            strOut = strOut.replace(/&gt;/g, '>');
	        }
	        else {
	            strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
	        }
	        return strOut;
	    };
	};

	module.exports = VastModifier;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * VastMerger module.
	 * @module VastParser
	 */

	var VastXMLParserHelper = __webpack_require__(6);

	var VastMerger = function (xmlList) {

	    var _logger = __webpack_require__(3);
	    var _prefix = 'VAST Parser';

	    var _xmls = xmlList;
	    var _helper = new VastXMLParserHelper();

	    function trimXml(strVastXml) {
	        var nPos = strVastXml.indexOf('<');
	        var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
	        nPos = strXml.lastIndexOf('>');
	        if (nPos !== -1) {
	            strXml = strXml.substr(0, nPos + 1);
	        }
	        return strXml;
	    }

	    function prepareDocObject(strVastXml) {
	        var strXml = trimXml(strVastXml);
	        var xmlDoc = null;
	        if (typeof window.DOMParser !== 'undefined') {
	            xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
	            if (xmlDoc.documentElement.nodeName === 'parsererror') {
	                try {
	                    _logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
	                }
	                catch (e) {
	                }
	                return null;
	            }
	        }
	        else if (typeof window.ActiveXObject !== 'undefined') {
	            try {
	                xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
	                xmlDoc.loadXML(strXml);
	                if (xmlDoc.parseError.errorCode !== 0) {
	                    _logger.error(_prefix, xmlDoc.parseError);
	                    return null;
	                }
	            }
	            catch (ex) {
	                _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
	                return null;
	            }
	        }
	        else {
	            _logger.error(_prefix, 'Failed to get vast xml parser');
	            return null;
	        }
	        return xmlDoc;
	    }

	    var _xmlDoc = prepareDocObject(_xmls[0]);
	    if (!_xmlDoc) {
	        return;
	    }

	    var _vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
	    var attr = _xmlDoc.createAttribute('apn_waterfall');
	    attr.value = true;
	    _vastNode.setAttributeNode(attr);

	    var adNodes = [];
	    for (var i = 0; i < _xmls.length; i++) {
	        var doc = prepareDocObject(_xmls[i]);
	        var vastNode = _helper.getSubNode(doc, 'VAST');
	        var ads = _helper.getSubNodes(vastNode, 'Ad');
	        if (ads && ads.length > 0) {
	            for (var j = 0; j < ads.length; j++) {
	                adNodes.push(ads[j]);
	            }
	        }
	    }

	    adNodes.sort(function (a, b) {
	        return _helper.getNodeAttributeNumberValue(a, 'sequence') - _helper.getNodeAttributeNumberValue(b, 'sequence');
	    });

	    var uaParser = __webpack_require__(9);
	    var ua = uaParser();
	    var browser = ua.browser.name.toLowerCase();
	    
	    if (browser === 'ie') {
	        _vastNode.textContent = '';
	    }
	    else {
	        _vastNode.innerHTML = '';
	    }
	    for (i = 0; i < adNodes.length; i++) {
	        _vastNode.appendChild(adNodes[i]);
	    }

	    this.getVastXml = function () {
	        if (!_xmlDoc) {
	            return '';
	        }
	        var strOut;
	        if (browser === 'edge') {
	            // VIDLA-683. Edge is loosing nested CDATA during serialization to string.
	            strOut = _xmlDoc.childNodes[0].outerHTML;
	        }
	        else if (browser === 'ie') {
	            // VIDLA-683. IE is loosing nested CDATA during parsing XML string to DOM.
	            // We have to restore nested CDATA for AdParameters if needed.
	            var nodes = _xmlDoc.getElementsByTagName('AdParameters');
	            for (var i = 0; i < nodes.length; i++) {
	                if (nodes[i].textContent.indexOf(']]>') > 0 && nodes[i].textContent.substr(0, 9) !== '<![CDATA[') {
	                    nodes[i].textContent = nodes[i].textContent.replace(/]]>/g, "]]]]><![CDATA[>");
	                    nodes[i].textContent = '<![CDATA[' + nodes[i].textContent + ']]>';
	                }
	            }
	            strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
	            strOut = strOut.replace(/&lt;/g, '<');
	            strOut = strOut.replace(/&gt;/g, '>');
	        }
	        else {
	            strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
	        }
	        return strOut;
	    };
	};

	module.exports = VastMerger;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	var _logger = __webpack_require__(3);
	var _uaParser = __webpack_require__(9);

	var _prefix = 'apnVmapVast->Utils';

	function convertSecsToString(nSecs) {
		var hours = Math.floor(nSecs / 3600);
		var mins = Math.floor((nSecs - hours * 3600) / 60);
		var secs = Math.floor(nSecs - hours * 3600 - mins * 60);
		var str = (hours > 9 ? '' : '0') + hours + ':' + (mins > 9 ? '' : '0') + mins + ':' + (secs > 9 ? '' : '0') + secs;
		return str;
	}

	function getUUID() {
		var d = new Date().getTime();
		var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
		});
		return uuid;
	}

	function trackUrls(arrUrls) {
		if (arrUrls && Array.isArray(arrUrls) && arrUrls.length > 0) {
			for (var i = 0; i < arrUrls.length; i++) {
				new Image(1, 1).src = arrUrls[i];
			}
		}
	}

	function showNextOverlay(show) {
		var nextOverlays = document.getElementsByClassName('vjs-next-overlay');
		if (nextOverlays && nextOverlays.length > 0) {
			nextOverlays[0].style.display = show ? '' : 'none';
		}
	}

	function convertStringToSeconds(strTime, duration, currentTime) {
		// validate parameters
		if (!strTime || !duration || duration <= 0) {
			return null;
		}
		
		var nSeconds = null;
		var nPos;
		if (strTime.indexOf(':') === 2 && strTime.length >= 8) {
			// hh:mm:ss or hh:mm:ss.mmm
			nPos = strTime.indexOf(':');
			var nHours = parseInt(strTime.substr(0, nPos));
			strTime = strTime.substr(nPos + 1, strTime.length - nPos - 1);
			nPos = strTime.indexOf(':');
			var nMinuts = parseInt(strTime.substr(0, nPos));
			strTime = strTime.substr(nPos + 1, strTime.length - nPos - 1);
			nPos = strTime.indexOf('.');
			var nSecs = nPos > 0 ? parseInt(strTime.substr(0, nPos)) : parseInt(strTime);
			var nMsecs = 0;
			if (nPos > 0) {
				strTime = strTime.substr(nPos + 1, strTime.length - nPos - 1);
				nMsecs = parseInt(strTime);
			}
			nSeconds = nHours * 3600 + nMinuts * 60 + nSecs + (nMsecs >= 500 ? 1 : 0); 
		}
		else if (strTime.indexOf('%') > 0){
			// n%
			nPos = strTime.indexOf('%');
			var nPercents = parseInt(strTime.substr(0, nPos));
			nSeconds = parseInt(duration * nPercents / 100); 
		}
		else if (strTime === 'start') {
			nSeconds = 0;
		}
		else if (strTime === 'end') {
			//nSeconds = parseInt(duration - 0.5); 
			nSeconds = duration; 
		}
		else if (strTime[0] === '#') {
			// #n
			strTime = strTime.substr(1, strTime.length - 1);
			nSeconds = (-1) * parseInt(strTime);
		}
		else if (strTime === 'now' && currentTime !== undefined) {
			nSeconds = parseInt(currentTime + 1);
		}
		return nSeconds;
	}

	function convertStringToMseconds(strTime) {
		// validate parameter
		if (!strTime) {
			return null;
		}
		
		var nMseconds = null;
		var nPos;
		if (strTime.indexOf(':') === 2 && strTime.length >= 8) {
			// hh:mm:ss or hh:mm:ss.mmm
			nPos = strTime.indexOf(':');
			var nHours = parseInt(strTime.substr(0, nPos));
			strTime = strTime.substr(nPos + 1, strTime.length - nPos - 1);
			nPos = strTime.indexOf(':');
			var nMinuts = parseInt(strTime.substr(0, nPos));
			strTime = strTime.substr(nPos + 1, strTime.length - nPos - 1);
			nPos = strTime.indexOf('.');
			var nSecs = nPos > 0 ? parseInt(strTime.substr(0, nPos)) : parseInt(strTime);
			var nMsecs = 0;
			if (nPos > 0) {
				strTime = strTime.substr(nPos + 1, strTime.length - nPos - 1);
				nMsecs = parseInt(strTime);
			}
			nMseconds = (nHours * 3600 + nMinuts * 60 + nSecs) * 1000 + nMsecs; 
		}
		return nMseconds;
	}

	/**
	 * Returns an object that captures the portions of player state relevant to
	 * video playback. The result of this function can be passed to
	 * restorePlayerSnapshot with a player to return the player to the state it
	 * was in when this function was invoked.
	 * @param {object} player The videojs player object
	 */
	function getPlayerSnapshot(player) {
	  var tech = player.el().querySelector('.vjs-tech');

	  var snapshot = {
	    ended: player.ended(),
	    src: player.currentSrc(),
	    currentTime: player.currentTime(),
	    type: player.currentType(),
	    playing: player.scrubbing_ || !player.paused(),
	    suppressedTracks: getSuppressedTracks(player),
	    muted: player.muted(),
	    volume: player.volume()
	  };

	  if (tech) {
	    snapshot.nativePoster = tech.poster;
	    snapshot.style = tech.getAttribute('style');
	  }
	  var ua = _uaParser();
	  var os = ua.os.name.toLowerCase();
	  if (os === 'ios' &&  Math.abs(player.duration() - snapshot.currentTime) < 2) {
		  snapshot.postrollOnIOS = true;
		}
		var els = document.getElementsByClassName('vjs-dock-text');
		if (els && els.length > 0) {
			snapshot.dockText = els[0];
			snapshot.dockText.style.display = 'none';
		}
	  _logger.log(_prefix, 'Break snapshot = ', snapshot);
	  return snapshot;

	  /**** Local Functions ****/
	  function getSuppressedTracks(player) {
	    var tracks = player.remoteTextTracks ? player.remoteTextTracks() : [];

	    if (tracks && Array.isArray(tracks.tracks_)) {
	      tracks = tracks.tracks_;
	    }

	    if (!Array.isArray(tracks)) {
	      tracks = [];
	    }

	    var suppressedTracks = [];
	    tracks.forEach(function (track) {
	      suppressedTracks.push({
	        track: track,
	        mode: track.mode
	      });
	      track.mode = 'disabled';
	    });

	    return suppressedTracks;
	  }
	}

	/**
	 * Attempts to modify the specified player so that its state is equivalent to
	 * the state of the snapshot.
	 * @param {object} snapshot - the player state to apply
	 */
	function restorePlayerSnapshot(player, snapshot) {
	  var tech = player.el().querySelector('.vjs-tech');
	  var attempts = 40; // the number of remaining attempts to restore the snapshot

	  if (snapshot.nativePoster) {
	    tech.poster = snapshot.nativePoster;
	  }

	  if ('style' in snapshot) {
	    // overwrite all css style properties to restore state precisely
	    tech.setAttribute('style', snapshot.style || '');
		}
		
		if (snapshot.dockText) {
			snapshot.dockText.style.display = 'block';
		}

	  //if (hasSrcChanged(player, snapshot)) {
		    // on ios7, fiddling with textTracks too early will cause safari to crash
		    player.one('contentloadedmetadata', restoreTracks);
		
		    player.one('canplay', tryToResume);
		    ensureCanplayEvtGetsFired();
		
	        _logger.log(_prefix, 'Break snapshot.src = ', snapshot.src);
		    // if the src changed for ad playback, reset it
		    player.src({src: snapshot.src, type: snapshot.type});
		
		    // safari requires a call to `load` to pick up a changed source
		    //player.load();		// don't need more
		    
		    //player.muted(snapshot.muted);
		    //player.volume(snapshot.volume);
	  /* } else 
		   {
		    restoreTracks();
		
		    if (snapshot.playing) {
		      player.play();
		    }
	   }*/


	    /**
	     * Sometimes firefox does not trigger the 'canplay' evt.
	     * This code ensure that it always gets triggered triggered.
	     */
	    function ensureCanplayEvtGetsFired() {
		    var timeoutId = setTimeout(function() {
		      player.trigger('canplay');
		    }, 1000);
		
		    player.one('canplay', function(){
		      clearTimeout(timeoutId);
		    });
	    }

	    /**
	     * Determine whether the player needs to be restored to its state
	     * before ad playback began. With a custom ad display or burned-in
	     * ads, the content player state hasn't been modified and so no
	     * restoration is required
	     */
	    /*function hasSrcChanged(player, snapshot) {
	      if (player.src()) {
	        return player.src() !== snapshot.src;
	      }
	      // the player was configured through source element children
	      return player.currentSrc() !== snapshot.src;
	    }*/

	    function restoreTracks() {
	        var suppressedTracks = snapshot.suppressedTracks;
	        suppressedTracks.forEach(function (trackSnapshot) {
	          trackSnapshot.track.mode = trackSnapshot.mode;
	        });
	      }
	    
	    /**
	     * Determine if the video element has loaded enough of the snapshot source
	     * to be ready to apply the rest of the state
	     */
	    function tryToResume() {

	      // if some period of the video is seekable, resume playback
	      // otherwise delay a bit and then check again unless we're out of attempts

		    // safari 11 requiress a call to `play` to make seek available
	        player.play();
	        
	      if (!isReadyToResume(player) && attempts--) {
	        setTimeout(tryToResume, 100);
	      } else {
	        try {
	          if(player.currentTime() !== snapshot.currentTime) {
	            /*if (snapshot.playing) { // if needed restore playing status after seek completes
	              player.one('seeked', function() {
	                player.play();
	              });
	            }*/
	            player.one('seeked', function() {
	                _logger.log(_prefix, 'Break seeked event. player time = ', player.currentTime());
	            	if (snapshot.playing) {
	                    player.play();
	            	}
	            	else {
	            		if (!snapshot.ended) {
	                        player.pause();
	            		}
	            	}
								player.trigger('tryToResumeDone');
	            });
	            _logger.log(_prefix, 'Break snapshot.currentTime = ', snapshot.currentTime);
	            if (snapshot.postrollOnIOS) {
	            	// VIDLA-2522 - make sure video will stop at the end for post-roll on iOS devices
	            	snapshot.currentTime = player.duration() - 1;
	            	snapshot.playing = true;
	            }
							player.currentTime(snapshot.currentTime);

	          } else if (snapshot.playing) {
	            // if needed and no seek has been performed, restore playing status immediately
	            player.play();
							player.trigger('tryToResumeDone');
	          }

	        } catch (e) {
						player.trigger('tryToResumeDone');
	        	_logger.log(_prefix, 'Failed to resume the content after an advertisement', e);
	        }
	      }
	    }
	    
	    function isReadyToResume(player) {

	    	  if (player.readyState() > 1) {
	    	    // some browsers and media aren't "seekable".
	    	    // readyState greater than 1 allows for seeking without exceptions
	    	    return true;
	    	  }
	    	  
	    	  if (player.seekable() === undefined) {
	    	    // if the player doesn't expose the seekable time ranges, try to
	    	    // resume playback immediately
	    	    return true;
	    	  }

	    	  if (player.seekable().length > 0) {
	    	    // if some period of the video is seekable, resume playback
	    	    return true;
	    	  }

	    	  return false;
	    }
	}

	module.exports = {
		convertSecsToString: convertSecsToString,
		getUUID: getUUID,
		trackUrls: trackUrls,
		showNextOverlay: showNextOverlay,
		convertStringToSeconds: convertStringToSeconds,
		convertStringToMseconds: convertStringToMseconds,
		getPlayerSnapshot: getPlayerSnapshot,
		restorePlayerSnapshot: restorePlayerSnapshot
	};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	var _logger = __webpack_require__(3);
	var _loader = __webpack_require__(11);
	var _vastParser = __webpack_require__(5);
	var _xmlParserHelper = __webpack_require__(18);
	var _utils = __webpack_require__(16);
	var _prefix = 'apnVmapVast->impbusCommunicator';

	var impbusCommunicator = function () {
		var _player;
		var _callback;
		var _options;
		var _defaultImpbusTimeout = 700;
		var _timeout;
		var _mediaInfo;
		var _helper = new _xmlParserHelper();
		
		function modifyAndReturnVastXml(vastObj) {
			if (_options && _options.skippable) {
				if (_options.skippable.enabled) {
					if (_options.skippable.videoThreshold) {
						if (vastObj.durationMsecs < _options.skippable.videoThreshold * 1000) {
							if (vastObj.skipOffset) {
								delete vastObj.skipOffset;
							}
						}
					}
					if (_options.skippable.videoOffset) {
						var strOffset = _utils.convertSecsToString(_options.skippable.videoOffset);
						vastObj.skipOffset = strOffset;
					}
				}
				else {
					if (vastObj.skipOffset) {
						delete vastObj.skipOffset;
					}
				}
			}
			if (vastObj.vastXml && _options && _options.skippable) {
				// update skipOffset in vastXml
				var xmlDoc = (new DOMParser()).parseFromString(vastObj.vastXml, 'text/xml');
				var linear = _helper.getSubNode(xmlDoc, 'Linear', 0);
				if (linear) {
					// remove skippOffset attribute
					linear.removeAttribute('skipoffset');
					if (vastObj.skipOffset) {
						// add new skipoffset attribute if needed 
	                    var attr = xmlDoc.createAttribute('skipoffset');
	                    attr.value = vastObj.skipOffset;
	                    linear.setAttributeNode(attr);
					}
					vastObj.vastXml = (new XMLSerializer()).serializeToString(xmlDoc);
				}
			}
			var additionalTrackers = {};
			if (_options && _options.trackers && _options.trackers.length > 0) {
				var impressions = _options.trackers[0].impression_urls;
				var errors = _options.trackers[0].error_urls;
				if (impressions) {
					additionalTrackers.impressions = impressions;
				}
				if (errors) {
					additionalTrackers.errors = errors;
				}
				var videoClicks = _options.trackers[0].video_click_urls;
				if (videoClicks && videoClicks.length > 0) {
					if (vastObj.clickTrackingUrl) {
						vastObj.clickTrackingUrl = vastObj.clickTrackingUrl.concat(videoClicks);
					}
					else {
						vastObj.clickTrackingUrl = videoClicks;
					}
				}
				var videoEvents = _options.trackers[0].video_events;
				if (videoEvents) {
					for (var event in videoEvents) {
						if (vastObj.trackingUrls.hasOwnProperty(event)) {
							vastObj.trackingUrls[event] = vastObj.trackingUrls[event].concat(videoEvents[event]);
						}
						else {
							vastObj.trackingUrls[event] = videoEvents[event];
						}
					}
				}
			}
			// prepare unwrapped VAST xml
			var vastXml = _vastParser.getUnwrappedVastTag(vastObj, null, null, null, null, null, additionalTrackers);
			if (vastXml) {
				_callback(vastXml);
			}
			else {
				_callback(null, '900', 'Failed to generate unwrapped VAST xml');
			}
		}
		
		// PTV functions
	 	var processPtvResponse = function(xml, errCode, errMessage) {
			if (errCode) {
				_callback(null, errCode, errMessage);
			}
			else {
				_vastParser.parse(xml, function(succ, id, vast, errorUrls) {
					if (!succ) {
						var code = '100';
						if (vast.indexOf('vast') === 0) {
							code = vast.substr(4, vast.length - 4);
						}
						if (errorUrls && errorUrls.length > 0) {
							_utils.trackUrls(errorUrls);
						}
						_callback(null, code, 'failed to parse VAST xml from impbus');
					}
					else {
						modifyAndReturnVastXml(vast);
					}
				}, null, 1000, null, null, _options);
			}
		};
		
		function makePtvRequest (impbusUrl, timeout) {
			_loader.load(impbusUrl, function(errorStatus, responseText, xhrObject) {
				if (errorStatus) {
					if (errorStatus === 'Timeout') {
						processPtvResponse(null, '408', errorStatus);
					}
					else {
						processPtvResponse(null, errorStatus, xhrObject.statusText);
					}
				}
				else {
					processPtvResponse(responseText);
				}
			}, timeout);
		}
		
		// UT functions
		var getVastObjFromUtResponse = function(utRespData, callback, timeout) {
			if (utRespData && utRespData.tags && utRespData.tags.length > 0) {
				var tag = utRespData.tags[0];
				_options.noAdUrl = tag.no_ad_url;
				if (tag.ads && tag.ads.length > 0) {
					var ad = null;
					var i;
					// try to find rtb
					for (i = 0; i < tag.ads.length; i++) {
						if (tag.ads[i].content_source === 'rtb' && tag.ads[i].ad_type === 'video') {
							ad = tag.ads[i];
							break;
						}
					}
					if (!ad) {
						// try to find video ad
						for (i = 0; i < tag.ads.length; i++) {
							if (tag.ads[i].ad_type === 'video') {
								ad = tag.ads[i];
								break;
							}
						}
					}
					if (ad) {
						_options.notifyUrl = ad.notify_url;
						_options.usersyncUrl = ad.usersync_url;
						_options.viewability = ad.viewability;
						_options.requestUrl = ad[ad.content_source].request_url;
						_options.responseUrl = ad[ad.content_source].respondse_url;
						_options.trackers = ad[ad.content_source].trackers;
						var xml = null;
						if (ad[ad.content_source].video && ad[ad.content_source].video.content) {
							xml = ad[ad.content_source].video.content;
						}
						else if (ad[ad.content_source].video && ad[ad.content_source].video.content_b64) {
							var Base64 = __webpack_require__(19).Base64;
							xml = Base64.decode(ad[ad.content_source].video.content_b64);	
						}
						else if (ad[ad.content_source].handler && ad[ad.content_source].handler.length > 0 &&
								ad[ad.content_source].handler[0].url) {
							_loader.load(ad[ad.content_source].handler[0].url, function(errorStatus, responseText, xhrObject) {
								if (errorStatus) {
									if (errorStatus === 'Timeout') {
										callback(null, '408', errorStatus);
									}
									else {
										callback(null, errorStatus, xhrObject.statusText);
									}
								}
								else {
									xml = responseText;
									_vastParser.parse(xml, function(succ, id, vast, errorUrls) {
										if (!succ) {
											var code = '100';
											if (vast.indexOf('vast') === 0) {
												code = vast.substr(4, vast.length - 4);
											}
											if (errorUrls && errorUrls.length > 0) {
												_utils.trackUrls(errorUrls);
											}
											callback(null, code, 'failed to parse VAST xml from impbus');
										}
										else {
											callback(vast);
										}
									}, null, 1000, null, null, _options);
								}
							}, timeout);
						}
						else {
							callback(null, '900', 'Failed to get xml from ad in impbus response');
						}
						if (xml) {
							_vastParser.parse(xml, function(succ, id, vast, errorUrls) {
								if (!succ) {
									var code = '100';
									if (vast.indexOf('vast') === 0) {
										code = vast.substr(4, vast.length - 4);
									}
									if (errorUrls && errorUrls.length > 0) {
										_utils.trackUrls(errorUrls);
									}
									callback(null, code, 'failed to parse VAST xml from impbus');
								}
								else {
									callback(vast);
								}
							}, null, 1000, null, null, _options);
						}
					}
					else {
						callback(null, '900', 'No available ad had been found in impbus response');
					}
				}
				else {
					callback(null, '900', 'No ads in first tag in impbus response');
				}
			}
			else {
				callback(null, '900', 'No tags in impbus response');
			}
		};
		
	 	var processUtResponse = function(utRespData, errCode, errMessage) {
	 		if (errCode) {
	 			_callback(null, errCode, errMessage);
	 			return;
	 		}
	 		getVastObjFromUtResponse(utRespData, function(vastObj, errCode, errMessage) {
	 	 		if (errCode) {
	 	 			_callback(null, errCode, errMessage);
	 	 			return;
	 	 		}
	 	 		modifyAndReturnVastXml(vastObj);
	 		}, _timeout);
	 	};

	 	function makeUtRequest (impbusUrl, reqData, timeout) {
	       	reqData.uuid = _utils.getUUID();
	       	if (reqData.tags && reqData.tags.length > 0) {
	       		for (var i = 0; i < reqData.tags.length; i++) {
	               	reqData.tags[i].uuid = _utils.getUUID();
	       		}
	       	}
	       	var strReqData = JSON.stringify(reqData);
	       	_loader.loadPost(impbusUrl, strReqData, function(errorStatus, responseText, xhrObject) {
	            if (!errorStatus) {
	                //if we have loaded succesfully
	                if (xhrObject && xhrObject.responseType === 'json') {
	                	processUtResponse(xhrObject.response);
	                } else {
	                    try {
	                        if (xhrObject.responseText) {
	                            var parsedJsonObject = JSON.parse(xhrObject.responseText);
	                            processUtResponse(parsedJsonObject);
	                        } else {
	                        	processUtResponse(null, '900', 'load failure: empty impbus response');
	                        }
	                    } catch (e) {
	                    	processUtResponse(this, '100', 'failed to parse UT impbus response');
	                    }
	                }
	            } else {
	                //if we have failed to load
	            	_logger.warn(_prefix, "Unable to load from ib:" + errorStatus);
	                switch (errorStatus) {
	                    case "Timeout":
	                    	processUtResponse(null, '408', errorStatus);
	                        break;
	                    default:
	                    	processUtResponse(null, errorStatus, xhrObject.statusText);
	                        break;
	                }
	            }
			}, timeout);
		}
		
	 	// VMAP functions
		function makeVmapRequest (impbusUrl, timeout, callback) {
			_loader.load(impbusUrl, function(errorStatus, responseText, xhrObject) {
				if (errorStatus) {
					if (errorStatus === 'Timeout') {
						callback(impbusUrl, null, '408', errorStatus);
					}
					else {
						callback(impbusUrl, null, errorStatus, xhrObject.statusText);
					}
				}
				else {
					callback(impbusUrl, responseText);
				}
			}, timeout);
		}

		// request preparation function
		function resolveStaticMacros(sourceUrl) {
			var url = sourceUrl;
			if (_mediaInfo) {
				var macros = {
					'{player.id}': _player.bcinfo.playerId,	// _player.el_getAttribute('data-player'),
					'{mediainfo.id}': _mediaInfo.id,
					'{mediainfo.name}': _mediaInfo.name,
					'{mediainfo.description}': _mediaInfo.description ? _mediaInfo.description : '',
					'{mediainfo.tags}': _mediaInfo.tags,
					'{mediainfo.referenceID}': _mediaInfo.referenceId ? _mediaInfo.referenceId : '',
					'{mediainfo.duration}': _mediaInfo.duration,
					'{mediainfo.ad_keys}': _mediaInfo.adKeys ? _mediaInfo.adKeys : '',
					'{player.duration}': _player.duration(),
					'{document.referrer}': document.referrer,
					'{window.location.href}': window.location.href,
					'{player.url}': _player.bcinfo.scriptUrl,
					'{timestamp}': Date.now(),
					'{random}': parseInt(Math.random() * 1000000000000)
				};
				for (var i in macros) {
					url = url.split(i).join(encodeURIComponent(macros[i]));
				}
			}
			return url;
		}

		function resolveDynamicMacros(sourceUrl) {
			var url = sourceUrl;
			if (_mediaInfo && _mediaInfo.customFields) {
				for (var i in _mediaInfo.customFields) {
					url = url.split('{mediainfo.customFields.' + i + '}').join(encodeURIComponent(_mediaInfo.customFields[i]));
				}
			}
			return url;
		}

		function resolveKeywordsAndMacros(sourceUrl) {
			var url = sourceUrl;
			if (_options.tagKeywords) {
				for (var key in _options.tagKeywords) {
					var param = '&kw_' + key + '=' + _options.tagKeywords[key];
					url += param;
				}
			}
			url = resolveStaticMacros(url);
			url = resolveDynamicMacros(url);
			return url;
		}
		
	    this.getXML = function (options, player, callback) {
	    	_callback = callback;
			_options = options;
			_player = player;
			if (_player.mediainfo && _player.mediainfo.name) {
				_mediaInfo = _player.mediainfo;
			}
	    	
	    	var impbusUrl;
	        if (_options && _options.endpointUrl) {
	           impbusUrl = _options.endpointUrl;
	        } else {
	           impbusUrl = '//';
	        }
	        
			_timeout = _options && _options.timeouts && _options.timeouts.adCallTimeout ? _options.timeouts.adCallTimeout : _defaultImpbusTimeout;
	    	if (_options.vmapEnabled) {
	    		// prepare vmap request links
	    		var arrVmapRequestData = [];
	    		var i;
	    		if (Array.isArray(_options.apnTagParams)) {
	    			for (i = 0; i < _options.apnTagParams.length; i++) {
	    				arrVmapRequestData.push(impbusUrl + _options.apnTagParams[i]);
	    			}
	    		}
	    		else {
	    			arrVmapRequestData.push(impbusUrl + _options.apnTagParams);
	    		}
	    		
				var vmapXmls = [];
	    		var requestCount = 0;
	    		var vmapRequestCallback = function(url, xml, errorCode, errorMessage) {
					if (errorCode || errorMessage) {
						_logger.warn(_prefix, "VMAP request url: " + arrVmapRequestData[i]);
						_logger.warn(_prefix, "Unable to get VMAP xml from ib. Error code: " + errorCode + ", message: " + errorMessage);
					}
					else if (xml && xml.length > 0) {
						vmapXmls.push({url: url, xml: xml});
					}
					requestCount++;
					if (requestCount === arrVmapRequestData.length) {
						if (vmapXmls.length > 0) {
							callback(vmapXmls);
						}
						else {
							callback(null);
						}
					}
				};
				
				var prepareVmapRequestData = function() {
					for (i = 0; i < arrVmapRequestData.length; i++) {
						var vmapUrl = resolveKeywordsAndMacros(arrVmapRequestData[i]);
						makeVmapRequest(vmapUrl, _timeout, vmapRequestCallback);
				 	}
				};

				if (_mediaInfo) {
					prepareVmapRequestData();
				}
				else {
					_player.one('loadstart',function(){
						_mediaInfo = _player.mediainfo;
						prepareVmapRequestData();
					});		
				}
	    	}
	    	else {
	    		if (typeof _options.apnTagParams === 'string') {
	    			// ptv call for single ad
	    			if (_options && !_options.skippable) {
	    				// check skippability in query params
	    				if (_options.apnTagParams.indexOf('vskippable=0') >= 0) {
	    					_options.skippable = {enabled : false};
	    				}
	    			}
					// ptv call for single ad
					var ptvUrl = impbusUrl + _options.apnTagParams;
					var preparePtvRequestData = function() {
						var tempUrl = resolveKeywordsAndMacros(ptvUrl);
						makePtvRequest(tempUrl, _timeout);
					};
					if (_mediaInfo) {
						preparePtvRequestData();
					}
					else {
						_player.one('loadstart',function(){
							_mediaInfo = _player.mediainfo;
							if (!isNaN(_player.duration()) && _player.duration() > 0) {
								preparePtvRequestData();
							}
							else {
								_player.one('loadedmetadata', preparePtvRequestData);
							}
						});		
					}
	     		}
	    		else {
					// ut call for single ad
					var prepareUtRequestData = function() {
						var temp = JSON.stringify(_options.apnTagParams);
						var resolvedUtRequest = resolveStaticMacros(temp);
						resolvedUtRequest = resolveDynamicMacros(resolvedUtRequest);
						var apnTagParams = JSON.parse(resolvedUtRequest);
						makeUtRequest(impbusUrl + '/ut/v3', apnTagParams, _timeout);
					};
					if (_mediaInfo) {
						prepareUtRequestData();
					}
					else {
						_player.one('loadstart',function(){
							_mediaInfo = _player.mediainfo;
							if (!isNaN(_player.duration()) && _player.duration() > 0) {
								prepareUtRequestData();
							}
							else {
								_player.one('loadedmetadata', prepareUtRequestData);
							}
						});		
					}
	    		}
	    	}
	    };

	};

	module.exports = impbusCommunicator;


/***/ }),
/* 18 */
/***/ (function(module, exports) {

	var XMLParserHelper = function () {
	    this.getSubNodes = function (node, subNodeName) {
	        var nodes = node.getElementsByTagName(subNodeName);
	        if (nodes.length > 0) {
	            return nodes;
	        }
	        return null;
	    };

	    this.getSubNode = function (node, subNodeName, index) {
	        if (!index) {
	            index = 0;
	        }
	        var nodes = node.getElementsByTagName(subNodeName);
	        if (nodes.length > index) {
	            return nodes[index];
	        }
	        return null;
	    };

	    this.getNodeValue = function (node) {
	        if (node.childNodes.length === 0) {
	            return '';
	        }
	        var val = node.childNodes[0].nodeValue;
	        if (val) {
	            return val.trim();
	        }
	        return '';
	    };

	    this.getNodeValues = function (node) {
	        if (node.childNodes.length === 0) {
	            return '';
	        }
	        var wholeVal = '';
	        for (var i = 0; i < node.childNodes.length; i++) {
	            var val = node.childNodes[i].nodeValue;
	            if (val) {
	            	wholeVal += val;
	            }
	        }
	        return wholeVal.trim();
	    };

	    this.getNodeAttributeValue = function (node, attributeName) {
	        var val = node.getAttribute(attributeName);
	        if (val === null) {
	            val = '';
	        }
	        return val;
	    };

	    this.getNodeAttributeNumberValue = function (node, attributeName, defaultValue) {
	        if (!defaultValue) {
	            defaultValue = 0;
	        }
	        var answer = defaultValue;
	        var val = this.getNodeAttributeValue(node, attributeName);

	        if (val.length > 0) {
	            if (val.indexOf('.') >= 0) {
	                answer = parseFloat(val);
	            }
	            else {
	                answer = parseInt(val);
	            }
	        }

	        return answer;
	    };

	    this.getNodeAttributeBooleanValue = function (node, attributeName, defaultValue) {
	        if (!defaultValue) {
	            defaultValue = false;
	        }
	        var answer = defaultValue;
	        var val = this.getNodeAttributeValue(node, attributeName);

	        if (val.length > 0) {
	            var char = val.toLowerCase().charAt(0);
	            answer = (char === 't');
	        }

	        return answer;
	    };

	    this.getSubNodeValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
	        var subnode = this.getSubNode(parentNode, subNodeName);
	        if (subnode !== null) {
	            return this.getNodeValue(subnode);
	        }
	        return defaultValue;
	    };

	    this.getSubNodeWholeValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
	        var subnode = this.getSubNode(parentNode, subNodeName);
	        if (subnode !== null) {
	            return this.getNodeValues(subnode);
	        }
	        return defaultValue;
	    };

	    this.getSubNodeBooleanValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? 'false' : defaultValue;

	        var value = this.getSubNodeValue(parentNode, subNodeName);
	        if (value.length > 0 && value.toLowerCase().charAt(0) === 't') {
	            return true;
	        }
	        if (value.length > 0 && value.toLowerCase().charAt(0) === 'f') {
	            return false;
	        }
	        return defaultValue;
	    };
	};

	module.exports = XMLParserHelper;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/*
	 *  base64.js
	 *
	 *  Licensed under the BSD 3-Clause License.
	 *    http://opensource.org/licenses/BSD-3-Clause
	 *
	 *  References:
	 *    http://en.wikipedia.org/wiki/Base64
	 */
	;(function (global, factory) {
	     true
	        ? module.exports = factory(global)
	        : typeof define === 'function' && define.amd
	        ? define(factory) : factory(global)
	}((
	    typeof self !== 'undefined' ? self
	        : typeof window !== 'undefined' ? window
	        : typeof global !== 'undefined' ? global
	: this
	), function(global) {
	    'use strict';
	    // existing version for noConflict()
	    var _Base64 = global.Base64;
	    var version = "2.4.8";
	    // if node.js and NOT React Native, we use Buffer
	    var buffer;
	    if (typeof module !== 'undefined' && module.exports) {
	        if (typeof navigator != 'undefined' && navigator.product == 'ReactNative') {
	        } else {
	            try {
	                buffer = __webpack_require__(20).Buffer;
	            } catch (err) {}
	        }
	    }
	    // constants
	    var b64chars
	        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	    var b64tab = function(bin) {
	        var t = {};
	        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
	        return t;
	    }(b64chars);
	    var fromCharCode = String.fromCharCode;
	    // encoder stuff
	    var cb_utob = function(c) {
	        if (c.length < 2) {
	            var cc = c.charCodeAt(0);
	            return cc < 0x80 ? c
	                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
	                                + fromCharCode(0x80 | (cc & 0x3f)))
	                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
	                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
	                   + fromCharCode(0x80 | ( cc         & 0x3f)));
	        } else {
	            var cc = 0x10000
	                + (c.charCodeAt(0) - 0xD800) * 0x400
	                + (c.charCodeAt(1) - 0xDC00);
	            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
	                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
	                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
	                    + fromCharCode(0x80 | ( cc         & 0x3f)));
	        }
	    };
	    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
	    var utob = function(u) {
	        return u.replace(re_utob, cb_utob);
	    };
	    var cb_encode = function(ccc) {
	        var padlen = [0, 2, 1][ccc.length % 3],
	        ord = ccc.charCodeAt(0) << 16
	            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
	            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
	        chars = [
	            b64chars.charAt( ord >>> 18),
	            b64chars.charAt((ord >>> 12) & 63),
	            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
	            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
	        ];
	        return chars.join('');
	    };
	    var btoa = global.btoa ? function(b) {
	        return global.btoa(b);
	    } : function(b) {
	        return b.replace(/[\s\S]{1,3}/g, cb_encode);
	    };
	    var _encode = buffer ?
	        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
	        ? function (u) {
	            return (u.constructor === buffer.constructor ? u : buffer.from(u))
	                .toString('base64')
	        }
	        :  function (u) {
	            return (u.constructor === buffer.constructor ? u : new  buffer(u))
	                .toString('base64')
	        }
	        : function (u) { return btoa(utob(u)) }
	    ;
	    var encode = function(u, urisafe) {
	        return !urisafe
	            ? _encode(String(u))
	            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
	                return m0 == '+' ? '-' : '_';
	            }).replace(/=/g, '');
	    };
	    var encodeURI = function(u) { return encode(u, true) };
	    // decoder stuff
	    var re_btou = new RegExp([
	        '[\xC0-\xDF][\x80-\xBF]',
	        '[\xE0-\xEF][\x80-\xBF]{2}',
	        '[\xF0-\xF7][\x80-\xBF]{3}'
	    ].join('|'), 'g');
	    var cb_btou = function(cccc) {
	        switch(cccc.length) {
	        case 4:
	            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
	                |    ((0x3f & cccc.charCodeAt(1)) << 12)
	                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
	                |     (0x3f & cccc.charCodeAt(3)),
	            offset = cp - 0x10000;
	            return (fromCharCode((offset  >>> 10) + 0xD800)
	                    + fromCharCode((offset & 0x3FF) + 0xDC00));
	        case 3:
	            return fromCharCode(
	                ((0x0f & cccc.charCodeAt(0)) << 12)
	                    | ((0x3f & cccc.charCodeAt(1)) << 6)
	                    |  (0x3f & cccc.charCodeAt(2))
	            );
	        default:
	            return  fromCharCode(
	                ((0x1f & cccc.charCodeAt(0)) << 6)
	                    |  (0x3f & cccc.charCodeAt(1))
	            );
	        }
	    };
	    var btou = function(b) {
	        return b.replace(re_btou, cb_btou);
	    };
	    var cb_decode = function(cccc) {
	        var len = cccc.length,
	        padlen = len % 4,
	        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
	            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
	            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
	            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
	        chars = [
	            fromCharCode( n >>> 16),
	            fromCharCode((n >>>  8) & 0xff),
	            fromCharCode( n         & 0xff)
	        ];
	        chars.length -= [0, 0, 2, 1][padlen];
	        return chars.join('');
	    };
	    var atob = global.atob ? function(a) {
	        return global.atob(a);
	    } : function(a){
	        return a.replace(/[\s\S]{1,4}/g, cb_decode);
	    };
	    var _decode = buffer ?
	        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
	        ? function(a) {
	            return (a.constructor === buffer.constructor
	                    ? a : buffer.from(a, 'base64')).toString();
	        }
	        : function(a) {
	            return (a.constructor === buffer.constructor
	                    ? a : new buffer(a, 'base64')).toString();
	        }
	        : function(a) { return btou(atob(a)) };
	    var decode = function(a){
	        return _decode(
	            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
	                .replace(/[^A-Za-z0-9\+\/]/g, '')
	        );
	    };
	    var noConflict = function() {
	        var Base64 = global.Base64;
	        global.Base64 = _Base64;
	        return Base64;
	    };
	    // export Base64
	    global.Base64 = {
	        VERSION: version,
	        atob: atob,
	        btoa: btoa,
	        fromBase64: decode,
	        toBase64: encode,
	        utob: utob,
	        encode: encode,
	        encodeURI: encodeURI,
	        btou: btou,
	        decode: decode,
	        noConflict: noConflict
	    };
	    // if ES5 is available, make Base64.extendString() available
	    if (typeof Object.defineProperty === 'function') {
	        var noEnum = function(v){
	            return {value:v,enumerable:false,writable:true,configurable:true};
	        };
	        global.Base64.extendString = function () {
	            Object.defineProperty(
	                String.prototype, 'fromBase64', noEnum(function () {
	                    return decode(this)
	                }));
	            Object.defineProperty(
	                String.prototype, 'toBase64', noEnum(function (urisafe) {
	                    return encode(this, urisafe)
	                }));
	            Object.defineProperty(
	                String.prototype, 'toBase64URI', noEnum(function () {
	                    return encode(this, true)
	                }));
	        };
	    }
	    //
	    // export Base64 to the namespace
	    //
	    if (global['Meteor']) { // Meteor.js
	        Base64 = global.Base64;
	    }
	    // module.exports and AMD are mutually exclusive.
	    // module.exports has precedence.
	    if (typeof module !== 'undefined' && module.exports) {
	        module.exports.Base64 = global.Base64;
	    }
	    else if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){ return global.Base64 }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    // that's it!
	    return {Base64: global.Base64}
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(21)
	var ieee754 = __webpack_require__(22)
	var isArray = __webpack_require__(23)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()

	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer.poolSize = 8192 // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}

	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }

	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)

	  var actual = that.write(string, encoding)

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len)
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }

	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}

	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8'

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true

	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}

	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}

	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}

	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0

	  if (this === target) return 0

	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)

	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}

	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }

	  return len
	}

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0

	  if (!val) val = 0

	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }

	  return this
	}

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	'use strict'

	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray

	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}

	// Support decoding URL-safe base64 strings, as Node.js does.
	// See: https://en.wikipedia.org/wiki/Base64#URL_applications
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63

	function getLens (b64) {
	  var len = b64.length

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // Trim off extra bytes after placeholder bytes are found
	  // See: https://github.com/beatgammit/base64-js/issues/42
	  var validLen = b64.indexOf('=')
	  if (validLen === -1) validLen = len

	  var placeHoldersLen = validLen === len
	    ? 0
	    : 4 - (validLen % 4)

	  return [validLen, placeHoldersLen]
	}

	// base64 is 4/3 + up to two characters of the original data
	function byteLength (b64) {
	  var lens = getLens(b64)
	  var validLen = lens[0]
	  var placeHoldersLen = lens[1]
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function _byteLength (b64, validLen, placeHoldersLen) {
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function toByteArray (b64) {
	  var tmp
	  var lens = getLens(b64)
	  var validLen = lens[0]
	  var placeHoldersLen = lens[1]

	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

	  var curByte = 0

	  // if there are placeholders, only get up to the last complete 4 chars
	  var len = placeHoldersLen > 0
	    ? validLen - 4
	    : validLen

	  for (var i = 0; i < len; i += 4) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 18) |
	      (revLookup[b64.charCodeAt(i + 1)] << 12) |
	      (revLookup[b64.charCodeAt(i + 2)] << 6) |
	      revLookup[b64.charCodeAt(i + 3)]
	    arr[curByte++] = (tmp >> 16) & 0xFF
	    arr[curByte++] = (tmp >> 8) & 0xFF
	    arr[curByte++] = tmp & 0xFF
	  }

	  if (placeHoldersLen === 2) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 2) |
	      (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[curByte++] = tmp & 0xFF
	  }

	  if (placeHoldersLen === 1) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 10) |
	      (revLookup[b64.charCodeAt(i + 1)] << 4) |
	      (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[curByte++] = (tmp >> 8) & 0xFF
	    arr[curByte++] = tmp & 0xFF
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] +
	    lookup[num >> 12 & 0x3F] +
	    lookup[num >> 6 & 0x3F] +
	    lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp =
	      ((uint8[i] << 16) & 0xFF0000) +
	      ((uint8[i + 1] << 8) & 0xFF00) +
	      (uint8[i + 2] & 0xFF)
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(
	      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
	    ))
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    parts.push(
	      lookup[tmp >> 2] +
	      lookup[(tmp << 4) & 0x3F] +
	      '=='
	    )
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
	    parts.push(
	      lookup[tmp >> 10] +
	      lookup[(tmp >> 4) & 0x3F] +
	      lookup[(tmp << 2) & 0x3F] +
	      '='
	    )
	  }

	  return parts.join('')
	}


/***/ }),
/* 22 */
/***/ (function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = (nBytes * 8) - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = (nBytes * 8) - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ }),
/* 23 */
/***/ (function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * VMAP Parser module.
	 * @module VmapParser
	 */

	var VmapXMLParserHelper = __webpack_require__(25);

	var VmapParser = function (nMsecTimeout, options) {

	    var _logger = __webpack_require__(3);
	    var _prefix = 'VMAP Parser:';
	    var _uaParser = __webpack_require__(9);
	    var _ua = _uaParser();

	    var _callback = null;
	    var _options = options || {};
	    var _nTimeOut = nMsecTimeout && nMsecTimeout > 0 ? nMsecTimeout : 1000;	// 1 second default
	    var _nStopTime = Date.now() + _nTimeOut;

	    var _helper = new VmapXMLParserHelper();
	    var _vmapVersion = '';
	    
	    var _vmapObj = {};
	    
	    var _arrErrorUrls = [];

	    _logger.always(_prefix, 'Version 1.0.5');
	    
	    _options.vmap = true;
	    
	    function getInnerHTML(node) {
	        var browser = _ua.browser.name.toLowerCase();
			var value;
			if (browser === 'ie') {
				value = (new XMLSerializer()).serializeToString(node);
				value = value.replace(/&lt;/g, '<');
				value = value.replace(/&gt;/g, '>');
				var nPos = value.indexOf('>');
				if (nPos > 0) {
					value = value.substr(nPos + 1);
				}
				nPos = value.lastIndexOf('</');
				if (nPos > 0) {
					value = value.substr(0, nPos);
				}
			}
			else {
				value = node.innerHTML;
			}
			return value;
	    }

	    function getVMAPVersion(vmapNode) {
	        var version = 'unknown';
	        if (vmapNode) {
	            version = _helper.getNodeAttributeValue(vmapNode, 'version');
	            version = version.trim();
	            if (version.length > 3) {
	                version = version.substr(0, 3);
	            }
	        }
	        return version;
	    }

	    function substituteErrorCode(arrErrorUrls, errorCode) {
	        if (arrErrorUrls && arrErrorUrls.length > 0) {
	            for (var i = 0; i < arrErrorUrls.length; i++) {
	                arrErrorUrls[i] = arrErrorUrls[i].replace('[ERROR_CODE]', errorCode);
	            }
	        }
	    }

	    function isInArray(arr, value) {
	        for (var i = 0; i < arr.length; i++) {
	            if (arr[i] === value) {
	                return true;
	            }
	        }
	        return false;
	    }
	    
	    function addTrackings(parentNode, arrTrackings) {
	        var nodes = _helper.getSubNodes(parentNode, 'vmap:Tracking');
	        if (nodes) {
	            for (var i = 0; i < nodes.length; i++) {
	                var node = nodes[i];
	                var url = _helper.getNodeValues(node);
	                if (url) {
	                    var event = _helper.getNodeAttributeValue(node, 'event');
	                    if (event) {
	                    	var arr = null;
	                    	for (var j = 0; j < arrTrackings.length; j++) {
	                    		if (arrTrackings[j].event === event) {
	                    			arr = arrTrackings[j].uris;
	                    			break;
	                    		}
	                    	}
	                    	if (!arr) {
	                    		arr = [];
	                    		arrTrackings.push({event: event, uris: arr});
	                    	}
	                        if (arr.length > 0) {
	                            if (!isInArray(arr, url)) {
	                                arr.push(url);
	                            }
	                        }
	                        else {
	                            arr.push(url);
	                        }
	                    }
	                }
	            }
	        }
	    }

	    function addExtensions(obj, parentNode) {
	        if (parentNode) {
	            var extensions = _helper.getSubNode(parentNode, 'vmap:Extensions');
	            if (extensions) {
	            	obj.extensions = [];
	            	var extensionNodes = _helper.getSubNodes(extensions, 'vmap:Extension');
	            	if (extensionNodes) {
	            		for (var i = 0; i < extensionNodes.length; i++) {
	            			var value = getInnerHTML(extensionNodes[i]);
	            			if (value) {
	            				value = trimXml(value);
	            				if (value.length > 0) {
	                                var type = _helper.getNodeAttributeValue(extensionNodes[i], 'type');
	                                if (type) {
	                                	obj.extensions.push({type: type, xmlData: value});
	                                }
	            				}
	            			}
	            		}
	            	}
	            }
	        }
	    }

	    function trimXml(strVmapXml) {
	        var nPos = strVmapXml.indexOf('<');
	        var strXml = strVmapXml.substr(nPos === -1 ? 0 : nPos);
	        nPos = strXml.lastIndexOf('>');
	        if (nPos !== -1) {
	            strXml = strXml.substr(0, nPos + 1);
	        }
	        return strXml.trim();
	    }

	    function isValidVmapVersion(vmapVersion) {
	        return vmapVersion === '1.0';
	    }

	    function reportError(errCode, message, trackings, continueProcess) {
	        if (trackings && trackings.length > 0) {
	        	for (var i = 0; i < trackings.length; i++) {
	        		if (trackings[i].event === 'error') {
	        	        substituteErrorCode(trackings[i].uris, errCode);
	        	        _logger.error(_prefix, 'Error ' + errCode + ' - ' + message);
	        			_arrErrorUrls = _arrErrorUrls.concat(trackings[i].uris);
	        			break;
	        		}
	        	}
	        }
	        if (!continueProcess && _callback) {
	        	_callback(false, null, _arrErrorUrls);
	        	_callback = null;
	        }
			if (_callback && allBreaksParsed()) {
				finishParsing();
			}
	    }

	    function parseXML(strVmapXml) {
	        var strXml = trimXml(strVmapXml);
	        if (strXml.length === 0) {
	            reportError('1000', 'Empty VMAP xml');
	            return;
	        }
	        var xmlDoc = null;
	        if (typeof window.DOMParser !== 'undefined') {
	            xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
	            if (xmlDoc.documentElement.nodeName === 'parsererror') {
	                try {
	                    _logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
	                }
	                catch (e) {
	                }
	                reportError('1002', 'VMAP XML parsing error');
	                return;
	            }
	        }
	        else if (typeof window.ActiveXObject !== 'undefined') {
	            try {
	                xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
	                xmlDoc.loadXML(strXml);
	                if (xmlDoc.parseError.errorCode !== 0) {
	                    _logger.error(_prefix, xmlDoc.parseError);
	                    reportError('1002', xmlDoc.parseError.errorCode + ', Error reason = ' + xmlDoc.parseError.reason);
	                    return;
	                }
	            }
	            catch (ex) {
	                _logger.error(_prefix, 'Failed to parse vmap xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
	                reportError('1002', 'Failed to parse vmap xml by window.ActiveXObject(Microsoft.XMLDOM)');
	                return;
	            }
	        }
	        else {
	            _logger.error(_prefix, 'Failed to parse vmap xml by window.ActiveXObject(Microsoft.XMLDOM)');
	            reportError('1002', 'Failed to get vmap xml');
	            return;
	        }
	        if (!xmlDoc) {
	            reportError('1002', 'VMAP XML parsing error');
	            return;
	        }
	        var vmapNode = _helper.getSubNode(xmlDoc, 'vmap:VMAP');
	        if (!vmapNode || !vmapNode.firstChild) {
	            reportError('1000', 'VMAP node does not exist');
	            return;
	        }

	        var vmapVersion = getVMAPVersion(vmapNode);
	        if (isValidVmapVersion(vmapVersion)) {
	        	_vmapVersion = vmapVersion;
	            _vmapObj.version = vmapVersion;

	            var breaks = _helper.getSubNodes(vmapNode, 'vmap:AdBreak');
	            if (!breaks || breaks.length === 0) {
	            	reportError('900', 'no AdBreak available');
	                return;
	            }
	            
	            var i;
	            _vmapObj.adBreaks = [];
	            for (i = 0; i < breaks.length; i++) {
	            	// make sure each break has id
	            	var id = _helper.getNodeAttributeValue(breaks[i], 'breakId');
	            	if (!id) {
	                    var attr = xmlDoc.createAttribute('breakId');
	                    id = 'apn_vmap_' + i;
	                    attr.value = id;
	                    breaks[i].setAttributeNode(attr);
					}
					else {
						// make break id unique
						id = (id + '_' + i);
					}
	                var breakObj = {breakId: id, startTime: Date.now()};
	                _vmapObj.adBreaks.push(breakObj);
	            }
	            
	            for (i = 0; i < _vmapObj.adBreaks.length; i++) {
	            	processBreak(breaks[i], _vmapObj.adBreaks[i]);
	            }
	        }
	        else {
	            reportError('1001', 'VMAP version not supported');
	        }
	        addExtensions(_vmapObj, vmapNode);
	    }
	    
	    function getBreakById(id) {
	    	for (var i = 0; i < _vmapObj.adBreaks.length; i++) {
	    		if (_vmapObj.adBreaks[i].breakId === id) {
	    			return _vmapObj.adBreaks[i];
	    		}
	    	}
	    	return null;
	    }

	    function allBreaksParsed() {
	    	for (var i = 0; i < _vmapObj.adBreaks.length; i++) {
	    		if (!_vmapObj.adBreaks[i].endTime) {
	    			return false;
	    		}
	    	}
	    	return true;
	    }
	    
	    function merge2breaks(break1, break2) {
	    	// merge adSources
	    	if (break1.adSource) {
	    		if (break2.adSource) {
	    			if (!break1.adSource.customAdData && break2.adSource.customAdData) {
	    				break1.adSource.customAdData = break2.adSource.customAdData;
	    			}
	    			if (!break1.adSource.vastData && break2.adSource.vastData) {
	    				break1.adSource.vastData = break2.adSource.vastData;
	    			}
	    			else if (break1.adSource.vastData && break2.adSource.vastData) {
	    				for (var sequence in break2.adSource.vastData) {
	    					if (break1.adSource.vastData[sequence]) {
	    						break1.adSource.vastData[sequence] = break1.adSource.vastData[sequence].concat(break2.adSource.vastData[sequence]);
	    					}
	    					else {
	    						break1.adSource.vastData[sequence] = break2.adSource.vastData[sequence];
	    					}
	    				}
	    			}
	    		}
	    	}
	    	else if (break2.adSource) {
	    		break1.adSource = break2.adSource;
	    	}
	    	
	    	// merge extensions
	    	if (break1.extensions && break2.extensions) {
	    		break1.extensions = break1.extensions.concat(break2.extensions);
	    	}
	    	else if (!break1.extensions && break2.extensions) {
	    		break1.extensions = break2.extensions;
	    	}
	    	
	    	// merge trackings
	    	if (break2.trackings) {
	    		if (!break1.trackings) {
	    			break1.trackings = [];
	    		}
	    		for (var i = 0; i < break2.trackings.length; i++) {
	    			var found = false;
	    			for (var j = 0; j < break1.trackings.length; j++) {
	    				if (break2.trackings[i].event === break1.trackings[j].event) {
	    					found = true;
	    					break1.trackings[j].uris = break1.trackings[j].uris.concat(break2.trackings[i].uris);
	    					break;
	    				}
	    			}
	    			if (!found) {
	    				break1.trackings.push(break2.trackings[i]);
	    			}
	    		}
	    	}
	    }
	    
	    function mergeBreaks() {
	    	for (var i = 0; i < _vmapObj.adBreaks.length; i++) {
	    		var breakObj = _vmapObj.adBreaks[i];
	    		if (i < _vmapObj.adBreaks.length - 1) {
	    			for (var j = i + 1; j < _vmapObj.adBreaks.length;) {
	    				if (breakObj.timeOffset === _vmapObj.adBreaks[j].timeOffset) {
	    					merge2breaks(breakObj, _vmapObj.adBreaks[j]);
	    	    			_vmapObj.adBreaks.splice(j, 1);
	    				}
	    				else {
	    					j++;
	    				}
	    			}
	    		}
	    	}
	     }

	    function finishParsing() {
	    	for (var i = 0; i < _vmapObj.adBreaks.length;) {
	    		var breakObj = _vmapObj.adBreaks[i];
	    		if (!breakObj.timeOffset) {
	    			_vmapObj.adBreaks.splice(i, 1);
		            _logger.error(_prefix, 'AdBreak does not have timeOffset. Remove break object from response object.');
		            continue;
	    		}
	    		if (!breakObj.breakType) {
	    			_vmapObj.adBreaks.splice(i, 1);
		            _logger.error(_prefix, 'AdBreak does not have breakType. Remove break object from response object.');
		            continue;
	    		}
	    		var validSource = false;
	    		var validTrackings = false;
	    		if (breakObj.adSource) {
	    			validSource = true;
	    			if (!breakObj.adSource.vastData && !breakObj.adSource.customAdData) {
	    				validSource = false;
	        			delete breakObj.adSource;
			            _logger.error(_prefix, 'AdBreak does not have valid AdSource. Remove adSource object from break object.');
	    			}
	    		}
	    		if (breakObj.trackings) {
	    			validTrackings = true;
	    			if (breakObj.trackings.length === 0) {
	    				validTrackings = false;
	    				delete breakObj.trackings;
			            _logger.error(_prefix, 'AdBreak does not have valid tracking event. Remove trackings object from break object.');
	    			}
	    		}
	    		if (!validSource && !validTrackings) {
	    			_vmapObj.adBreaks.splice(i, 1);
		            _logger.error(_prefix, 'AdBreak does not have valid AdSource and tracking event. Remove break object from response object.');
	    		}
	    		else {
	    			i++;
	    		}
	    	}
	    	if (_vmapObj.adBreaks.length === 0) {
	        	reportError('900', 'No AdBreaks have been resolved');
	    	}
	    	else {
	    		mergeBreaks();
	        	_callback(true, _vmapObj, _arrErrorUrls);
	        	_callback = null;
	    	}
	    }
	    
	    function addVastDataBySequence(sequence, obj, data) {
	    	if (obj[sequence]) {
	    		obj[sequence].push(data);
	    	}
	    	else {
	    		obj[sequence] = [data];
	    	}
	    }

		function processValue(succ, id, selectedData, errorUrls) {
			var breakObj = getBreakById(id);
			if (!breakObj) {
	        	reportError('900', 'failed to found AdBreak after VAST parsing');
	        	return;
			}
	    	breakObj.endTime = Date.now();
			if (succ) {
				if (breakObj.adSource.templateType !== 'proprietary') {
					if (Array.isArray(selectedData)) {
						var i;
						for (i = 0; i < selectedData.length;) {
							if (selectedData[i].vastVersion.substr(0, 1) !== breakObj.adSource.templateType.substr(4, 1)) {
					            _logger.error(_prefix, 'VAST version ' + selectedData[i].vastVersion + ' does not match template type ' + breakObj.adSource.templateType);
					        	selectedData.splice(i, 1);
							}
							else {
								i++;
							}
						}
						if (selectedData.length > 0) {
							breakObj.adSource.vastData = {};
							for (i = 0; i < selectedData.length; i++) {
								var sequence = parseInt(selectedData[i].sequence);
								addVastDataBySequence(sequence, breakObj.adSource.vastData, selectedData[i]);
							}
						}
					}
					else {
						if (selectedData.vastVersion.substr(0, 1) !== breakObj.adSource.templateType.substr(4, 1)) {
				        	reportError('1005', 'invalid AdSource template type', breakObj.trackings, true);
						}
						else {
							breakObj.adSource.vastData = selectedData;
						}
					}
				}
				else {
					breakObj.adSource.vastData = selectedData;
				}
			}
			else {
				if (errorUrls && errorUrls.length > 0) {
					_arrErrorUrls = _arrErrorUrls.concat(errorUrls);
				}
				if (selectedData.substr(0,4) === 'vast') {
					selectedData = selectedData.substr(4);
		        	reportError(selectedData, 'VAST parsing error', breakObj.trackings, true);
				}
				else if (selectedData === 'Timeout') {
		        	reportError('1007', 'VAST parsing timeout', breakObj.trackings, true);
				}
				else {
		        	reportError('900', 'VAST parsing error', breakObj.trackings, true);
				}
			}
			
			if (_callback && allBreaksParsed()) {
				finishParsing();
			}
		}
		
	    function processBreak(breakNode, breakObj) {
	        addExtensions(breakObj, breakNode);
	        
	        var trackings = _helper.getSubNode(breakNode, 'vmap:TrackingEvents');
	    	if (trackings) {
	    		breakObj.trackings = [];
	    		addTrackings(trackings, breakObj.trackings);
	    	}
	 
	        var attr = _helper.getNodeAttributeValue(breakNode, 'timeOffset');
	        if (!attr) {
	        	breakObj.endTime = Date.now();
	        	reportError('900', 'missing timeOffset attribute in AdBreak node', breakObj.trackings, true);
	            return;
	        }
	        breakObj.timeOffset = attr;
	        
	        attr = _helper.getNodeAttributeValue(breakNode, 'breakType');
	        if (!attr) {
	        	breakObj.endTime = Date.now();
	        	reportError('1003', 'AdBreak not supported', breakObj.trackings, true);
	            return;
	        }
	        breakObj.breakType = attr;
	        
	        attr = _helper.getNodeAttributeValue(breakNode, 'repeatAfter');
	        if (attr) {
	        	breakObj.repeatAfter = attr;
	        }

	        var adSourceNode = _helper.getSubNode(breakNode, 'vmap:AdSource');
	        if (adSourceNode) {
	            var adSource = {};
	            breakObj.adSource = adSource;
	 
	            attr = _helper.getNodeAttributeValue(adSourceNode, 'id');
	            if (attr) {
	            	adSource.id = attr;
	            }
	            attr = _helper.getNodeAttributeBooleanValue(adSourceNode, 'allowMultipleAds', true);
	            if (attr) {
	            	adSource.allowMultipleAds = attr;
	            }
	            attr = _helper.getNodeAttributeValue(adSourceNode, 'followRedirects');
	            if (attr) {
	            	adSource.followRedirects = (attr === 'true');
	            }
	            
				var VastParser = __webpack_require__(26);
				var timeout = _nStopTime - Date.now();
	            var value;
	            var sourceNode = _helper.getSubNode(adSourceNode, 'vmap:VASTAdData');
	            if (sourceNode) {
	    			value = getInnerHTML(sourceNode);
	            	if (!value) {
	                	breakObj.endTime = Date.now();
	                	reportError('1004', 'empty VASTAdData for AdBreak', breakObj.trackings, true);
	                    return;
	            	}
	            	adSource.templateType = 'vast3';
	    		    VastParser.parse(value, processValue, breakObj.breakId, timeout, null, null, _options);
	            }
	            else {
	                sourceNode = _helper.getSubNode(adSourceNode, 'vmap:CustomAdData');
	                if (sourceNode) {
	                	breakObj.endTime = Date.now();
	                	value = _helper.getNodeValues(sourceNode);
	                	if (!value) {
	                    	reportError('1004', 'empty CustomAdData for AdBreak', breakObj.trackings, true);
	                        return;
	                	}
	                    attr = _helper.getNodeAttributeValue(sourceNode, 'templateType');
	                    if (!attr) {
	                    	reportError('1005', 'missing templateType attribute in CustomAdData node', breakObj.trackings, true);
	                        return;
	                    }
	                	adSource.templateType = attr;
	                	adSource.customAdData = value;
	            		if (_callback && allBreaksParsed()) {
	            			finishParsing();
	            		}
	                }
	                else {
	                    sourceNode = _helper.getSubNode(adSourceNode, 'vmap:AdTagURI');
	                    if (sourceNode) {
	                    	value = _helper.getNodeValues(sourceNode);
	                    	if (!value) {
	                        	breakObj.endTime = Date.now();
	                        	reportError('1004', 'empty AdTagURI for AdBreak', breakObj.trackings, true);
	                            return;
	                    	}
	                        attr = _helper.getNodeAttributeValue(sourceNode, 'templateType');
	                        if (!attr) {
	                        	breakObj.endTime = Date.now();
	                        	reportError('1005', 'missing templateType attribute in AdTagURI node', breakObj.trackings, true);
	                            return;
	                        }
	                    	adSource.templateType = attr;
	        			    var UrlLoader = __webpack_require__(11);
	        			    UrlLoader.load(value,
	        			        function(error, responseText) {
	        			    		if (error) {
	        			    			processValue(false, breakObj.breakId, error === 'Timeout' ? 'vast1007' : 'vast1008');
	        			    		}
	        			    		else {
	        			    			timeout = _nStopTime - Date.now();
	    				    		    VastParser.parse(responseText, processValue, breakObj.breakId, timeout, null, null, _options);
	         			    		}
	        			       }, timeout);
	                    }
	                }
	            }
	        }
	    }

	    this.parse = function (strVmapXml, callback) {
	        _callback = callback;
	        parseXML(strVmapXml);
	    };
	};

	function findBreakByTime(adBreaks, timeOffset) {
		for (var i = 0; i < adBreaks.length; i++) {
			if (adBreaks[i].timeOffset === timeOffset) {
				return adBreaks[i];
			}
		}
		return null;
	}

	function findEventObjByEventName(trackings, eventName) {
		for (var i = 0; i < trackings.length; i++) {
			if (trackings[i].event === eventName) {
				return trackings[i];
			}
		}
		return null;
	}

	function mergeVmapData(vmapData1, vmapData2) {
		if (!vmapData1) {
			return vmapData2;
		}
		if (!vmapData2) {
			return vmapData1;
		}
		
		// merge extensions
		if (vmapData2.extensions && vmapData2.extensions.length > 0) {
			if (!vmapData1.extensions) {
				vmapData1.extensions = [];
			}
			vmapData1.extensions = vmapData1.extensions.concat(vmapData2.extensions);
		}
		
		// merge breaks
		if (vmapData2.adBreaks && vmapData2.adBreaks.length > 0) {
			if (!vmapData1.adBreaks) {
				vmapData1.adBreaks = [];
				vmapData1.adBreaks = vmapData1.adBreaks.concat(vmapData2.adBreaks);
			}
			else {
				for (var i = 0; i < vmapData2.adBreaks.length; i++) {
					var adBreak1 = findBreakByTime(vmapData1.adBreaks,  vmapData2.adBreaks[i].timeOffset);
					if (!adBreak1) {
						vmapData1.adBreaks.push(vmapData2.adBreaks[i]);
					}
					else {
						// merge break extensions
						if (vmapData2.adBreaks[i].extensions && vmapData2.adBreaks[i].extensions.length > 0) {
							if (!adBreak1.extensions) {
								adBreak1.extensions = [];
							}
							adBreak1.extensions = adBreak1.extensions.concat(vmapData2.adBreaks[i].extensions);
						}
						// merge break trackings
						if (vmapData2.adBreaks[i].trackings && vmapData2.adBreaks[i].trackings.length > 0) {
							if (!adBreak1.trackings) {
								adBreak1.trackings = [];
								adBreak1.trackings = adBreak1.trackings.concat(vmapData2.adBreaks[i].trackings);
							}
							else {
								for (var j = 0; j < vmapData2.adBreaks[i].trackings.length; j++) {
									var eventData = findEventObjByEventName(adBreak1.trackings, vmapData2.adBreaks[i].trackings[j].event);
									if (!eventData) {
										adBreak1.trackings.push(vmapData2.adBreaks[i].trackings[j]);
									}
									else {
										eventData.uris = eventData.uris.concat(vmapData2.adBreaks[i].trackings[j].uris);
									}
								}
							}
						}
						// merge break ad sources
						if (vmapData2.adBreaks[i].adSource) {
							if (!adBreak1.adSource) {
								adBreak1.adSource = vmapData2.adBreaks[i].adSource;
							}
							else {
								if (vmapData2.adBreaks[i].adSource.vastData) {
									if (!adBreak1.adSource.vastData) {
										adBreak1.adSource.vastData = vmapData2.adBreaks[i].adSource.vastData;
									}
									else {
										for (var sequence in vmapData2.adBreaks[i].adSource.vastData) {
											if (adBreak1.adSource.vastData[sequence]) {
												adBreak1.adSource.vastData[sequence] = 
													adBreak1.adSource.vastData[sequence].concat(vmapData2.adBreaks[i].adSource.vastData[sequence]);
											}
											else {
												adBreak1.adSource.vastData[sequence] = vmapData2.adBreaks[i].adSource.vastData[sequence];
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return vmapData1;
	}

	module.exports = {
	    /** Describe Parser Main Entry Point Here.
	     * @param {string} strVmapXml - VMAP xml.
	     * @param {function} fnCallback - Callback function.
	     *        Callback parameters:
	     *            succ: true if success, false otherwise
	     *            data: object if success, error code otherwise
	     *            arrErrorUrl: null if success, list of error tracking url parsed from vmap xml untill parsing has failed
	     * @param {number} nMsecTimeout - VMAP processing time out in miliseconds.
	     * @param {object} options - publisher options. 
	     * 		  If adServerTimeout is present in options, VAST parser uses adServerTimeout value for loading wrapper xml and ignores nMsecTimeout.
	     */
	    parse: function (strVmapXml, fnCallback, nMsecTimeout, options) {
	        var parserObj = new VmapParser(nMsecTimeout, options);
	        parserObj.parse(strVmapXml,
	            function (succ, data, arrErrorUrls) {
	                if (fnCallback) {
	                    fnCallback(succ, data, arrErrorUrls);
	                }
	                parserObj = null;
	            });
	        return parserObj;
	    },

		/** The mergeVmapData Entry Point merges breaks data from second VMAP internal object
		 * into first VMAP internal object. This entry point used in a case when each
		 * break VMAP xml had been received by separate impbus VMAP call.
		 * @param {object} vmapData1 - first VMAP intenal object.
		 * @param {object} vmapData2 - second VMAP intenal object.
		 * @return {object} merged VMAP internal object. Usually the return value is modified vmapData1. 
		 * 					Only in a case when vmapData1 is null, the return value will be vmapData2. 
		 */
		mergeVmapData: function (vmapData1, vmapData2) {
		    return mergeVmapData(vmapData1, vmapData2);
		}

	};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var uaParser = __webpack_require__(9);
	var ua = uaParser();

	var XMLParserHelper = function () {
		function adjustNodeName(nodeName) {
			var newNodeName = nodeName;
			var browser = ua.browser.name.toLowerCase();
			if (browser === 'edge') {
				if (nodeName.indexOf('vmap:') === 0) {
					newNodeName = newNodeName.substr(5, nodeName.length - 5);
				}
			}
			return newNodeName;
		}

	    this.getSubNodes = function (node, subNodeName) {
	        var nodes = node.getElementsByTagName(adjustNodeName(subNodeName));
	        if (nodes.length > 0) {
	            return nodes;
	        }
	        return null;
	    };

	    this.getSubNode = function (node, subNodeName, index) {
	    	var setIndex = false;
	        if (!index) {
	        	setIndex = true;
	            index = 0;
	        }
	        var nodes = node.getElementsByTagName(adjustNodeName(subNodeName));
	        if (nodes.length > index) {
	        	if (!setIndex) {
	        		return nodes[index];
	        	}
	        	for (var i = 0; i < nodes.length; i++) {
	        		if (nodes[i].parentNode === node) {
	        			return nodes[i];
	        		}
	        	}
	            return nodes[0];
	        }
	        return null;
	    };

	    this.getNodeValue = function (node) {
	        if (node.childNodes.length === 0) {
	            return '';
	        }
	        var val = node.childNodes[0].nodeValue;
	        if (val) {
	            return val.trim();
	        }
	        return '';
	    };

	    this.getNodeValues = function (node) {
	        if (node.childNodes.length === 0) {
	            return '';
	        }
	        var wholeVal = '';
	        for (var i = 0; i < node.childNodes.length; i++) {
	            var val = node.childNodes[i].nodeValue;
	            if (val) {
	            	wholeVal += val;
	            }
	        }
	        return wholeVal.trim();
	    };

	    this.getNodeAttributeValue = function (node, attributeName) {
	        var val = node.getAttribute(attributeName);
	        if (val === null) {
	            val = '';
	        }
	        return val;
	    };

	    this.getNodeAttributeNumberValue = function (node, attributeName, defaultValue) {
	        if (!defaultValue) {
	            defaultValue = 0;
	        }
	        var answer = defaultValue;
	        var val = this.getNodeAttributeValue(node, attributeName);

	        if (val.length > 0) {
	            if (val.indexOf('.') >= 0) {
	                answer = parseFloat(val);
	            }
	            else {
	                answer = parseInt(val);
	            }
	        }

	        return answer;
	    };

	    this.getNodeAttributeBooleanValue = function (node, attributeName, defaultValue) {
	        if (!defaultValue) {
	            defaultValue = false;
	        }
	        var answer = defaultValue;
	        var val = this.getNodeAttributeValue(node, attributeName);

	        if (val.length > 0) {
	            var char = val.toLowerCase().charAt(0);
	            answer = (char === 't');
	        }

	        return answer;
	    };

	    this.getSubNodeValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
	        var subnode = this.getSubNode(parentNode, subNodeName);
	        if (subnode !== null) {
	            return this.getNodeValue(subnode);
	        }
	        return defaultValue;
	    };

	    this.getSubNodeWholeValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
	        var subnode = this.getSubNode(parentNode, subNodeName);
	        if (subnode !== null) {
	            return this.getNodeValues(subnode);
	        }
	        return defaultValue;
	    };

	    this.getSubNodeBooleanValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? 'false' : defaultValue;

	        var value = this.getSubNodeValue(parentNode, subNodeName);
	        if (value.length > 0 && value.toLowerCase().charAt(0) === 't') {
	            return true;
	        }
	        if (value.length > 0 && value.toLowerCase().charAt(0) === 'f') {
	            return false;
	        }
	        return defaultValue;
	    };
	};

	module.exports = XMLParserHelper;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * VAST Parser module.
	 * @module VastParser
	 */

	var VastXMLParserHelper = __webpack_require__(27);

	var APN_CompanionAds = __webpack_require__(28);
	var APN_Icons = __webpack_require__(29);

	var uaParser = __webpack_require__(9);
	var ua = uaParser();

	var VastParser = function (id, nMsecTimeout, options) {

	    var _logger = __webpack_require__(3);
	    var _prefix = 'VAST Parser';

	    var _callback = null;
	    var _options = options;
	    var _wrapperLimit = _options && _options.wrapperLimit && _options.wrapperLimit > 0 ? _options.wrapperLimit : 5;
	    var _curWrapperLevel = 0;
	    var _sourceVastXml = null;
	    var _id = id;
	    var _nTimeOut = nMsecTimeout && nMsecTimeout > 0 ? nMsecTimeout : 1000;	// 1 second default
	    var _arrMediaFiles = [],
	    	_mezzanine = null,
	    	_arrInteractiveCreatives = [],
	        _arrTrackings = {},
	        _arrImpressions = [],
	        _arrClickUrls = [],
	        _arrClickTrackings = [],
	        _arrErrorUrls = [],
	        _arrInternalErrorUrls = [],
	        _sExtensions = '',
	        _adParameters = '',
	        _nMsecDuration = 0,
	        _strSkipOffset = '';
	    
	    var _errors303 = null;
	    var _arrError303Urls = [];

	    var _arrTrackingsMerge = {},
	        _arrImpressionsMerge = [],
	        _arrClickUrlsMerge = [],
	        _arrClickTrackingsMerge = [],
	        _arrErrorUrlsMerge = [],
	    	_arrViewableImpressionsMerge = {viewable: [], notViewable: [], undetermined: []};

	    var _helper = new VastXMLParserHelper();
	    var _startTime = null;
	    var _withWrapper = false;
	    var _vastVersion = '';
	    var _conditionalAd = false;
	    var _fallbackOnNoAd;

	    var _adTree = [];
	    var _currTreeIdx = -1;

	    var _terminated = false;

	    var _capabilityDetection = __webpack_require__(10);

	    var _waterfall = false;
	    var _vastObjects = [];
	    var _topLevel = false;
	    var _notifyurls = {};
	    var _curNotifyUrl = '';
	    var _buyerMemberIds = {};
	    var _curBuyerMemberId = '';
	    var _viewabilityConfigs = {};
	    var _curViewabilityConfig = '';
	    var _creativeIds = {};
	    var _curCreativeId = '';

	    var _csmCount = 0;
	    var _rtbCount = 0;
	    
	    var _vmap = options.vmap;

	    var _finalVastUri = '';//VIDLA-2240 to keep final VAST URI

	    _logger.always(_prefix, 'Version 3.1.17');

	    function getVASTVersion(vastNode) {
	        var version = 'unknown';
	        if (vastNode) {
	            version = _helper.getNodeAttributeValue(vastNode, 'version');
	            version = version.trim();
	            if (version.length > 3) {
	                version = version.substr(0, 3);
	            }
	        }
	        return version;
	    }

	    function substituteErrorCode(arrErrorUrls, errorCode) {
	        if (arrErrorUrls && arrErrorUrls.length > 0) {
	            for (var i = 0; i < arrErrorUrls.length; i++) {
	                arrErrorUrls[i] = arrErrorUrls[i].replace('[ERRORCODE]', errorCode);
	            }
	        }
	    }

	    function traceTreePath(idx, message) {
	        var curIdx = idx;
	        var text = 'AD DETECTED=' + (message.substr(0, 7) === 'SUCCESS' ? 'SUCCESS' : 'NONE') + ' :: Reason=' + message +
	            ', playerTechnology=' + (_options.hasOwnProperty('playerTechnology') ? JSON.stringify(_options.playerTechnology) : 'unknown') +
	            ', platform=' + _capabilityDetection.getPlatformType() + ', Ad tree path=';
	        var tree = '';
	        while (curIdx !== -1) {
	            var ad = _adTree[curIdx].children[0];
	            if (ad) {
	                var val = _helper.getNodeAttributeValue(ad, 'id');
	                if (tree.length > 0) {
	                    tree = ' -> ' + tree;
	                }
	                tree = val + tree;
	            }
	            curIdx = _adTree[curIdx].parentIdx;
	        }
	        _logger.info(_prefix, text + tree);
	    }

	    function processWrapper(parentNode) {
	        var node = _helper.getSubNode(parentNode, 'VASTAdTagURI');
	        if (!node) {
	            traceTreePath(_currTreeIdx, 'INVALID WRAPPER NODE');
	            if (_adTree.length === 0) {
	                reportError('300', 'invalid wrapper node');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        var url = _helper.getNodeValues(node);
	        if (!url || url.length === 0) {
	            traceTreePath(_currTreeIdx, 'EMPTY VASTAdTagURI');
	            if (_adTree.length === 0) {
	                reportError('300', 'Invalid VASTAdTagURI node value');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }

	        if (_terminated) {
	            traceTreePath(_currTreeIdx, 'terminated');
	            _callback(false, _id, 'terminated', null, _curNotifyUrl);		// terminated
	            return;
	        }

	        _withWrapper = true;
	        
	        if (_vastVersion >= '4.0') {
	        	var val = _helper.getNodeAttributeBooleanValue(parentNode, 'followAdditionalWrappers', true);
	        	_adTree[_currTreeIdx].state.followAdditionalWrappers = val;
	        	
	        	val = _helper.getNodeAttributeBooleanValue(parentNode, 'allowMultipleAds', false);
	        	_adTree[_currTreeIdx].state.allowMultipleAds = val;
	        	
	        	val = _helper.getNodeAttributeValue(parentNode, 'fallbackOnNoAd');
	        	if (val !== '') {
	        		_fallbackOnNoAd = _helper.getNodeAttributeBooleanValue(parentNode, 'fallbackOnNoAd');
	        	}
	        }

	        //keep final URI for VIDLA-2240
	        _finalVastUri = url;

	        var UrlLoader = __webpack_require__(11);
	        UrlLoader.load(url,
	            function (error, responseText) {
	                if (_terminated) {
	                    traceTreePath(_currTreeIdx, 'terminated');
	                    _callback(false, _id, 'terminated', null, _curNotifyUrl);		// terminated
	                    return;
	                }
	                if (error || responseText.length === 0) {
	                    traceTreePath(_currTreeIdx, 'VASTAdTagURI TIMED OUT: ' + url);
	                    if (_adTree.length === 0) {
	                        reportError('301', 'Timeout of VAST URI provided in wrapper element');
	                    }
	                    else {
	                        processNextAd();
	                    }
	                }
	                else {
	                    _topLevel = false;
	                    parseXML(responseText);
	                }
	            }, _options.adServerTimeout ? _options.adServerTimeout : _nTimeOut);
	    }

	    function isInArray(arr, value) {
	        for (var i = 0; i < arr.length; i++) {
	            if (arr[i] === value) {
	                return true;
	            }
	        }
	        return false;
	    }

	    function addErrorUrls(parentNode, arrErrorUrls) {
	        if (parentNode) {
	            var nodes = _helper.getSubNodes(parentNode, 'Error');
	            if (nodes) {
	                for (var i = 0; i < nodes.length; i++) {
	                    var node = nodes[i];
	                    var url = _helper.getNodeValues(node);
	                    if (url && !isInArray(arrErrorUrls, url)) {
	                        arrErrorUrls.push(url);
	                    }
	                }
	            }
	        }
	    }

	    function addImpressions(parentNode, arrImpressions) {
	        if (parentNode) {
	            var nodes = _helper.getSubNodes(parentNode, 'Impression');
	            if (nodes) {
	                for (var i = 0; i < nodes.length; i++) {
	                    var node = nodes[i];
	                    var url = _helper.getNodeValues(node);
	                    if (url && !isInArray(arrImpressions, url)) {
	                        arrImpressions.push(url);
	                    }
	                }
	            }
	        }
	    }

	    function addTrackings(parentNode, arrTrackings) {
	        //var _nMsecDuration;
	        if (parentNode) {
	            var linear = _helper.getSubNode(parentNode, 'Linear', 0);
	            if (linear) {

	                //comment out by VIDLA-163
	                //var duration_node = _helper.getSubNode(linear, 'Duration');
	                //if (duration_node) {
	                //var str = _helper.getNodeValue(duration_node);
	                //_nMsecDuration = getMsecTime(str, -1);
	                //}


	                var node = _helper.getSubNode(linear, 'TrackingEvents');
	                if (node) {
	                    var nodes = _helper.getSubNodes(node, 'Tracking');
	                    if (nodes) {
	                        for (var i = 0; i < nodes.length; i++) {
	                            node = nodes[i];
	                            var url = _helper.getNodeValues(node);
	                            if (url) {


	                                var event = _helper.getNodeAttributeValue(node, 'event');

	                                //VIDLA-422 progress event also can be multiple in wrapper case
	                                if (event === 'progress') {
	                                    var offset = _helper.getNodeAttributeValue(node, 'offset');
	                                    if (offset) {
	                                        //event = 'progress_' + getMsecTime(offset,_nMsecDuration);
	                                        event = 'progress_' + offset;
	                                    } else {
	                                        event = '';
	                                    }
	                                }
	                                if (event) {
	                                    if (arrTrackings.hasOwnProperty(event)) {
	                                        if (!isInArray(arrTrackings[event], url)) {
	                                            arrTrackings[event].push(url);
	                                        }
	                                    }
	                                    else {
	                                        arrTrackings[event] = [];
	                                        arrTrackings[event].push(url);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }

	    function addExtensions(parentNode, treeIdx) {
	        if (parentNode) {
	            var node = _helper.getSubNode(parentNode, 'Extensions');
	            if (node && node.innerHTML && node.innerHTML.length > 0) {
	                _adTree[treeIdx].state.sExtensions = _adTree[treeIdx].state.sExtensions + node.innerHTML.toString();
	            }
	            else if (node && node.textContent && node.textContent.length > 0) {
	                _adTree[treeIdx].state.sExtensions = _adTree[treeIdx].state.sExtensions + node.textContent.toString();
	            }
	        }
	    }

	    function addCompanions(parentNode, treeIdx) {
	        if (parentNode) {
	            var node = _helper.getSubNode(parentNode, 'CompanionAds');
	            if (node &&
	                ((node.innerHTML && node.innerHTML.length > 0) ||
	                (node.textContent && node.textContent.length > 0))) {
	                APN_CompanionAds.parse(_adTree[treeIdx].state.companions, node, _helper);
	            }
	        }
	    }

	    function addIcons(parentNode, treeIdx) {
	        if (parentNode) {
	            var node = _helper.getSubNode(parentNode, 'Icons');
	            if (node &&
	                ((node.innerHTML && node.innerHTML.length > 0) ||
	                (node.textContent && node.textContent.length > 0))) {
	                APN_Icons.parse(_adTree[treeIdx].state.icons, node, _helper);
	            }
	        }
	    }

	    function addClickUrls(parentNode, arrClickUrls, arrClickTrackings) {
	        if (parentNode) {
	            var linear = _helper.getSubNode(parentNode, 'Linear', 0);
	            if (linear) {
	                var url = null;
	                var parentNode2 = _helper.getSubNode(linear, 'VideoClicks');
	                if (parentNode2) {
	                    var node = _helper.getSubNode(parentNode2, 'ClickThrough');
	                    if (node) {
	                        url = _helper.getNodeValues(node);
	                        if (url && !isInArray(arrClickUrls, url)) {
	                            arrClickUrls.push(url);
	                        }
	                    }
	                    var nodes = _helper.getSubNodes(parentNode2, 'ClickTracking');
	                    if (nodes) {
	                        for (var i = 0; i < nodes.length; i++) {
	                            node = nodes[i];
	                            url = _helper.getNodeValues(node);
	                            if (url && !isInArray(arrClickTrackings, url)) {
	                                arrClickTrackings.push(url);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }

	    function addViewableImpression(parentNode, arrViewableImpression) {
	        if (parentNode) {
	            var viewImps = _helper.getSubNode(parentNode, 'ViewableImpression', 0);
	            if (viewImps) {
	                var url = null;
	                var node = null;
	                var i;
	                var subNodes = _helper.getSubNodes(viewImps, 'Viewable');
	                if (subNodes && subNodes.length > 0) {
	                    for (i = 0; i < subNodes.length; i++) {
	                        node = subNodes[i];
	                        url = _helper.getNodeValues(node);
	                        if (url && !isInArray(arrViewableImpression.viewable, url)) {
	                        	arrViewableImpression.viewable.push(url);
	                        }
	                    }
	                }
	                subNodes = _helper.getSubNodes(viewImps, 'NotViewable');
	                if (subNodes && subNodes.length > 0) {
	                    for (i = 0; i < subNodes.length; i++) {
	                        node = subNodes[i];
	                        url = _helper.getNodeValues(node);
	                        if (url && !isInArray(arrViewableImpression.notViewable, url)) {
	                        	arrViewableImpression.notViewable.push(url);
	                        }
	                    }
	                }
	                subNodes = _helper.getSubNodes(viewImps, 'ViewUndetermined');
	                if (subNodes && subNodes.length > 0) {
	                    for (i = 0; i < subNodes.length; i++) {
	                        node = subNodes[i];
	                        url = _helper.getNodeValues(node);
	                        if (url && !isInArray(arrViewableImpression.undetermined, url)) {
	                        	arrViewableImpression.undetermined.push(url);
	                        }
	                    }
	                }
	            }
	        }
	    }

	    function getMsecTime(strTime, duration) {
	        var nPos = strTime.indexOf('%');
	        if (nPos > 0) {
	            if (duration && duration > 0) {
	                return Number(strTime.substring(0, nPos));
	            }
	            else {
	                return 0;
	            }
	        } else {
	            nPos = strTime.indexOf('.');
	            var msecs = nPos > 0 ? Number(strTime.substring(nPos + 1)) : 0;
	            if (nPos > 0) {
	                strTime = strTime.substring(0, nPos);
	            }
	            var arr = strTime.split(':');
	            if (arr.length === 3) {
	                return (Number(arr[0]) * 3600 + Number(arr[1]) * 60 + Number(arr[2])) * 1000 + msecs;
	            }
	            else {
	                return 0;
	            }
	        }
	    }

	    function isCapable(type, codec) {
	        return _capabilityDetection.canPlay(type, codec);
	    }

	    function isFlashOnlyType(type) {
	        return type === 'video/x-flv' || type === 'video/x-f4v' || type === 'video/f4v' ||
	            type === 'application/x-shockwave-flash';
	    }

	    function isHtml5OnlyType(type) {
	        return type === 'video/webm' || type === 'video/ogg' || type === 'application/javascript' ||
	            type === 'application/x-javascript';
	    }

	    function isVpaidType(type) {
	        return type === 'application/x-shockwave-flash' || type === 'application/javascript' ||
	            type === 'application/x-javascript';
	    }

	    function isOptionsValidated(type) {
	        if (_options.playerTechnology && Array.isArray(_options.playerTechnology) && _options.playerTechnology.length > 0) {
	            var supported = false;
	            for (var i = 0; i < _options.playerTechnology.length; i++) {
	                var tech = _options.playerTechnology[i].toLowerCase();
	                if (!isFlashOnlyType(type.toLowerCase()) && !isHtml5OnlyType(type.toLowerCase())) {
	                    supported = true;
	                    break;
	                }
	                if (tech === 'flash' && !isHtml5OnlyType(type.toLowerCase())) {
	                    supported = true;
	                    break;
	                }
	                if (tech === 'html5' && !isFlashOnlyType(type.toLowerCase())) {
	                    supported = true;
	                    break;
	                }
	            }
	            if (!supported) {
	                return false;
	            }
	        }
	        if (_options.hasOwnProperty('supportVpaid') && !_options.supportVpaid) {
	            if (isVpaidType(type.toLowerCase())) {
	                return false;
	            }
	        }
	        return true;
	    }

	    function configureMediaRendition(node, url, num, mediaTypes) {
	        var rendition = null;
	        if (node) {
	            rendition = {};
	            rendition.type = _helper.getNodeAttributeValue(node, 'type');
	            if (mediaTypes.indexOf(rendition.type) === -1) {
	                mediaTypes.push(rendition.type);
	            }
	            // check capability
	            if (!rendition.type || rendition.type.length === 0) {
	                return null;
	            }
	            var codec = _helper.getNodeAttributeValue(node, 'codec');
	            if (codec && codec.length > 0) {
	            	codec = codec.trim();
	            	codec = codec.length > 2 ? codec : '';	// protection against bad data such as '0'
	            	if (codec.length > 0) {
	                    rendition.codec = codec;
	            	}
	            }
	            if (!isCapable(rendition.type, codec)) {
	                return null;
	            }
	            if (_options) {
	                if (!isOptionsValidated(rendition.type)) {
	                    return null;
	                }
	            }
	            rendition.url = url;
	            rendition.variation = 'Media#' + num;
	            rendition.delivery = _helper.getNodeAttributeValue(node, 'delivery');
	            var bitrate = _helper.getNodeAttributeNumberValue(node, 'bitrate', -1);
	            if (bitrate !== -1) {
	                rendition.bitrate = bitrate;
	            }
	            rendition.width = _helper.getNodeAttributeNumberValue(node, 'width');
	            rendition.height = _helper.getNodeAttributeNumberValue(node, 'height');
	            var valNode = _helper.getNodeAttributeValue(node, 'scalable');
	            if (valNode.length > 0) {
	                rendition.scalable = _helper.getNodeAttributeBooleanValue(node, 'scalable', true);
	            }
	            valNode = _helper.getNodeAttributeValue(node, 'maintainAspectRatio');
	            if (valNode.length > 0) {
	                rendition.maintainAspectRatio = _helper.getNodeAttributeBooleanValue(node, 'maintainAspectRatio', true);
	            }
	            var apiFramework = _helper.getNodeAttributeValue(node, 'apiFramework');
	            if (apiFramework && apiFramework.length > 0) {
	                rendition.apiFramework = apiFramework.toUpperCase();
	            }
	        }

	        return rendition;
	    }

	    function addMediaFilesAndDuration(parentNode) {
	        _nMsecDuration = 0;
	        _strSkipOffset = '';
	        _adParameters = '';
	        _arrMediaFiles = [];
	    	_mezzanine = null;
	    	_arrInteractiveCreatives = [];
	        var message = '';
	        var mediaTypes = [];
	        if (parentNode) {
	            var linear = _helper.getSubNode(parentNode, 'Linear', 0);
	            if (linear) {
	                var node = _helper.getSubNode(linear, 'Duration');
	                if (node) {
	                    var str = _helper.getNodeValue(node);
	                    _nMsecDuration = getMsecTime(str, -1);
	                }
	                var strSkipOffset = _helper.getNodeAttributeValue(linear, 'skipoffset');

	                //comment out by VIDLA-163
	                //if (strSkipOffset && strSkipOffset.length > 0) {
	                //    _nSkipOffset = getMsecTime(strSkipOffset, _nMsecDuration);
	                //}
	                _strSkipOffset = strSkipOffset;

	                //_adParameters = _helper.getSubNodeValue(linear, 'AdParameters', '');
	                _adParameters = _helper.getSubNodeWholeValue(linear, 'AdParameters', '');

	                node = _helper.getSubNode(linear, 'MediaFiles');
	                if (node) {
	                	var url;
	                    var nodes = _helper.getSubNodes(node, 'MediaFile');
	                    if (nodes) {
	                        for (var i = 0; i < nodes.length; i++) {
	                            node = nodes[i];
	                            url = _helper.getNodeValues(node);

	                            if (url.length > 0) {
	                                var rendition = configureMediaRendition(node, url, i, mediaTypes);

	                                if (rendition) {
	                                    _arrMediaFiles.push(rendition);
	                                }
	                            }
	                        }
	                        if (_arrMediaFiles.length === 0) {
	                            message = 'INCOMPATIBLE MEDIA TYPE, Available = ' + JSON.stringify(mediaTypes);
	                        }
	                        else {
	                        	// for VAST 4
	                            node = _helper.getSubNode(linear, 'MediaFiles');
	                        	_mezzanine = _helper.getSubNodeWholeValue(node, 'Mezzanine', '');
	                        	var interactiveNodes = _helper.getSubNodes(node, 'InteractiveCreativeFile');
	                        	if (interactiveNodes && interactiveNodes.length > 0) {
	                        		for (var j = 0; j < interactiveNodes.length; j++) {
	                        			var interactiveCreative = interactiveNodes[j];
	                        			url = _helper.getNodeValues(interactiveCreative);
	                        			if (url) {
	                        				var type = _helper.getNodeAttributeValue(interactiveCreative, 'type');
	                        				var framework = _helper.getNodeAttributeValue(interactiveCreative, 'apiFramework');
	                        				_arrInteractiveCreatives.push({url: url, type: type, apiFramework: framework});
	                        			}
	                        		}
	                        	}
	                        }
	                    }
	                    else {
	                        message = 'MISSING MEDIA FILES';
	                    }
	                }
	                else {
	                    message = 'MISSING MEDIA FILES';
	                }
	            }
	            else {
	                message = 'INVALID VAST STRUCTURE';
	            }
	        }
	        return message;
	    }

	    function trimXml(strVastXml) {
	        var nPos = strVastXml.indexOf('<');
	        var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
	        nPos = strXml.lastIndexOf('>');
	        if (nPos !== -1) {
	            strXml = strXml.substr(0, nPos + 1);
	        }
	        return strXml.trim();
	    }

	    function isValidVastVersion(vastVersion) {
	        return vastVersion === '2.0' || vastVersion === '3.0' || vastVersion === '4.0' || vastVersion === '4.1';
	    }

	    function reportError(errCode, message) {
	        var arrErrorForInternalAndExternal = _arrErrorUrls.concat(_arrInternalErrorUrls);//merge with internal error and external error
	        substituteErrorCode(arrErrorForInternalAndExternal, errCode);
	        if (_arrError303Urls && _arrError303Urls.length > 0) {
	        	substituteErrorCode(_arrError303Urls, '303');
	        	arrErrorForInternalAndExternal = arrErrorForInternalAndExternal.concat(_arrError303Urls);
	        }
	        _logger.error(_prefix, 'Error ' + errCode + ' - ' + message);
	        _callback(false, _id, 'vast' + errCode, arrErrorForInternalAndExternal, _curNotifyUrl);
	    }

	    function processNextAd() {

	        //push error urls to global variable _arrInternalErrorUrls which has empty array as an default, it will be used for reportError() to return array of error urls to _callback
	        //the _arrInternalErrorUrls will be emptied by processAd() when exit out of siblings and if there's no internal parsing error
	        var arrStateOfNode = _adTree[_currTreeIdx].state;
	        if (arrStateOfNode && Array.isArray(arrStateOfNode.arrErrorUrls)) {
	            arrStateOfNode.arrErrorUrls.forEach(function (element) {
	                _arrInternalErrorUrls.push(element);
	            });
	        }

	        if (_currTreeIdx >= 0) {
	            _adTree[_currTreeIdx].children[0] = null;
	            _adTree[_currTreeIdx].children.splice(0, 1);
	            if (_adTree[_currTreeIdx].children.length === 0) {
	                var parentIdx = _adTree[_currTreeIdx].parentIdx;
	                _adTree.splice(_currTreeIdx, 1);
	                _currTreeIdx = parentIdx;
	                if (_currTreeIdx === -1) {
	                    if (_waterfall && _vastObjects.length > 0) {
	                        _logger.info(_prefix, 'Waterfall: Vast XML node count detected: # csm nodes: ' + _csmCount + ', # rtb nodes: ' + _rtbCount);
	                        _callback(true, _id, _vastObjects, null);
	                    }
	                    else if (_vmap && _vastObjects.length > 0) {
	                        _logger.info(_prefix, 'VMAP: Ad XML node count detected: ' + _vastObjects.length);
	                        _callback(true, _id, _vastObjects, null);
	                    }
	                    else {
	                        reportError('900', 'no Ad available');
	                    }
	                    return;
	                }
	                else {
	                    processNextAd();
	                    return;
	                }
	            }
	            _curWrapperLevel = _currTreeIdx;
	            _adTree[_currTreeIdx].state = preapareAdStateData();
	            processAd(_adTree[_currTreeIdx].children[0]);
	        }
	    }

	    function preapareAdStateData() {
	        var state = {
	            arrTrackings: {},
	            arrImpressions: [],
	            arrClickUrls: [],
	            arrClickTrackings: [],
	            arrErrorUrls: [],
	            sExtensions: '',
	            sequence: _vmap ? 0 : 1,
	            companions: {required: 'unknown', companions: []},
	            icons: [],
	            arrViewableImpressions: {viewable: [], notViewable: [], undetermined: []}
	        };
	        return state;
	    }

	    function saveNotificationUrl(adNode) {
	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (id.length > 0) {
	            var url = _helper.getNodeAttributeValue(adNode, 'notifyurl');
	            if (url && url.length > 0) {
	                _notifyurls[id] = url;
	            }
	        }
	    }

	    function saveCreativeId(adNode) {
	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (id.length > 0) {
	            var crId = _helper.getNodeAttributeValue(adNode, 'creativeId');
	            if (crId && crId.length > 0) {
	                _creativeIds[id] = crId;
	            }
	        }
	    }

	    function saveBuyerMemberId(adNode) {
	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (id.length > 0) {
	            var buyerId = _helper.getNodeAttributeValue(adNode, 'buyerMemberId');
	            if (buyerId && buyerId.length > 0) {
	                _buyerMemberIds[id] = buyerId;
	            }
	        }
	    }

	    function saveViewabilityConfig(adNode) {
	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (id.length > 0) {
	            var config = _helper.getNodeAttributeValue(adNode, 'viewabilityConfig');
	            if (config && config.length > 0) {
	                _viewabilityConfigs[id] = config;
	            }
	        }
	    }
	    
	    function saveNoAdsErrors() {
	    	if (_errors303 && _errors303.length > 0) {
	    		for (var i = 0; i < _errors303.length; i++) {
	                var node = _errors303[i];
	                var url = _helper.getNodeValues(node);
	                if (url && !isInArray(_arrError303Urls, url)) {
	                	_arrError303Urls.push(url);
	                }
	    		}
	    	}
	    }

	    function parseXML(strVastXml) {
	        _startTime = (new Date()).getTime();
	    	_arrError303Urls = [];	// make sure we keep error url for last vast

	        _sourceVastXml = strVastXml;
	        var strXml = trimXml(strVastXml);
	        if (strXml.length === 0) {
	            traceTreePath(_currTreeIdx, 'EMPTY VAST');
	            if (_adTree.length === 0) {
	                reportError('110', 'no bid response for mediation');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        var xmlDoc = null;
	        if (typeof window.DOMParser !== 'undefined') {
	            xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
	            if (xmlDoc.documentElement.nodeName === 'parsererror') {
	                try {
	                    _logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
	                }
	                catch (e) {
	                }
	                traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	                if (_adTree.length === 0) {
	                    reportError('100', 'VAST XML parsing error');
	                }
	                else {
	                    processNextAd();
	                }
	                return;
	            }
	        }
	        else if (typeof window.ActiveXObject !== 'undefined') {
	            try {
	                xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
	                xmlDoc.loadXML(strXml);
	                if (xmlDoc.parseError.errorCode !== 0) {
	                    _logger.error(_prefix, xmlDoc.parseError);
	                    traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	                    if (_adTree.length === 0) {
	                        reportError('100', xmlDoc.parseError.errorCode + ', Error reason = ' + xmlDoc.parseError.reason);
	                    }
	                    else {
	                        processNextAd();
	                    }
	                    return;
	                }
	            }
	            catch (ex) {
	                _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
	                traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	                if (_adTree.length === 0) {
	                    reportError('100', 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)');
	                }
	                else {
	                    processNextAd();
	                }
	                return;
	            }
	        }
	        else {
	            _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)');
	            traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	            if (_adTree.length === 0) {
	                reportError('100', 'Failed to get vast xml');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        if (!xmlDoc) {
	            traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
	            if (_adTree.length === 0) {
	                reportError('102', 'VAST XML parsing error');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        var vastNode = _helper.getSubNode(xmlDoc, 'VAST');
	        if (!vastNode || !vastNode.firstChild) {
	            traceTreePath(_currTreeIdx, 'EMPTY VAST');
	            if (_adTree.length === 0) {
	                reportError('110', 'no bid response for mediation');
	            }
	            else {
	                processNextAd();
	            }
	            return;
	        }
	        
	    	_errors303 = _helper.getSubNodes(vastNode, 'Error');
	 
	        var vastVersion = getVASTVersion(vastNode);
	        if (isValidVastVersion(vastVersion)) {
	            if (_topLevel) {
	                _waterfall = _helper.getNodeAttributeBooleanValue(vastNode, 'apn_waterfall');
	                if (_waterfall) {
	                    _options.waterfall = true;
	                }
	            }
	            var ads = _helper.getSubNodes(vastNode, 'Ad');
	            if (!ads || ads.length === 0) {
	            	saveNoAdsErrors();
	                traceTreePath(_currTreeIdx, 'NO AD NODE');
	                if (_adTree.length === 0) {
	                    reportError('900', 'no Ad available');
	                }
	                else {
	                    processNextAd();
	                }
	                return;
	            }
	            var children = [];
	            for (var i = 0; i < ads.length; i++) {
	            	if (_topLevel) {
	                	// make unique Ad id attribute
	            		var adIdTop = _helper.getNodeAttributeValue(ads[i], 'id');
	            		if (adIdTop) {
	            			adIdTop += ('_suffix' + i);
	            			ads[i].id = adIdTop;
	            		}
	            	}
	            	
	            	if (_vastVersion >= '4.0' && _currTreeIdx > 0) {
	            		if (!_adTree[_currTreeIdx].state.allowMultiAds) {
	            			var sequence = _helper.getNodeAttributeValue(ads[i], 'sequence');
	            			if (sequence) {
	            				continue;
	            			}
	            			if (children.length > 0) {
	            				break;
	            			}
	            		}
	            	}
	                children.push(ads[i]);
	                if (_waterfall && _topLevel) {
	                    saveNotificationUrl(ads[i]);
	                }
	                if (_topLevel) {
	                    saveBuyerMemberId(ads[i]);
	                    saveCreativeId(ads[i]);
	                    saveViewabilityConfig(ads[i]);
	                }
	            }
	            if (children.length === 0) {
	            	saveNoAdsErrors();
	                traceTreePath(_currTreeIdx, 'NO VALID AD NODES');
	                if (_adTree.length === 0) {
	                    reportError('900', 'no Ad available');
	                }
	                else {
	                    processNextAd();
	                }
	            	return;
	            }
	            var treeElem = {parentIdx: _currTreeIdx, currentIdx: 0, children: children, state: preapareAdStateData()};
	            _adTree.push(treeElem);
	            treeElem.currentIdx = _adTree.length - 1;
	            _currTreeIdx = treeElem.currentIdx;
	            processAd(_adTree[_currTreeIdx].children[0], vastVersion);
	        }
	        else {
	            traceTreePath(_currTreeIdx, 'INVALID VAST VERSION: ' + vastVersion);
	            if (_adTree.length === 0) {
	                reportError('102', 'VAST version not supported');
	            }
	            else {
	                processNextAd();
	            }
	        }
	    }

	    function mergeTrackings(idx) {
	        for (var event in _adTree[idx].state.arrTrackings) {
	            for (var i = 0; i < _adTree[idx].state.arrTrackings[event].length; i++) {
	                if (_arrTrackingsMerge.hasOwnProperty(event)) {
	                    if (!isInArray(_arrTrackingsMerge[event], _adTree[idx].state.arrTrackings[event][i])) {
	                        _arrTrackingsMerge[event].push(_adTree[idx].state.arrTrackings[event][i]);
	                    }
	                }
	                else {
	                    _arrTrackingsMerge[event] = [];
	                    _arrTrackingsMerge[event].push(_adTree[idx].state.arrTrackings[event][i]);
	                }
	            }
	        }
	        return _arrTrackingsMerge;
	    }

	    function mergeTreeTrackings(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeTrackings(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrTrackingsMerge;
	    }

	    function mergeImpressions(idx) {
	        for (var i = 0; i < _adTree[idx].state.arrImpressions.length; i++) {
	            if (!isInArray(_arrImpressionsMerge, _adTree[idx].state.arrImpressions[i])) {
	                _arrImpressionsMerge.push(_adTree[idx].state.arrImpressions[i]);
	            }
	        }
	        return _arrImpressionsMerge;
	    }

	    function mergeTreeImpressions(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeImpressions(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrImpressionsMerge;
	    }

	    function mergeClickUrls(idx) {
	        for (var i = 0; i < _adTree[idx].state.arrClickUrls.length; i++) {
	            if (!isInArray(_arrClickUrlsMerge, _adTree[idx].state.arrClickUrls[i])) {
	                _arrClickUrlsMerge.push(_adTree[idx].state.arrClickUrls[i]);
	            }
	        }
	        return _arrClickUrlsMerge;
	    }

	    function mergeTreeClickUrls(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeClickUrls(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrClickUrlsMerge;
	    }

	    function mergeClickTrackings(idx) {
	        for (var i = 0; i < _adTree[idx].state.arrClickTrackings.length; i++) {
	            if (!isInArray(_arrClickTrackingsMerge, _adTree[idx].state.arrClickTrackings[i])) {
	                _arrClickTrackingsMerge.push(_adTree[idx].state.arrClickTrackings[i]);
	            }
	        }
	        return _arrClickTrackingsMerge;
	    }

	    function mergeTreeClickTrackings(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeClickTrackings(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrClickTrackingsMerge;
	    }

	    function mergeErrorUrls(idx) {
	        for (var i = 0; i < _adTree[idx].state.arrErrorUrls.length; i++) {
	            if (!isInArray(_arrErrorUrlsMerge, _adTree[idx].state.arrErrorUrls[i])) {
	                _arrErrorUrlsMerge.push(_adTree[idx].state.arrErrorUrls[i]);
	            }
	        }
	        return _arrErrorUrlsMerge;
	    }

	    function mergeTreeErrorUrls(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeErrorUrls(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrErrorUrlsMerge;
	    }

	    function mergeExtensions(idx) {
	        if (_adTree[idx].state.sExtensions.length > 0) {
	            _sExtensions = _sExtensions + _adTree[idx].state.sExtensions;
	        }
	        return _sExtensions;
	    }

	    function mergeTreeExtensions(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	            mergeExtensions(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _sExtensions;
	    }

	    function mergeCompanions(treeIdx) {
	        var idx = treeIdx;
	        while (idx > 0) {
	            var parentIdx = _adTree[idx].parentIdx;
	            APN_CompanionAds.mergeCompanions(_adTree[parentIdx].state.companions, _adTree[idx].state.companions);
	            idx = parentIdx;
	        }
	        if (_adTree[idx].state.companions.required === 'unknown') {
	            delete _adTree[idx].state.companions.required;
	        }
	        return _adTree[idx].state.companions;
	    }

	    function mergeTreeCompanions(treeIdx) {
	        var arrCompanions = {required: 'unknown', companions: []};
	        var idx = treeIdx;
	        while (idx >= 0) {
	            APN_CompanionAds.mergeCompanions(arrCompanions, _adTree[idx].state.companions);
	            idx = _adTree[idx].parentIdx;
	        }
	        return arrCompanions;
	    }

	    function isProgramExist(arrIcons, program) {
	        for (var i = 0; i < arrIcons.length; i++) {
	            if (arrIcons[i].program.toLowerCase() === program.toLowerCase()) {
	                return true;
	            }
	        }
	        return false;
	    }

	    function removeProgram(arrIcons, program) {
	        for (var i = 0; i < arrIcons.length; i++) {
	            if (arrIcons[i].program.toLowerCase() === program.toLowerCase()) {
	                //arrIcons[i].splice(i, 1);
	                arrIcons.splice(i, 1);//one of arrIcons should be removed if it has same program for VIDLA-625
	                return;
	            }
	        }
	    }

	    function mergeIcons(treeIdx) {
	        var idx = treeIdx;
	        while (idx > 0) {
	            var parentIdx = _adTree[idx].parentIdx;
	            for (var i = 0; i < _adTree[idx].state.icons.length; i++) {
	                // avoid duplicate icons with same program (replace if exist)
	                if (isProgramExist(_adTree[parentIdx].state.icons, _adTree[idx].state.icons[i].program)) {
	                    removeProgram(_adTree[parentIdx].state.icons, _adTree[idx].state.icons[i].program);
	                }
	                _adTree[parentIdx].state.icons.push(_adTree[idx].state.icons[i]);
	            }
	            idx = parentIdx;
	        }
	        return _adTree[idx].state.icons;
	    }

	    function mergeTreeIcons(treeIdx) {
	        var arrIcons = [];
	        var idx = treeIdx;
	        while (idx >= 0) {
	            for (var i = 0; i < _adTree[idx].state.icons.length; i++) {
	                // avoid duplicate icons with same program
	                if (!isProgramExist(arrIcons, _adTree[idx].state.icons[i].program)) {
	                    arrIcons.push(_adTree[idx].state.icons[i]);
	                }
	            }
	            idx = _adTree[idx].parentIdx;
	        }
	        return arrIcons;
	    }

	    function aggregateCompanions(companionsObj) {
	        // get companions with resources and without resorces
	        var resCompanions = [];
	        var noresCompanions = [];
	        var companions = companionsObj.companions;
	        if (!companionsObj.companions) {
	            return companionsObj;
	        }
	        var companion;
	        var i, j;
	        for (i = companions.length - 1; i >= 0; i--) {
	            companion = companions[i];
	            if (companion.StaticResource || companion.IFrameResource || companion.HTMLResource) {
	                var sameSize = false;
	                for (j = 0; j < resCompanions.length; j++) {
	                    if (companion.width === resCompanions[j].width &&
	                        companion.height === resCompanions[j].height) {
	                        sameSize = true;
	                        break;
	                    }
	                }
	                if (!sameSize) {
	                    resCompanions.push(companion);
	                }
	            }
	            else {
	                noresCompanions.push(companion);
	            }
	        }

	        // aggregate companions without resorces into companions with resources
	        for (i = 0; i < noresCompanions.length; i++) {
	            for (j = 0; j < resCompanions.length; j++) {
	                if (noresCompanions[i].width === resCompanions[j].width && noresCompanions[i].height === resCompanions[j].height) {
	                    if ((noresCompanions[i].id && noresCompanions[i].id === resCompanions[j].id) || (!noresCompanions[i].id)) {
	                        // add click trackings
	                        if (noresCompanions[i].CompanionClickTracking) {
	                            if (!resCompanions[j].CompanionClickTracking) {
	                                resCompanions[j].CompanionClickTracking = [];
	                            }
	                            resCompanions[j].CompanionClickTracking = resCompanions[j].CompanionClickTracking.concat(noresCompanions[i].CompanionClickTracking);
	                        }
	                        // add view trackings
	                        if (noresCompanions[i].TrackingEvents) {
	                            if (!resCompanions[j].TrackingEvents) {
	                                resCompanions[j].TrackingEvents = [];
	                            }
	                            resCompanions[j].TrackingEvents = resCompanions[j].TrackingEvents.concat(noresCompanions[i].TrackingEvents);
	                        }
	                    }
	                }
	            }
	        }
	        var ret = {companions: resCompanions};
	        if (companionsObj.required) {
	            ret.required = companionsObj.required;
	        }
	        return ret;
	    }
	    
	    function getCategories(node) {
	    	var categories = [];
	    	var nodes = _helper.getSubNodes(node, 'Category');
	    	if (nodes && nodes.length > 0) {
	    		for (var i = 0; i < nodes.length; i++) {
	    			var val = _helper.getNodeValues(nodes[i]);
	    			if (val && val.length > 0) {
	    				// if category value is not present ignore this category node
	        			var authority = _helper.getNodeAttributeValue(nodes[i], 'authority');
	        			categories.push({category: val, authority: authority});
	    			}
	    		}
	    	}
	    	return categories.length > 0 ? categories : null;
	    }

	    function mergeViewableImpressions(idx) {
	    	var i;
	        for (i = 0; i < _adTree[idx].state.arrViewableImpressions.viewable.length; i++) {
	            if (!isInArray(_arrViewableImpressionsMerge.viewable, _adTree[idx].state.arrViewableImpressions.viewable[i])) {
	            	_arrViewableImpressionsMerge.viewable.push(_adTree[idx].state.arrViewableImpressions.viewable[i]);
	            }
	        }
	        for (i = 0; i < _adTree[idx].state.arrViewableImpressions.notViewable.length; i++) {
	            if (!isInArray(_arrViewableImpressionsMerge.notViewable, _adTree[idx].state.arrViewableImpressions.notViewable[i])) {
	            	_arrViewableImpressionsMerge.notViewable.push(_adTree[idx].state.arrViewableImpressions.notViewable[i]);
	            }
	        }
	        for (i = 0; i < _adTree[idx].state.arrViewableImpressions.undetermined.length; i++) {
	            if (!isInArray(_arrViewableImpressionsMerge.undetermined, _adTree[idx].state.arrViewableImpressions.undetermined[i])) {
	            	_arrViewableImpressionsMerge.undetermined.push(_adTree[idx].state.arrViewableImpressions.undetermined[i]);
	            }
	        }
	        return _arrViewableImpressionsMerge;
	    }

	    function mergeTreeViewableImpressions(treeIdx) {
	        var idx = treeIdx;
	        while (idx >= 0) {
	        	mergeViewableImpressions(idx);
	            idx = _adTree[idx].parentIdx;
	        }
	        return _arrViewableImpressionsMerge;
	    }
	    
	    function getUniversalAdId(node) {
	    	var creatieves = _helper.getSubNodes(node, 'Creative');
	    	if (creatieves && creatieves.length > 0) {
	    		for (var i = 0; i < creatieves.length; i++) {
	    			var linear = _helper.getSubNode(creatieves[i], 'Linear');
	    			if (linear) {
	        			var universalAdId = _helper.getSubNode(creatieves[i], 'UniversalAdId');
	        			return universalAdId;
	    			}
	    		}
	    	}
	    	return null;
	    }
	    
	    function getAdVerifications(node) {
	    	var verifications = [];
	    	var adVer = _helper.getSubNode(node, 'AdVerifications');
	    	if (adVer) {
	    		var nodes = _helper.getSubNodes(adVer, 'Verification');
	    		if (nodes && nodes.length > 0) {
	    			for (var i = 0; i < nodes.length; i++) {
	    				var verification = nodes[i];
	    				var vendor = _helper.getNodeAttributeValue(verification, 'vendor');
	    				var jsResources = [];
	    				var flashResources = [];
	    				var val;
	    				var attr;
	    				var j;
	    				var resources = _helper.getSubNodes(verification, 'JavaScriptResource');
	    				if (resources && resources.length > 0) {
	    					for (j = 0; j < resources.length; j++) {
	    						val = _helper.getNodeValues(resources[j]);
	    						var attrFr = _helper.getNodeAttributeValue(resources[j], 'apiFramework');
	    						var attrBr = _helper.getNodeAttributeBooleanValue(resources[j], 'browserOptional');
	    						jsResources.push({url: val, framework: attrFr, browserOptional: attrBr});
	    					}
	    				}
	    				resources = _helper.getSubNodes(verification, 'FlashResource');
	    				if (resources && resources.length > 0) {
	    					for (j = 0; j < resources.length; j++) {
	    						val = _helper.getNodeValues(resources[j]);
	    						attr = _helper.getNodeAttributeValue(resources[j], 'apiFramework');
	    						flashResources.push({url: val, framework: attr});
	    					}
	    				}
	                    var viewableImpression = _helper.getSubNodeWholeValue(verification, 'ViewableImpression');
	                    var trackingEvents = {};
	                    var hasTrackings = false;
	    				var trEvents = _helper.getSubNode(verification, 'TrackingEvents');
	    				if (trEvents) {
	                        var trackings = _helper.getSubNodes(trEvents, 'Tracking');
	                        if (trackings && trackings.length > 0) {
	                            for (j = 0; j < trackings.length; j++) {
	                                val = _helper.getNodeValues(trackings[j]);
	                                var event = _helper.getNodeAttributeValue(trackings[j], 'event');
	                                if (event && val) {
	                                    hasTrackings = true;
	                                    if (trackingEvents.hasOwnProperty(event)) {
	                                        trackingEvents[event].push(val);
	                                    }
	                                    else {
	                                        trackingEvents[event] = [val];
	                                    }
	                                }
	                            }                              
	                        }
	    				}
	                    var verificationParameters = _helper.getSubNodeWholeValue(verification, 'VerificationParameters');
	    				var verData = {};
	    				if (vendor) {
	    					verData.vendor = vendor;
	    				}
	    				if (jsResources.length > 0) {
	    					verData.jsResources = jsResources;
	    				}
	    				if (flashResources.length > 0) {
	    					verData.flashResources = flashResources;
	    				}
	    				if (viewableImpression) {
	    					verData.viewableImpression = viewableImpression;
	                    }
	                    if (hasTrackings) {
	                        verData.trackingEvents = trackingEvents;
	                    }
	                    if (verificationParameters) {
	                        verData.verificationParameters = verificationParameters;
	                    }
	    				verifications.push(verData);
	    			}
	    		}
	    	}
	    	
	    	return verifications.length > 0 ? verifications : null;
	    }
	    
	    function normalizeAdId(id) {
	    	var retId = id;
	    	var idx = retId.indexOf('_suffix');
	    	if (idx > 0) {
	    		retId = retId.substring(0, idx);
	    	}
	    	return retId;
	    }

	    function processAd(adNode, vastVersion) {
	        var inLineWrapperNode = _helper.getSubNode(adNode, 'Wrapper');
	        var isWrapper = inLineWrapperNode !== null;
	        if (!isWrapper) {
	            inLineWrapperNode = _helper.getSubNode(adNode, 'InLine');
	        }
	        
	        if (!inLineWrapperNode) {
	        	saveNoAdsErrors();
	            traceTreePath(_currTreeIdx, 'MISSING WRAPPER / INLINE NODE');
	            processNextAd();
	            return;
	        }

	        _curWrapperLevel++;
	        // wrapper limit is number of Wrapper nodes + InLine node
	        if (_curWrapperLevel > _wrapperLimit) {
	            traceTreePath(_currTreeIdx, 'Reach Wrapper limit');
	            processNextAd();
	            return;
	        }

	        if (vastVersion > _vastVersion) {
	            _vastVersion = vastVersion;
	        }

	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (_notifyurls.hasOwnProperty(id)) {
	            _curNotifyUrl = _notifyurls[id];
	        }
	        if (_creativeIds.hasOwnProperty(id)) {
	            _curCreativeId = _creativeIds[id];
	        }
	        if (_buyerMemberIds.hasOwnProperty(id)) {
	            _curBuyerMemberId = _buyerMemberIds[id];
	        }
	        if (_viewabilityConfigs.hasOwnProperty(id)) {
	            _curViewabilityConfig = _viewabilityConfigs[id];
	        }
	        // worried only about top level ad sequence attribute
	        if (_currTreeIdx === 0) {
	            var seq = _helper.getNodeAttributeValue(adNode, 'sequence');
	            if (seq) {
	                _adTree[_currTreeIdx].state.sequence = parseInt(seq);
	            }
	            var conditional = _helper.getNodeAttributeValue(adNode, 'conditionalAd');
	            if (conditional) {
	            	_conditionalAd = _helper.getNodeAttributeBooleanValue(adNode, 'conditionalAd');
	            }
	        }

	        addErrorUrls(inLineWrapperNode, _adTree[_currTreeIdx].state.arrErrorUrls);
	        addImpressions(inLineWrapperNode, _adTree[_currTreeIdx].state.arrImpressions);
	        addTrackings(inLineWrapperNode, _adTree[_currTreeIdx].state.arrTrackings);
	        addClickUrls(inLineWrapperNode, _adTree[_currTreeIdx].state.arrClickUrls, _adTree[_currTreeIdx].state.arrClickTrackings);
	        addExtensions(inLineWrapperNode, _currTreeIdx);
	        addCompanions(inLineWrapperNode, _currTreeIdx);
	        addIcons(inLineWrapperNode, _currTreeIdx);
	        addViewableImpression(inLineWrapperNode, _adTree[_currTreeIdx].state.arrViewableImpressions);

	        _arrInternalErrorUrls = [];//clear _arrInternalErrorUrls at this time, all same sibiling's error will be gathered by processNextAd()

	        if (isWrapper) {
	        	if (_vastVersion >= '4.0' && _currTreeIdx > 0) {
	        		if (!_adTree[_currTreeIdx - 1].state.followAdditionalWrappers) {
	                    traceTreePath(_currTreeIdx, 'Additional Wrappers are not allowed');
	                    processNextAd();
	                    return;
	        		}
	        	}
	            processWrapper(inLineWrapperNode);
	        }
	        else {
	            var message = addMediaFilesAndDuration(inLineWrapperNode);
	            if (_arrMediaFiles.length === 0 || message.length > 0) {
	                traceTreePath(_currTreeIdx, message);
	                processNextAd();
	                return;
	            }
	            _arrTrackingsMerge = JSON.parse(JSON.stringify(_arrTrackings));
	            _arrImpressionsMerge = _arrImpressions.slice(0);
	            _arrClickUrlsMerge = _arrClickUrls.slice(0);
	            _arrClickTrackingsMerge = _arrClickTrackings.slice(0);
	            _arrErrorUrlsMerge = _arrErrorUrls.slice(0);
	            _sExtensions = '';

	            var strTrackingUrls = JSON.stringify(mergeTreeTrackings(_adTree[_currTreeIdx].parentIdx));
	            var strImpressionUrls = JSON.stringify(mergeTreeImpressions(_adTree[_currTreeIdx].parentIdx));
	            var strClickUrls = JSON.stringify(mergeTreeClickUrls(_adTree[_currTreeIdx].parentIdx));
	            var strClickTrackingUrls = JSON.stringify(mergeTreeClickTrackings(_adTree[_currTreeIdx].parentIdx));
	            var strErrorUrls = JSON.stringify(mergeTreeErrorUrls(_adTree[_currTreeIdx].parentIdx));
	            var strExtensions = mergeTreeExtensions(_adTree[_currTreeIdx].parentIdx);
	            var strCompanions = JSON.stringify(mergeTreeCompanions(_adTree[_currTreeIdx].parentIdx));
	            var strIcons = JSON.stringify(mergeTreeIcons(_adTree[_currTreeIdx].parentIdx));
	            _sExtensions = '';
	            var companions = mergeCompanions(_currTreeIdx);
	            companions = aggregateCompanions(companions);
	            var vastObj = {
	                vastVersion: _vastVersion,
	                withWrapper: _withWrapper,
	                mediaFiles: _arrMediaFiles,
	                trackingUrls: mergeTrackings(_currTreeIdx),
	                impressionUrls: mergeImpressions(_currTreeIdx),
	                clickUrls: mergeClickUrls(_currTreeIdx),
	                clickTrackingUrls: mergeClickTrackings(_currTreeIdx),
	                errorUrls: mergeErrorUrls(_currTreeIdx),
	                durationMsecs: _nMsecDuration,
	                skipOffset: _strSkipOffset,
	                extensions: mergeExtensions(_currTreeIdx),
	                adParameters: _adParameters,
	                vastXml: _sourceVastXml,			// inline vast xml
	                extTrackingUrls: strTrackingUrls,
	                extImpressionUrls: strImpressionUrls,
	                extClickUrls: strClickUrls,
	                extClickTrackingUrls: strClickTrackingUrls,
	                extErrorUrls: strErrorUrls,
	                extExtensions: strExtensions,
	                adId: normalizeAdId(id),
	                sequence: _adTree[0].state.sequence,
	                companionAds: companions,
	                extCompanions: strCompanions,
	                icons: mergeIcons(_currTreeIdx),
	                extIcons: strIcons,
	                finalVastUri: _finalVastUri //VIDLA-2240
	            };
	            
	            // vast 4 data
	            if (_vastVersion.substr(0, 1) > '3') {
	        		var universalAdId = getUniversalAdId(inLineWrapperNode);
	        		if (universalAdId) {
	                    var idRegistry = _helper.getNodeAttributeValue(universalAdId, 'idRegistry');
	                    var idValue = _helper.getNodeAttributeValue(universalAdId, 'idValue');
	                    if (idRegistry.length === 0 || idValue.length === 0) {
	                        traceTreePath(_currTreeIdx, 'universalAdId is invalid');
	                        processNextAd();
	                        return;
	                    }
	                    vastObj.universalAdId = {idRegistry: idRegistry, idValue: idValue};
	                }
	        		
	            	vastObj.conditionalAd = _conditionalAd;
	            	var categories = getCategories(inLineWrapperNode);
	            	if (categories) {
	            		for (var j = 0; j < categories.length; j++) {
	            			if (!categories[j].category || !categories[j].authority) {
	                            traceTreePath(_currTreeIdx, 'invalid Category node');
	                            processNextAd();
	                            return;
	            			}
	            		}
	                	vastObj.categories = categories;
	            	}
	            	
	                var strViewableImpressions = JSON.stringify(mergeTreeViewableImpressions(_adTree[_currTreeIdx].parentIdx));
	            	var viewImpressions = mergeViewableImpressions(_currTreeIdx);
	            	// use only not empty (with not empty arrays) viewImpressions object
	            	if (viewImpressions && 
	            		(viewImpressions.viewable.length + viewImpressions.notViewable.length + viewImpressions.undetermined.length) > 0) {
	                	vastObj.extViewableImpression = strViewableImpressions;
	                	vastObj.viewableImpression = viewImpressions;
	            	}
	            	
	            	var adVerifications = getAdVerifications(inLineWrapperNode);
	        		if (adVerifications && adVerifications.length > 0) {
	                	vastObj.adVerifications = adVerifications;
	        		}
	        		
	        		if (_mezzanine) {
	        			vastObj.mezzanine = _mezzanine;
	        		}
	        		if (_arrInteractiveCreatives && _arrInteractiveCreatives.length > 0) {
	        			vastObj.interactiveCreativeFiles = _arrInteractiveCreatives;
	        		}
	        		
	        		if (_fallbackOnNoAd !== undefined) {
	        			vastObj.fallbackOnNoAd = _fallbackOnNoAd;
	        		}
	            }
	            
	            if (_waterfall && _curNotifyUrl.length > 0) {
	                vastObj.notifyurl = _curNotifyUrl;
	            }
	            if (_curCreativeId.length > 0) {
	                vastObj.creative_id = _curCreativeId;
	            }
	            if (_curBuyerMemberId.length > 0) {
	                vastObj.buyerMemberId = _curBuyerMemberId;
	            }
	            if (_curViewabilityConfig.length > 0) {
	                vastObj.viewabilityConfig = _curViewabilityConfig;
	            }
	            // becaurse waterfall xml always unwrapped, we can set rtb flag base on current ad node
	            var rtb = false;
	            if (_waterfall) {
	                var rtbAttr = _helper.getNodeAttributeValue(adNode, 'rtb');
	                if (rtbAttr && rtbAttr === 'true') {
	                    rtb = true;
	                    vastObj.rtb = true;
	                }
	            }
	            if (_terminated) {
	                traceTreePath(_currTreeIdx, 'terminated');
	                _callback(false, _id, 'terminated', null, _curNotifyUrl);		// terminated
	                return;
	            }
	            var mediaTypes = [];
	            for (var i = 0; i < _arrMediaFiles.length; i++) {
	                if (mediaTypes.indexOf(_arrMediaFiles[i].type) === -1) {
	                    mediaTypes.push(_arrMediaFiles[i].type);
	                }
	            }
	            traceTreePath(_currTreeIdx, 'SUCCESS, Available=' + JSON.stringify(mediaTypes));
	            if (_waterfall) {
	                _vastObjects.push(vastObj);
	                if (rtb) {
	                    _rtbCount++;
	                }
	                else {
	                    _csmCount++;
	                }
	                processNextAd();
	            }
	            else if (_vmap) {
	            	vastObj.vastXml = getXmlForSequence(vastObj.vastXml, vastObj.sequence);
	            	_vastObjects.push(vastObj);
	                processNextAd();
	            }
	            else {
	                _callback(true, _id, vastObj, null);
	            }
	        }
	    }
	    
	    function getXmlForSequence(xml, sequence) {
	        var xmlDoc = (new DOMParser()).parseFromString(xml, 'text/xml');
	        var vastNode = _helper.getSubNode(xmlDoc, 'VAST');
	        var adNodes = _helper.getSubNodes(vastNode, 'Ad');
	        for (var i = 0; i < adNodes.length;) {
	        	var adSequence = _helper.getNodeAttributeValue(adNodes[i], 'sequence');
	        	if (adSequence && parseInt(adSequence) !== sequence) {
	        		// delete ad with different sequence attribute
	        		vastNode.removeChild(adNodes[i]);
	        	}
	        	else {
	        		i++;
	        	}
	        }
	    	var browser = ua.browser.name.toLowerCase();    
	        var xmlOut;
	        if (browser === 'ie') {
	        	xmlOut = (new XMLSerializer()).serializeToString(xmlDoc.childNodes[0]);
	        }
	        else {
	            xmlOut = xmlDoc.childNodes[0].outerHTML; 
	        }
	        return xmlOut;
	    }

	    function prepareExternalTrackers(videoTrackers, impTracker) {

	        var url;
	        var i;
	        var arr;
	        var name;
	        if (impTracker) {
	            _arrImpressions.push(impTracker.trim());
	        }
	        if (videoTrackers) {
	            if (Array.isArray(videoTrackers) && videoTrackers.length === 1) {
	                // new format
	                var trackers = videoTrackers[0];
	                if (trackers.impression_urls) {
	                    for (i = 0; i < trackers.impression_urls.length; i++) {
	                        url = trackers.impression_urls[i].trim();
	                        _arrImpressions.push(url);
	                    }
	                }
	                if (trackers.error_urls) {
	                    for (i = 0; i < trackers.error_urls.length; i++) {
	                        url = trackers.error_urls[i].trim();
	                        _arrErrorUrls.push(url);
	                    }
	                }
	                if (trackers.video_click_urls) {
	                    for (i = 0; i < trackers.video_click_urls.length; i++) {
	                        url = trackers.video_click_urls[i].trim();
	                        _arrClickTrackings.push(url);
	                    }
	                }
	                for (name in trackers.video_events) {
	                    arr = trackers.video_events[name];
	                    for (i = 0; i < arr.length; i++) {
	                        url = arr[i].trim();
	                        if (_arrTrackings.hasOwnProperty(name)) {
	                            if (!isInArray(_arrTrackings[name], url)) {
	                                _arrTrackings[name].push(url);
	                            }
	                        }
	                        else {
	                            _arrTrackings[name] = [url];
	                        }
	                    }
	                }
	            }
	            else {
	                for (name in videoTrackers) {
	                    if (name === 'service') {	// ignore not vast related trackers
	                        continue;
	                    }
	                    if (Array.isArray(videoTrackers[name])) {
	                        arr = videoTrackers[name];
	                        for (i = 0; i < arr.length; i++) {
	                            url = arr[i].trim();
	                            if (name === 'click') {
	                                _arrClickTrackings.push(url);
	                            }
	                            else if (name === 'error') {
	                                _arrErrorUrls.push(url);
	                            }
	                            else if (name === 'impression') {
	                                _arrImpressions.push(url);
	                            }
	                            else {
	                                if (_arrTrackings.hasOwnProperty(name)) {
	                                    if (!isInArray(_arrTrackings[name], url)) {
	                                        _arrTrackings[name].push(url);
	                                    }
	                                }
	                                else {
	                                    _arrTrackings[name] = [url];
	                                }
	                            }
	                        }
	                    }
	                    else {
	                        url = videoTrackers[name].trim();
	                        if (name === 'click') {
	                            _arrClickTrackings.push(url);
	                        }
	                        else if (name === 'error') {
	                            _arrErrorUrls.push(url);
	                        }
	                        else if (name === 'impression') {
	                            _arrImpressions.push(url);
	                        }
	                        else {
	                            if (_arrTrackings.hasOwnProperty(name)) {
	                                if (!isInArray(_arrTrackings[name], url)) {
	                                    _arrTrackings[name].push(url);
	                                }
	                            }
	                            else {
	                                _arrTrackings[name] = [url];
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }

	    this.parse = function (strVastXml, videoTrackers, impTracker, callback) {
	        _callback = callback;
	        prepareExternalTrackers(videoTrackers, impTracker);
	        _topLevel = true;
	        parseXML(strVastXml);
	    };

	    this.terminate = function () {
	        _terminated = true;
	    };
	};

	var VastModifier = __webpack_require__(30);

	var VastMerger = __webpack_require__(31);

	module.exports = {
	    /** Describe Parser Main Entry Point Here.
	     * @param {string} strVastXml - VAST xml.
	     * @param {function} fnCallback - Callback function.
	     *        Callback parameters:
	     *            succ: true if success, false otherwise
	     *            sourceId: mediation element identificator
	     *            data: object is success, error code otherwise
	     *            arrErrorUrl: null if success, list of tracking url parsed from vast xml untill parsing has failed
	     * @param {object} id - mediation element identificator.
	     * @param {number} nMsecTimeout - time out in miliseconds for loading wrapper xml.
	     * @param {object} videoTrackers - video_trackings field from impbus request.
	     * @param {string} videoTrackers - imp_tracking_url field from impbus request.
	     * @param {object} options - publisher options.
	     * 		  If adServerTimeout is present in options, VAST parser uses adServerTimeout value for loading wrapper xml instead of nMsecTimeout.
	     */
	    parse: function (strVastXml, fnCallback, id, nMsecTimeout, videoTrackers, impTracker, options) {
	        var parserObj = new VastParser(id, nMsecTimeout, options);
	        parserObj.parse(strVastXml, videoTrackers, impTracker,
	            function (succ, sourceId, data, arrErrorUrls, notifUrl) {
	                if (fnCallback) {
	                    fnCallback(succ, sourceId, data, arrErrorUrls, notifUrl);
	                }
	                parserObj = null;
	            });
	        return parserObj;
	    },

	    /** Describe Vast Unwrapping Entry Point Here.
	     * @param {object} parserData - object returned after successful parsing.
	     * @param {string} adToken - optional ad identificator used for debug mode
	     * @return {string} - unwrapped VAST xml.
	     */
	    getUnwrappedVastTag: function (parserData, adToken, notifyUrl, contentSource, buyerMemberId, viewabilityConfig, additionalTrackers, creativeId) {
	        if (!parserData || !parserData.vastXml) {
	            return null;
	        }
	        var obj = new VastModifier(parserData, adToken, notifyUrl, contentSource, buyerMemberId, viewabilityConfig, additionalTrackers, creativeId);
	        var xml = obj.addTrackers();
	        obj = null;
	        return xml;
	    },

	    /** Describe Vast Merging VAST XMLs Entry Point Here.
	     * @param {object} xmlListData - object containes XMLs and additional data:
	     *                    xml: VAST XML
	     *                    notifyUrl: notification url from impbus response
	     *                    buyerMemberId: buyer member idenfificator from impbus response
	     * @return {string} - merged VAST xml.
	     */
	    getMergedVastTag: function (xmlList) {
	        if (!xmlList || xmlList.length === 0) {
	            return null;
	        }
	        var obj = new VastMerger(xmlList);
	        var xml = obj.getVastXml();
	        obj = null;
	        return xml;
	    }
	};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

	var XMLParserHelper = function () {
	    this.getSubNodes = function (node, subNodeName) {
	        var nodes = node.getElementsByTagName(subNodeName);
	        if (nodes.length > 0) {
	            return nodes;
	        }
	        return null;
	    };

	    this.getSubNode = function (node, subNodeName, index) {
	        if (!index) {
	            index = 0;
	        }
	        var nodes = node.getElementsByTagName(subNodeName);
	        if (nodes.length > index) {
	            return nodes[index];
	        }
	        return null;
	    };

	    this.getNodeValue = function (node) {
	        if (node.childNodes.length === 0) {
	            return '';
	        }
	        var val = node.childNodes[0].nodeValue;
	        if (val) {
	            return val.trim();
	        }
	        return '';
	    };

	    this.getNodeValues = function (node) {
	        if (node.childNodes.length === 0) {
	            return '';
	        }
	        var wholeVal = '';
	        for (var i = 0; i < node.childNodes.length; i++) {
	            var val = node.childNodes[i].nodeValue;
	            if (val) {
	            	wholeVal += val;
	            }
	        }
	        return wholeVal.trim();
	    };

	    this.getNodeAttributeValue = function (node, attributeName) {
	        var val = node.getAttribute(attributeName);
	        if (val === null) {
	            val = '';
	        }
	        return val;
	    };

	    this.getNodeAttributeNumberValue = function (node, attributeName, defaultValue) {
	        if (!defaultValue) {
	            defaultValue = 0;
	        }
	        var answer = defaultValue;
	        var val = this.getNodeAttributeValue(node, attributeName);

	        if (val.length > 0) {
	            if (val.indexOf('.') >= 0) {
	                answer = parseFloat(val);
	            }
	            else {
	                answer = parseInt(val);
	            }
	        }

	        return answer;
	    };

	    this.getNodeAttributeBooleanValue = function (node, attributeName, defaultValue) {
	        if (!defaultValue) {
	            defaultValue = false;
	        }
	        var answer = defaultValue;
	        var val = this.getNodeAttributeValue(node, attributeName);

	        if (val.length > 0) {
	            var char = val.toLowerCase().charAt(0);
	            answer = (char === 't');
	        }

	        return answer;
	    };

	    this.getSubNodeValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
	        var subnode = this.getSubNode(parentNode, subNodeName);
	        if (subnode !== null) {
	            return this.getNodeValue(subnode);
	        }
	        return defaultValue;
	    };

	    this.getSubNodeWholeValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
	        var subnode = this.getSubNode(parentNode, subNodeName);
	        if (subnode !== null) {
	            return this.getNodeValues(subnode);
	        }
	        return defaultValue;
	    };

	    this.getSubNodeBooleanValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? 'false' : defaultValue;

	        var value = this.getSubNodeValue(parentNode, subNodeName);
	        if (value.length > 0 && value.toLowerCase().charAt(0) === 't') {
	            return true;
	        }
	        if (value.length > 0 && value.toLowerCase().charAt(0) === 'f') {
	            return false;
	        }
	        return defaultValue;
	    };
	};

	module.exports = XMLParserHelper;


/***/ }),
/* 28 */
/***/ (function(module, exports) {

	var CompanionAds = {

	    parse: function (companionAdsDest, companionAdsNode, helper) {
	        var req = helper.getNodeAttributeValue(companionAdsNode, 'required');
	        if (req && req.length > 0) {
	            companionAdsDest.required = req;
	        }

	        var nodes = helper.getSubNodes(companionAdsNode, 'Companion');
	        if (nodes) {
	            for (var i = 0; i < nodes.length; i++) {
	                var node = nodes[i];
	                //var companion = JSON.parse(JSON.stringify(APN_Companion));
	                var companion = {};

	                // required attributes
	                var width = helper.getNodeAttributeNumberValue(node, 'width', -1);
	                var height = helper.getNodeAttributeNumberValue(node, 'height', -1);
	                if (width <= 0 || height <= 0) {
	                    continue;
	                }
	                companion.width = width;
	                companion.height = height;

	                // optional attributes and subnodes
	                var val = helper.getNodeAttributeValue(node, 'id');
	                if (val) {
	                    companion.id = val;
	                }

	                val = helper.getNodeAttributeNumberValue(node, 'assetWidth', -1);
	                if (val > 0) {
	                    companion.assetWidth = val;
	                }

	                val = helper.getNodeAttributeNumberValue(node, 'assetHeight', -1);
	                if (val > 0) {
	                    companion.assetHeight = val;
	                }

	                val = helper.getNodeAttributeNumberValue(node, 'expandedWidth', -1);
	                if (val > 0) {
	                    companion.expandedWidth = val;
	                }

	                val = helper.getNodeAttributeNumberValue(node, 'expandedHeight', -1);
	                if (val > 0) {
	                    companion.expandedHeight = val;
	                }

	                val = helper.getNodeAttributeValue(node, 'apiFramework');
	                if (val) {
	                    companion.apiFramework = val;
	                }

	                val = helper.getNodeAttributeValue(node, 'adSlotID');
	                if (val) {
	                    companion.adSlotID = val;
	                }

	                var pxratio = helper.getNodeAttributeNumberValue(node, 'pxratio', 1.0);
	                if (pxratio !== 1.0) {
	                	companion.pxratio = pxratio;
	                }
	                
	                val = helper.getNodeAttributeValue(node, 'required');
	                if (val) {
	                    companion.required = val;
	                }

	                val = helper.getSubNodeValue(node, 'AltText');
	                if (val) {
	                    companion.AltText = val;
	                }

	                val = helper.getSubNodeValue(node, 'AdParameters');
	                if (val) {
	                    companion.AdParameters = val;
	                }

	                var resource = helper.getSubNode(node, 'StaticResource');
	                if (resource) {
	                    val = helper.getNodeAttributeValue(resource, 'creativeType');
	                    if (val) {
	                        // validate capability
	                        var flashOnlyType = val === 'video/x-flv' || val === 'video/x-f4v' || val === 'video/f4v' || val === 'application/x-shockwave-flash';
	                        var isMobile = false;
	                        if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
	                            isMobile = true;
	                        }
	                        if (isMobile && flashOnlyType) {
	                            // ignore this companion
	                            continue;
	                        }

	                        var staticResource = {type: val};
	                        val = helper.getNodeValues(resource);
	                        if (val) {
	                            staticResource.src = val;
	                            companion.StaticResource = staticResource;
	                        }
	                    }
	                }

	                val = helper.getSubNodeWholeValue(node, 'IFrameResource');
	                if (val) {
	                    companion.IFrameResource = val;
	                }

	                val = helper.getSubNodeWholeValue(node, 'HTMLResource');
	                if (val) {
	                    companion.HTMLResource = val;
	                }

	                val = helper.getSubNodeValue(node, 'CompanionClickThrough');
	                if (val) {
	                    companion.CompanionClickThrough = val;
	                }

	                var j;
	                var trackingNode;
	                var url;
	                var clickTrackinEvents = helper.getSubNodes(node, 'CompanionClickTracking');
	                if (clickTrackinEvents) {
	                    companion.CompanionClickTracking = [];
	                    for (j = 0; j < clickTrackinEvents.length; j++) {
	                        trackingNode = clickTrackinEvents[j];
	                        url = helper.getNodeValues(trackingNode);
	                        if (url) {
	                            companion.CompanionClickTracking.push(url);
	                        }
	                    }
	                }

	                var trackinEvents = helper.getSubNodes(node, 'Tracking');
	                if (trackinEvents) {
	                    companion.TrackingEvents = [];
	                    for (j = 0; j < trackinEvents.length; j++) {
	                        trackingNode = trackinEvents[j];
	                        var event = helper.getNodeAttributeValue(trackingNode, 'event');
	                        url = helper.getNodeValues(trackingNode);
	                        if (event && url) {
	                            companion.TrackingEvents.push({eventType: event, url: url});
	                        }
	                    }
	                }

	                companionAdsDest.companions.push(companion);
	            }
	        }
	    },

	    mergeCompanions: function (companionAdsDest, companionAds) {
	        if (companionAdsDest.required === 'unknown') {
	            companionAdsDest.required = companionAds.required;
	        }
	        companionAdsDest.companions = companionAdsDest.companions.concat(companionAds.companions);
	    },

	    createCompanionNode: function (xmlDoc, data) {
	        var companion = xmlDoc.createElement('Companion');
	        var i;
	        var elem;
	        var attr;
	        var cdata;

	        var arrAttrs = ['id', 'width', 'height', 'assetWidth', 'assetHeight', 'expandedWidth', 'expandedHeight',
	            'apiFramework', 'adSlotID', 'required'];
	        for (i = 0; i < arrAttrs.length; i++) {
	            if (data.hasOwnProperty(arrAttrs[i])) {
	                attr = xmlDoc.createAttribute(arrAttrs[i]);
	                attr.value = data[arrAttrs[i]];
	                companion.setAttributeNode(attr);
	            }
	        }

	        if (data.hasOwnProperty('StaticResource')) {
	            elem = xmlDoc.createElement('StaticResource');
	            attr = xmlDoc.createAttribute('creativeType');
	            attr.value = data.StaticResource.type;
	            elem.setAttributeNode(attr);
	            cdata = xmlDoc.createCDATASection(data.StaticResource.src);
	            elem.appendChild(cdata);
	            companion.appendChild(elem);
	        }

	        var arrNodes = ['AdParameters', 'IFrameResource', 'HTMLResource', 'CompanionClickThrough'];
	        for (i = 0; i < arrNodes.length; i++) {
	            if (data.hasOwnProperty(arrNodes[i])) {
	                elem = xmlDoc.createElement(arrNodes[i]);
	                cdata = xmlDoc.createCDATASection(data[arrNodes[i]]);
	                elem.appendChild(cdata);
	                companion.appendChild(elem);
	            }
	        }

	        if (data.hasOwnProperty('AltText')) {
	            elem = xmlDoc.createElement('AltText');
	            try {
	                elem.innerHTML = data.AltText;
	            }
	            catch (ex) {
	                // IE 11 does not allow set innerHTML property
	                try {
	                    elem.textContent = data.AltText;
	                }
	                catch (ex2) {

	                }
	            }
	            companion.appendChild(elem);
	        }

	        if (data.hasOwnProperty('CompanionClickTracking')) {
	            for (i = 0; i < data.CompanionClickTracking.length; i++) {
	                var tracking = xmlDoc.createElement('CompanionClickTracking');
	                cdata = xmlDoc.createCDATASection(data.CompanionClickTracking[i]);
	                tracking.appendChild(cdata);
	                companion.appendChild(tracking);
	            }
	        }

	        if (data.hasOwnProperty('TrackingEvents')) {
	            elem = xmlDoc.createElement('TrackingEvents');
	            // enumerate trackers
	            for (i = 0; i < data.TrackingEvents.length; i++) {
	                var event = xmlDoc.createElement('Tracking');
	                attr = xmlDoc.createAttribute('event');
	                attr.value = data.TrackingEvents[i].eventType;
	                event.setAttributeNode(attr);
	                cdata = xmlDoc.createCDATASection(data.TrackingEvents[i].url);
	                event.appendChild(cdata);
	                elem.appendChild(event);
	            }
	            companion.appendChild(elem);
	        }

	        return companion;
	    }
	};

	module.exports = CompanionAds;

/***/ }),
/* 29 */
/***/ (function(module, exports) {

	var Icons = {

	    parse: function (IconsDest, IconsNode, helper) {
	        var nodes = helper.getSubNodes(IconsNode, 'Icon');
	        if (nodes) {
	            for (var i = 0; i < nodes.length; i++) {
	                var node = nodes[i];
	                var icon = {};

	                // required attributes
	                var width = helper.getNodeAttributeNumberValue(node, 'width', -1);
	                var height = helper.getNodeAttributeNumberValue(node, 'height', -1);
	                var program = helper.getNodeAttributeValue(node, 'program');
	                var xPosition = helper.getNodeAttributeValue(node, 'xPosition');
	                var yPosition = helper.getNodeAttributeValue(node, 'yPosition');
	                if (width <= 0 || height <= 0 || program.length === 0 || xPosition.length === 0 || yPosition.length === 0) {
	                    continue;
	                }
	                icon.width = width;
	                icon.height = height;
	                icon.program = program;
	                icon.xPosition = xPosition;
	                icon.yPosition = yPosition;

	                // optional attributes and subnodes
	                var val = helper.getNodeAttributeValue(node, 'apiFramework');
	                if (val) {
	                    icon.apiFramework = val;
	                }

	                var pxratio = helper.getNodeAttributeNumberValue(node, 'pxratio', 1.0);
	                if (pxratio !== 1.0) {
	                	icon.pxratio = pxratio;
	                }
	                
	                val = helper.getNodeAttributeValue(node, 'offset');
	                if (val) {
	                    // validate
	                    if (isNaN(Date.parse('January 1, 1970 ' + val))) {
	                        // invalid time format
	                        continue;
	                    }
	                    icon.offset = val;
	                }

	                val = helper.getNodeAttributeValue(node, 'duration');
	                if (val) {
	                    // validate
	                    if (isNaN(Date.parse('January 1, 1970 ' + val))) {
	                        // invalid time format
	                        continue;
	                    }
	                    icon.duration = val;
	                }

	                var resource = helper.getSubNode(node, 'StaticResource');
	                if (resource) {
	                    val = helper.getNodeAttributeValue(resource, 'creativeType');
	                    if (val) {
	                        // validate capability
	                        var flashOnlyType = val === 'video/x-flv' || val === 'video/x-f4v' || val === 'video/f4v' || val === 'application/x-shockwave-flash';
	                        var isMobile = false;
	                        if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
	                            isMobile = true;
	                        }
	                        if (isMobile && flashOnlyType) {
	                            // ignore this companion
	                            continue;
	                        }

	                        var staticResource = {type: val};
	                        val = helper.getNodeValues(resource);
	                        if (val) {
	                            staticResource.src = val;
	                            icon.StaticResource = staticResource;
	                        }
	                    }
	                }

	                val = helper.getSubNodeWholeValue(node, 'IFrameResource');
	                if (val) {
	                    icon.IFrameResource = val;
	                }

	                val = helper.getSubNodeWholeValue(node, 'HTMLResource');
	                if (val) {
	                    icon.HTMLResource = val;
	                }
	                
	                // icon must contain a resource
	                if (!icon.StaticResource && !icon.IFrameResource && !icon.HTMLResource) {
	                	continue;
	                }

	                var iconClicks = helper.getSubNode(node, 'IconClicks');
	                if (iconClicks) {
	                    val = helper.getSubNodeValue(node, 'IconClickThrough');
	                    if (val) {
	                        icon.IconClickThrough = val;
	                    }

	                    //IconClickTracking can be multiple by a VAST3.0 spec 2.4.3.5 Icon Clicks and Tracking
	                    val = helper.getSubNodes(iconClicks, 'IconClickTracking');
	                    if (val) {
	                        icon.IconClickTracking = [];
	                        for (var cntIconClick = 0; cntIconClick < val.length; cntIconClick++) {
	                            icon.IconClickTracking.push(helper.getNodeValues(val[cntIconClick]));
	                        }
	                    }
	                }

	                /* VAST3 XML schema explains IconViewTracking can be multiple like below
	                 <xs:element name="IconViewTracking" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded">
	                 <xs:annotation>
	                 <xs:documentation>URLs to ping when icon is shown.</xs:documentation>
	                 </xs:annotation>
	                 </xs:element>
	                 */
	                var iconViewTracking = helper.getSubNodes(node, 'IconViewTracking');
	                if (iconViewTracking) {
	                    icon.IconViewTracking = [];
	                    for (var cntIconView = 0; cntIconView < iconViewTracking.length; cntIconView++) {
	                        icon.IconViewTracking.push(helper.getNodeValues(iconViewTracking[cntIconView]));
	                    }
	                }


	                var removeExistingProgram = function (IconsDest, program) {
	                    for (var cntIconDest = 0; cntIconDest < IconsDest.length; cntIconDest++) {
	                        if (IconsDest[cntIconDest].program === program) {
	                            IconsDest.splice(cntIconDest, 1);
	                        }
	                    }
	                };

	                //VIDLA-625 if same program exists in Icons node last one will be used.
	                removeExistingProgram(IconsDest, program);

	                IconsDest.push(icon);

	            }
	        }
	    },

	    createIconNode: function (xmlDoc, data) {
	        var icon = xmlDoc.createElement('Icon');
	        var i;
	        var elem;
	        var attr;
	        var cdata;

	        var arrAttrs = ['width', 'height', 'program', 'xPosition', 'yPosition', 'apiFramework', 'offset', 'duration'];
	        for (i = 0; i < arrAttrs.length; i++) {
	            if (data.hasOwnProperty(arrAttrs[i])) {
	                attr = xmlDoc.createAttribute(arrAttrs[i]);
	                attr.value = data[arrAttrs[i]];
	                icon.setAttributeNode(attr);
	            }
	        }

	        if (data.hasOwnProperty('StaticResource')) {
	            elem = xmlDoc.createElement('StaticResource');
	            attr = xmlDoc.createAttribute('creativeType');
	            attr.value = data.StaticResource.type;
	            elem.setAttributeNode(attr);
	            cdata = xmlDoc.createCDATASection(data.StaticResource.src);
	            elem.appendChild(cdata);
	            icon.appendChild(elem);
	        }

	        var arrNodes = ['IFrameResource', 'HTMLResource', 'IconViewTracking'];
	        for (i = 0; i < arrNodes.length; i++) {
	            if (data.hasOwnProperty(arrNodes[i])) {
	                elem = xmlDoc.createElement(arrNodes[i]);
	                cdata = xmlDoc.createCDATASection(data[arrNodes[i]]);
	                elem.appendChild(cdata);
	                icon.appendChild(elem);
	            }
	        }

	        if (data.hasOwnProperty('IconClickThrough') || data.hasOwnProperty('IconClickTracking')) {
	            var iconClicks = xmlDoc.createElement('IconClicks');
	            if (data.hasOwnProperty('IconClickThrough')) {
	                elem = xmlDoc.createElement('IconClickThrough');
	                cdata = xmlDoc.createCDATASection(data.IconClickThrough);
	                elem.appendChild(cdata);
	                iconClicks.appendChild(elem);
	            }
	            if (data.hasOwnProperty('IconClickTracking')) {
	                elem = xmlDoc.createElement('IconClickTracking');
	                cdata = xmlDoc.createCDATASection(data.IconClickTracking);
	                elem.appendChild(cdata);
	                iconClicks.appendChild(elem);
	            }
	            icon.appendChild(iconClicks);
	        }

	        return icon;
	    }
	};

	module.exports = Icons;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * VAST Parser module.
	 * @module VastParser
	 */

	var VastXMLParserHelper = __webpack_require__(27);

	var APN_CompanionAds = __webpack_require__(28);
	var APN_Icons = __webpack_require__(29);

	var VastModifier = function (parserData, adToken, notifyUrl, contentSource, buyerMemberId, viewabilityConfig, additionalTrackers, creativeId) {

	    var _logger = __webpack_require__(3);
	    var _prefix = 'VAST Parser';

	    var _parserData = parserData;
	    var _adToken = adToken;
	    var _notifyUrl = notifyUrl;
	    var _creativeId = creativeId;
	    var _buyerMemberId = buyerMemberId;
	    var _contentSource = contentSource;
	    var _viewabilityConfig = viewabilityConfig;
		var _additionalTrackers = additionalTrackers;
	    var _helper = new VastXMLParserHelper();

	    function trimXml(strVastXml) {
	        var nPos = strVastXml.indexOf('<');
	        var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
	        nPos = strXml.lastIndexOf('>');
	        if (nPos !== -1) {
	            strXml = strXml.substr(0, nPos + 1);
	        }
	        return strXml;
	    }

	    function prepareDocObject(strVastXml) {
	        var strXml = trimXml(strVastXml);
	        var xmlDoc = null;
	        if (typeof window.DOMParser !== 'undefined') {
	            xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
	            if (xmlDoc.documentElement.nodeName === 'parsererror') {
	                try {
	                    _logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
	                }
	                catch (e) {
	                }
	                return null;
	            }
	        }
	        else if (typeof window.ActiveXObject !== 'undefined') {
	            try {
	                xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
	                xmlDoc.loadXML(strXml);
	                if (xmlDoc.parseError.errorCode !== 0) {
	                    _logger.error(_prefix, xmlDoc.parseError);
	                    return null;
	                }
	            }
	            catch (ex) {
	                _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
	                return null;
	            }
	        }
	        else {
	            _logger.error(_prefix, 'Failed to get vast xml parser');
	            return null;
	        }
	        return xmlDoc;
	    }

	    var _xmlDoc = prepareDocObject(parserData.vastXml);

	    function updateVastVersion(vastVersion) {
	        if (_xmlDoc) {
	            var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
	            if (vastNode) {
	                var attr = _xmlDoc.createAttribute('version');
	                attr.value = vastVersion;
	                vastNode.setAttributeNode(attr);
	            }
	        }
	    }

	    updateVastVersion(parserData.vastVersion);

	    function appendAttributesToAdNode() {
	        if (_xmlDoc) {
	            var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
	            if (vastNode) {
	                var ads = _helper.getSubNodes(vastNode, 'Ad');
	                if (ads && ads.length > 0) {
	                    for (var i = 0; i < ads.length; i++) {
	                        if (_notifyUrl) {
	                            var attr = _xmlDoc.createAttribute('notifyurl');
	                            attr.value = _notifyUrl;
	                            ads[i].setAttributeNode(attr);
	                        }
	                        if (_contentSource && _contentSource === 'rtb') {
	                            var attr2 = _xmlDoc.createAttribute('rtb');
	                            attr2.value = 'true';
	                            ads[i].setAttributeNode(attr2);
	                        }
	                        var attr3 = _xmlDoc.createAttribute('sequence');
	                        attr3.value = _parserData.sequence.toString();
	                        ads[i].setAttributeNode(attr3);
	                        if (_buyerMemberId) {
	                            var attr4 = _xmlDoc.createAttribute('buyerMemberId');
	                            attr4.value = _buyerMemberId;
	                            ads[i].setAttributeNode(attr4);
	                        }
	                        if (_viewabilityConfig) {
	                            var attr5 = _xmlDoc.createAttribute('viewabilityConfig');
	                            attr5.value = _viewabilityConfig;
	                            ads[i].setAttributeNode(attr5);
	                        }
	                        if (_creativeId) {
	                            var attr6 = _xmlDoc.createAttribute('creativeId');
	                            attr6.value = _creativeId;
	                            ads[i].setAttributeNode(attr6);
	                        }
	                    }
	                }
	            }
	        }
	    }

	    appendAttributesToAdNode();

	    function addCdataBlock(parentNode, url) {
	        var cdata = _xmlDoc.createCDATASection(url);
	        parentNode.appendChild(cdata);
	    }

	    var _creativesNode = null;

	    function getLinearNode() {
	        if (_adToken) {
	            var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
	            var attr = _xmlDoc.createAttribute('adtoken');
	            attr.value = _adToken;
	            vastNode.setAttributeNode(attr);
	        }

	        var inLine = _helper.getSubNode(_xmlDoc, 'InLine');
	        if (!inLine) {
	            return null;	// VAST xml has no InLine node
	        }

	        var i;
	        var impNode;
	        if (_parserData.extImpressionUrls && typeof _parserData.extImpressionUrls === 'string') {
	            var impTrackers = JSON.parse(_parserData.extImpressionUrls);
	            if (Array.isArray(impTrackers) && impTrackers.length > 0) {
	                for (i = 0; i < impTrackers.length; i++) {
	                    impNode = _xmlDoc.createElement('Impression');
	                    addCdataBlock(impNode, impTrackers[i]);
	                    inLine.appendChild(impNode);
	                }
	            }
	            delete _parserData.extImpressionUrls;
	        }
	    	if (_additionalTrackers && _additionalTrackers.impressions) {
	    		for (i = 0; i < _additionalTrackers.impressions.length; i++) {
	    			if (_additionalTrackers.impressions[i]) {
		            	impNode = _xmlDoc.createElement('Impression');
		            	addCdataBlock(impNode, _additionalTrackers.impressions[i]);
		            	inLine.appendChild(impNode);
	    			}
	    		}
	    	}
	        	
	    	var errNode;
	        if (_parserData.extErrorUrls && typeof _parserData.extErrorUrls === 'string') {
	            var errTrackers = JSON.parse(_parserData.extErrorUrls);
	            if (Array.isArray(errTrackers) && errTrackers.length > 0) {
	                for (i = 0; i < errTrackers.length; i++) {
	                    errNode = _xmlDoc.createElement('Error');
	                    addCdataBlock(errNode, errTrackers[i]);
	                    inLine.appendChild(errNode);
	                }
	            }
	            delete _parserData.extErrorUrls;
	        }
	    	if (_additionalTrackers && _additionalTrackers.errors) {
	    		for (i = 0; i < _additionalTrackers.errors.length; i++) {
	    			if (_additionalTrackers.errors[i]) {
		            	errNode = _xmlDoc.createElement('Error');
		            	addCdataBlock(errNode, _additionalTrackers.errors[i]);
		            	inLine.appendChild(errNode);
	    			}
	    		}
	    	}
	    	
	        if (_parserData.extViewableImpression && typeof _parserData.extViewableImpression === 'string') {
	            var viewableImpressions = JSON.parse(_parserData.extViewableImpression);
	            var viNode = _xmlDoc.createElement('ViewableImpression');
	            if (Array.isArray(viewableImpressions.viewable) && viewableImpressions.viewable.length > 0) {
	                for (i = 0; i < viewableImpressions.viewable.length; i++) {
	                    var viewableNode = _xmlDoc.createElement('Viewable');
	                    addCdataBlock(viewableNode, viewableImpressions.viewable[i]);
	                    viNode.appendChild(viewableNode);
	                }
	            }
	            if (Array.isArray(viewableImpressions.notViewable) && viewableImpressions.notViewable.length > 0) {
	                for (i = 0; i < viewableImpressions.notViewable.length; i++) {
	                    var notViewableNode = _xmlDoc.createElement('NotViewable');
	                    addCdataBlock(notViewableNode, viewableImpressions.notViewable[i]);
	                    viNode.appendChild(notViewableNode);
	                }
	            }
	            if (Array.isArray(viewableImpressions.undetermined) && viewableImpressions.undetermined.length > 0) {
	                for (i = 0; i < viewableImpressions.undetermined.length; i++) {
	                    var undeterminedNode = _xmlDoc.createElement('ViewUndetermined');
	                    addCdataBlock(undeterminedNode, viewableImpressions.undetermined[i]);
	                    viNode.appendChild(undeterminedNode);
	                }
	            }
	            inLine.appendChild(viNode);
	            delete _parserData.extViewableImpression;
	        }
	        	
	        var uaParser = __webpack_require__(9);
	        var ua = uaParser();
	        var browser = ua.browser.name.toLowerCase();
	        if (_parserData.extExtensions && typeof _parserData.extExtensions === 'string') {
	            var extensions = _parserData.extExtensions;
	            if (extensions.length > 0) {
	                var extensionsNode = _helper.getSubNode(inLine, 'Extensions');
	                if (!extensionsNode) {
	                    extensionsNode = _xmlDoc.createElement('Extensions');
	                    inLine.appendChild(extensionsNode);
	                    if (browser === 'ie') {
	                    	extensionsNode.textContent = extensions;
	                    }
	                    else {
	                        extensionsNode.innerHTML = extensions;
	                    }
	                }
	                else {
	                    if (browser === 'ie') {
	                    	extensionsNode.textContent = extensionsNode.textContent.toString() + extensions;
	                    }
	                    else {
	                        extensionsNode.innerHTML = extensionsNode.innerHTML.toString() + extensions;
	                    }
	                }
	            }
	            delete _parserData.extExtensions;
	        }

	        _creativesNode = _helper.getSubNode(inLine, 'Creatives');
	        if (!_creativesNode) {
	            _creativesNode = _xmlDoc.createElement('Creatives');
	            inLine.appendChild(_creativesNode);
	        }
	        var linearNode = _helper.getSubNode(_creativesNode, 'Linear');
	        if (!linearNode) {
	            var creativeNode = _xmlDoc.createElement('Creative');
	            _creativesNode.appendChild(creativeNode);
	            linearNode = _xmlDoc.createElement('Linear');
	            creativeNode.appendChild(linearNode);
	        }
	        return linearNode;
	    }

	    function iconAlreadyExist(iconsNode, program) {
	        var icons = _helper.getSubNodes(iconsNode, 'Icon');
	        if (icons && icons.length > 0) {
	            for (var i = 0; i < icons.length; i++) {
	                var programAttr = _helper.getNodeAttributeValue(icons[i], 'program');
	                if (programAttr.toLowerCase() === program.toLowerCase()) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    }

	    function appendTrackings(linearNode) {
	        var i;
	        if (_parserData.extTrackingUrls && typeof _parserData.extTrackingUrls === 'string' &&
	            _parserData.extTrackingUrls.length > 5) {
	            var videoTrackers = JSON.parse(_parserData.extTrackingUrls);
	            var trackersNode = _helper.getSubNode(linearNode, 'TrackingEvents');
	            if (!trackersNode) {
	                trackersNode = _xmlDoc.createElement('TrackingEvents');
	                linearNode.appendChild(trackersNode);
	            }
	            // enumerate video trackers
	            for (var name in videoTrackers) {
	                var urls = videoTrackers[name];
	                for (i = 0; i < urls.length; i++) {
	                    var trackerNode = _xmlDoc.createElement('Tracking');
	                    var attr = _xmlDoc.createAttribute('event');
	                    attr.value = name;
	                    trackerNode.setAttributeNode(attr);
	                    //trackerNode.textContent = urls[i];
	                    addCdataBlock(trackerNode, urls[i]);
	                    trackersNode.appendChild(trackerNode);
	                }
	            }
	            delete _parserData.extTrackingUrls;
	        }

	        var videoClicksNode;
	        if (_parserData.extClickUrls && typeof _parserData.extClickUrls === 'string') {
	            var videoClicks = JSON.parse(_parserData.extClickUrls);
	            if (Array.isArray(videoClicks) && videoClicks.length > 0) {
	                videoClicksNode = _helper.getSubNode(linearNode, 'VideoClicks');
	                if (!videoClicksNode) {
	                    videoClicksNode = _xmlDoc.createElement('TrackingEvents');
	                    linearNode.appendChild(videoClicksNode);
	                }
	                if (!_helper.getSubNode(videoClicksNode, 'ClickThrough')) {
	                    var clickNode = _xmlDoc.createElement('ClickThrough');
	                    //clickNode.textContent = videoClicks[0];
	                    addCdataBlock(clickNode, videoClicks[0]);
	                    videoClicksNode.appendChild(clickNode);
	                }
	            }
	            delete _parserData.extClickUrls;
	        }

	        if (_parserData.extClickTrackingUrls && typeof _parserData.extClickTrackingUrls === 'string') {
	            var clickTrackings = JSON.parse(_parserData.extClickTrackingUrls);
	            if (Array.isArray(clickTrackings) && clickTrackings.length > 0) {
	                videoClicksNode = _helper.getSubNode(linearNode, 'VideoClicks');
	                if (!videoClicksNode) {
	                    videoClicksNode = _xmlDoc.createElement('VideoClicks');
	                    linearNode.appendChild(videoClicksNode);
	                }
	                for (i = 0; i < clickTrackings.length; i++) {
	                    var clickTrackingNode = _xmlDoc.createElement('ClickTracking');
	                    //clickTrackingNode.textContent = clickTrackings[i];
	                    addCdataBlock(clickTrackingNode, clickTrackings[i]);
	                    videoClicksNode.appendChild(clickTrackingNode);
	                }
	            }
	            delete _parserData.extClickTrackingUrls;
	        }

	        if (_parserData.extIcons && typeof _parserData.extIcons === 'string') {
	            var icons = JSON.parse(_parserData.extIcons);
	            if (Array.isArray(icons) && icons.length > 0) {
	                var iconsNode = _helper.getSubNode(linearNode, 'Icons');
	                if (!iconsNode) {
	                    iconsNode = _xmlDoc.createElement('Icons');
	                    linearNode.appendChild(iconsNode);
	                }
	                for (i = 0; i < icons.length; i++) {
	                    // avoid duplicate icons with same program
	                    if (!iconAlreadyExist(iconsNode, icons[i].program)) {
	                        var iconNode = APN_Icons.createIconNode(_xmlDoc, icons[i]);
	                        if (iconNode) {
	                            iconsNode.appendChild(iconNode);
	                        }
	                    }
	                }
	            }
	            delete _parserData.extIcons;
	        }
	    }

	    function appendNewCompanion(companionAdsNode, newCompanion) {
	        // get companions with resources
	        var companionNode, j;
	        var companionAdsObj = {companions: []};
	        APN_CompanionAds.parse(companionAdsObj, companionAdsNode, _helper);
	        var resCompanions = companionAdsObj.companions;
	        if (newCompanion.StaticResource || newCompanion.IFrameResource || newCompanion.HTMLResource) {
	            var sameSize = false;
	            for (j = 0; j < resCompanions.length; j++) {
	                if (newCompanion.width === resCompanions[j].width &&
	                    newCompanion.height === resCompanions[j].height) {
	                    sameSize = true;
	                    break;
	                }
	            }
	            if (!sameSize) {
	                companionNode = APN_CompanionAds.createCompanionNode(_xmlDoc, newCompanion);
	                companionAdsNode.appendChild(companionNode);
	            }
	        }
	        else {
	            // aggregate companion without resorces into companions with resources
	            var needUpdate = false;
	            for (j = 0; j < resCompanions.length; j++) {
	                if (newCompanion.width === resCompanions[j].width && newCompanion.height === resCompanions[j].height) {
	                    if ((newCompanion.id && newCompanion.id === resCompanions[j].id) || (!newCompanion.id)) {
	                        // add click trackings
	                        if (newCompanion.CompanionClickTracking) {
	                            if (!resCompanions[j].CompanionClickTracking) {
	                                resCompanions[j].CompanionClickTracking = [];
	                            }
	                            resCompanions[j].CompanionClickTracking = resCompanions[j].CompanionClickTracking.concat(newCompanion.CompanionClickTracking);
	                        }
	                        // add view trackings
	                        if (newCompanion.TrackingEvents) {
	                            if (!resCompanions[j].TrackingEvents) {
	                                resCompanions[j].TrackingEvents = [];
	                            }
	                            resCompanions[j].TrackingEvents = resCompanions[j].TrackingEvents.concat(newCompanion.TrackingEvents);
	                        }
	                        needUpdate = true;
	                        break;
	                    }
	                }
	            }
	            if (needUpdate) {
	                while (companionAdsNode.firstChild) {
	                    companionAdsNode.removeChild(companionAdsNode.firstChild);
	                }
	                for (var i = 0; i < resCompanions.length; i++) {
	                    companionNode = APN_CompanionAds.createCompanionNode(_xmlDoc, resCompanions[i]);
	                    companionAdsNode.appendChild(companionNode);
	                }
	            }
	        }
	    }

	    function appendCompanions() {
	        if (_parserData.extCompanions && typeof _parserData.extCompanions === 'string') {
	            var companions = JSON.parse(_parserData.extCompanions);
	            if (Array.isArray(companions.companions) && companions.companions.length > 0) {
	                var companionAdsNode = _helper.getSubNode(_creativesNode, 'CompanionAds');
	                if (!companionAdsNode) {
	                    companionAdsNode = _xmlDoc.createElement('CompanionAds');
	                    _creativesNode.appendChild(companionAdsNode);
	                }
	                var attr;
	                if (companions.required !== 'unknown') {
	                    attr = _xmlDoc.createAttribute('required');
	                    attr.value = companions.required;
	                    companionAdsNode.setAttributeNode(attr);
	                }
	                for (var i = 0; i < companions.companions.length; i++) {
	                    appendNewCompanion(companionAdsNode, companions.companions[i]);
	                }
	            }
	        }
	    }

	    this.addTrackers = function () {
	        if (!_xmlDoc) {
	            return '';
	        }
	        var linearNode = getLinearNode();
	        if (!linearNode) {
	            return '';
	        }
	        appendTrackings(linearNode);
	        if (_creativesNode) {
	            appendCompanions();
	        }
	        var strOut;
	        var uaParser = __webpack_require__(9);
	        var ua = uaParser();
	        var browser = ua.browser.name.toLowerCase();
	        if (browser === 'edge') {
	            // VIDLA-683. Edge is loosing nested CDATA during serialization to string.
	            strOut = _xmlDoc.childNodes[0].outerHTML;
	        }
	        else if (browser === 'ie') {
	            // VIDLA-683. IE is loosing nested CDATA during parsing XML string to DOM.
	            // We have to restore nested CDATA for AdParameters if needed.
	            var nodes = _xmlDoc.getElementsByTagName('AdParameters');
	            for (var i = 0; i < nodes.length; i++) {
	                if (nodes[i].textContent.indexOf(']]>') > 0 && nodes[i].textContent.substr(0, 9) !== '<![CDATA[') {
	                    nodes[i].textContent = nodes[i].textContent.replace(/]]>/g, "]]]]><![CDATA[>");
	                    nodes[i].textContent = '<![CDATA[' + nodes[i].textContent + ']]>';
	                }
	            }
	            strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
	            strOut = strOut.replace(/&lt;/g, '<');
	            strOut = strOut.replace(/&gt;/g, '>');
	        }
	        else {
	            strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
	        }
	        return strOut;
	    };
	};

	module.exports = VastModifier;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * VastMerger module.
	 * @module VastParser
	 */

	var VastXMLParserHelper = __webpack_require__(27);

	var VastMerger = function (xmlList) {

	    var _logger = __webpack_require__(3);
	    var _prefix = 'VAST Parser';

	    var _xmls = xmlList;
	    var _helper = new VastXMLParserHelper();

	    function trimXml(strVastXml) {
	        var nPos = strVastXml.indexOf('<');
	        var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
	        nPos = strXml.lastIndexOf('>');
	        if (nPos !== -1) {
	            strXml = strXml.substr(0, nPos + 1);
	        }
	        return strXml;
	    }

	    function prepareDocObject(strVastXml) {
	        var strXml = trimXml(strVastXml);
	        var xmlDoc = null;
	        if (typeof window.DOMParser !== 'undefined') {
	            xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
	            if (xmlDoc.documentElement.nodeName === 'parsererror') {
	                try {
	                    _logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
	                }
	                catch (e) {
	                }
	                return null;
	            }
	        }
	        else if (typeof window.ActiveXObject !== 'undefined') {
	            try {
	                xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
	                xmlDoc.loadXML(strXml);
	                if (xmlDoc.parseError.errorCode !== 0) {
	                    _logger.error(_prefix, xmlDoc.parseError);
	                    return null;
	                }
	            }
	            catch (ex) {
	                _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
	                return null;
	            }
	        }
	        else {
	            _logger.error(_prefix, 'Failed to get vast xml parser');
	            return null;
	        }
	        return xmlDoc;
	    }

	    var _xmlDoc = prepareDocObject(_xmls[0]);
	    if (!_xmlDoc) {
	        return;
	    }

	    var _vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
	    var attr = _xmlDoc.createAttribute('apn_waterfall');
	    attr.value = true;
	    _vastNode.setAttributeNode(attr);

	    var adNodes = [];
	    for (var i = 0; i < _xmls.length; i++) {
	        var doc = prepareDocObject(_xmls[i]);
	        var vastNode = _helper.getSubNode(doc, 'VAST');
	        var ads = _helper.getSubNodes(vastNode, 'Ad');
	        if (ads && ads.length > 0) {
	            for (var j = 0; j < ads.length; j++) {
	                adNodes.push(ads[j]);
	            }
	        }
	    }

	    adNodes.sort(function (a, b) {
	        return _helper.getNodeAttributeNumberValue(a, 'sequence') - _helper.getNodeAttributeNumberValue(b, 'sequence');
	    });

	    var uaParser = __webpack_require__(9);
	    var ua = uaParser();
	    var browser = ua.browser.name.toLowerCase();
	    
	    if (browser === 'ie') {
	        _vastNode.textContent = '';
	    }
	    else {
	        _vastNode.innerHTML = '';
	    }
	    for (i = 0; i < adNodes.length; i++) {
	        _vastNode.appendChild(adNodes[i]);
	    }

	    this.getVastXml = function () {
	        if (!_xmlDoc) {
	            return '';
	        }
	        var strOut;
	        if (browser === 'edge') {
	            // VIDLA-683. Edge is loosing nested CDATA during serialization to string.
	            strOut = _xmlDoc.childNodes[0].outerHTML;
	        }
	        else if (browser === 'ie') {
	            // VIDLA-683. IE is loosing nested CDATA during parsing XML string to DOM.
	            // We have to restore nested CDATA for AdParameters if needed.
	            var nodes = _xmlDoc.getElementsByTagName('AdParameters');
	            for (var i = 0; i < nodes.length; i++) {
	                if (nodes[i].textContent.indexOf(']]>') > 0 && nodes[i].textContent.substr(0, 9) !== '<![CDATA[') {
	                    nodes[i].textContent = nodes[i].textContent.replace(/]]>/g, "]]]]><![CDATA[>");
	                    nodes[i].textContent = '<![CDATA[' + nodes[i].textContent + ']]>';
	                }
	            }
	            strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
	            strOut = strOut.replace(/&lt;/g, '<');
	            strOut = strOut.replace(/&gt;/g, '>');
	        }
	        else {
	            strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
	        }
	        return strOut;
	    };
	};

	module.exports = VastMerger;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var _logger = __webpack_require__(3);
	var ImpbusCommunicator = __webpack_require__(17);
	try {
		var _molPlugin = __webpack_require__(33);	
	}
	catch(e) {}
	var _MarkersHandler = __webpack_require__(2);
	var _uaParser = __webpack_require__(9);
	var _UserSync = __webpack_require__(34);
	var _Utils = __webpack_require__(16);

	var _prefix = 'apnVmapVast->vastManager';

	var vastManager = function () {
		var _ua = _uaParser();
		var _impbusCommunicator;
		var _player;
		var _options;
		var _adPlaying = false;
		var _defaultAdCancelTimeout = 3000;	
	    var _savedMarkers;
	    var _markersHandler;
	    var _contentDuration = 0;
	    var _markerXml = {};
	    var _adIndicator;
	    var _userSyncUrl;
		var _mobilePrerollNeedClick = false;
		var _prerollNeedClickToPlay = false;

		var _cover = document.getElementById('apn-break-cover');

		var _playlist = [];
		var _playlistIdx = -1;
		var _playlistCreative;
		var _nextPlaylistItemFired = false;

		var _isMobile = _ua.device.type || _ua.device.model;
		var _isIos = _ua.os.name.toLowerCase() === 'ios';
		var _isIPhone = _isMobile && _ua.device.model.toLowerCase() === 'iphone';
	    
		function showCover(show) {
			_logger.log(_prefix, (show ? "Show" : "Hide") + " ad cover with spinner");
			if (show) {
	    		_cover.style.display = 'block';
	     		_player.el().classList.add('vjs-waiting');
			}
			else {
	    		_cover.style.display = 'none';
	    		_player.el().classList.remove('vjs-waiting');
			}
		}
		
		function resetContent() {
			showCover(false);
			setTimeout(function() {
				_adPlaying = false;
				if (_savedMarkers) {
			    	_player.markers.reset(JSON.parse(_savedMarkers));
				}
			}, 1000);
			_adIndicator.style.display = 'none';
			removeListeners();
			_Utils.showNextOverlay(true);
			_nextPlaylistItemFired = false;
			if (_playlistCreative && _playlist.length > 0) {
				_player.one('ended', function() {
					setTimeout(function() {
						if (!_nextPlaylistItemFired && _playlistCreative) {
							_player.playlist.next();
						}
					}, 500);
				});
			}
		}
		
		function convertStringToSeconds(strTime, callback) {
			if (!strTime || strTime === 'start') {
				return 0;
			}
			else if (strTime === 'end') {
				if (_contentDuration > 0) {
					return _contentDuration;
				}
				else {
					if (_player.duration() > 0) {
						_contentDuration = parseInt(_player.duration()) - 0.5;
						return _contentDuration;
					}
					_player.one("loadedmetadata",function() {
						_contentDuration = parseInt(_player.duration()) - 0.5;
						callback(_contentDuration);
					});
					return -1;
				}
			}
			else if (strTime.indexOf(':') > 0) {
				try {
					var hours = parseInt(strTime.substr(0, strTime.indexOf(':')));
					strTime = strTime.substr(3, strTime.length - 3);
					var minuts = parseInt(strTime.substr(0, strTime.indexOf(':')));
					strTime = strTime.substr(3, strTime.length - 3);
					var seconds;
					if (strTime.indexOf('.') > 0) {
						seconds = parseInt(strTime.substr(0, strTime.indexOf('.')));
						strTime = strTime.substr(3, strTime.length - 3);
						var mseconds = parseInt(strTime);
						if (mseconds >= 500) {
							seconds++;
						}
					}
					else {
						seconds = parseInt(strTime);
					}
					return hours * 3600 + minuts * 60 + seconds;
				}
				catch(e) {
					_logger.warn(_prefix, 'Failed to convert time to seconds');
					return 0;
				}
			}
			else if (strTime.indexOf('%') > 0) {
				var percents = parseInt(strTime.substr(0, strTime.indexOf('%')));
				if (_contentDuration > 0) {
					return parseInt(_contentDuration * percents / 100);
				}
				else {
					if (_player.duration() > 0) {
						_contentDuration = parseInt(_player.duration()) - 0.5;
						return parseInt(_contentDuration * percents / 100);
					}
					_player.one("loadedmetadata",function() {
						_contentDuration = parseInt(_player.duration()) - 0.5;
						callback(parseInt(_contentDuration * percents / 100));
					});
					return -1;
				}
			}
			else {
				_logger.warn(_prefix, 'Invalid time format: ' + strTime);
				return 0;
			}
		}
		
		function needPlayAdForPlaylistItem(plIdx) {
			if (_options.frequencyRules && _options.frequencyRules.playlistClips && _options.frequencyRules.playlistClips > 1) {
				var mod = plIdx % _options.frequencyRules.playlistClips;
				return mod === 0;
			}
			return true;
		}

		function nextListItemHandler() {
			_nextPlaylistItemFired = true;
			showCover(true);
			_playlistIdx++;
			if (_markersHandler && _player.markers && _player.markers.destroy) {
				_player.markers.destroy();
			}
			if (_playlistCreative) {
				if (needPlayAdForPlaylistItem(_player.playlist.currentIndex())) {
					play(_playlistCreative);
					_playlistCreative = null;
					return;
				}
				showCover(false);
				_player.playlist.autoadvance(0);
			}
			else {
				_impbusCommunicator.getXML(_options, _player, function(xml, errorCode, errorMessage) {
					_playlistCreative = xml;
					if (errorCode) {
						showCover(false);
						_player.playlist.autoadvance(0);
						_logger.error(_prefix, 'Error to get VAST xml for next playlist item. Eror code: ' + errorCode + ". Error message: " + errorMessage);
					}
					else {
						if (needPlayAdForPlaylistItem(_player.playlist.currentIndex())) {
							play(_playlistCreative);
							_playlistCreative = null;
						}
						else {
							showCover(false);
							_player.playlist.autoadvance(0);
						}
					}
				});
			}
		}

		function getXmlForNextPlaylistItem() {
			_playlist = (_player.playlist && typeof _player.playlist === 'function') ? _player.playlist() : [];
			if (!_playlist) {
				_playlist = [];
			}
			if (_playlist.length > 0 && _playlistIdx < _playlist.length) {
				if (!_playlistCreative) {
					_impbusCommunicator.getXML(_options, _player, function(xml) {
						_playlistCreative = xml;
					});
				}
			}
			else {
				_player.off('playlistitem', nextListItemHandler);
			}
		}

		function loadMetadataHandler() {
			_contentDuration = parseInt(_player.duration()) - 0.5;
	        _player.off("loadedmetadata",loadMetadataHandler);
			_logger.log(_prefix, 'loadedmetadata event, duration: ' + _contentDuration);
		}
		
		function setPlaybackMethodData() {
			if (!_options || !_options.apnTagParams) {
				return;
			}
			var initPlayback = "auto";
	    	if (_player.currentTime() === 0) {
	    		initPlayback = _player.autoplay() ? 'auto' : 'click';
	    	}
			var initAudio = _player.muted() ? 'off' : 'on';
			_options.initialPlayback = initPlayback;
			_options.initialAudio = initAudio;
		}
		
		function traceMessage(event) {
			_logger.log(_prefix, 'trace event message: ' + event.data.message);
			if (_options.pageNotificationCallback) {
				_options.pageNotificationCallback('message', event.data.message);
			}
		}
		
		function traceEvent(event) {
			_logger.log(_prefix, 'trace event: ' + event.data.event);
			if (_options.pageNotificationCallback) {
				_options.pageNotificationCallback('event', event.data.event);
			}
		}
		
	    function addListeners() {
		    _player.one("loadedmetadata",loadMetadataHandler);
		    
	    	_player.one('vast.adStart', function() {
				showCover(false);
				_adIndicator.style.display = 'block';
	    		_adPlaying = true;
	    		if (_userSyncUrl) {
	    			_UserSync.sharedInstance().run({userSyncTargetElement: _player.el_, usersync_url: _userSyncUrl});
	    		}
	    	});
	    	
	    	_player.on('vast.adError', resetContent);    	
	    	_player.on('vast.adsCancel', resetContent);    	
	    	_player.on('vast.adSkip', resetContent);    	
	    	_player.on('vast.reset', resetContent);    	
	    	_player.on('vast.contentEnd', resetContent);
	    	_player.on('adFinished', resetContent);

	    	_player.on('trace.message', traceMessage);
	    	_player.on('trace.event', traceEvent);
	    }
	    
	    function removeListeners() {
	    	_player.off('vast.adError', resetContent);    	
	    	_player.off('vast.adsCancel', resetContent);    	
	    	_player.off('vast.adSkip', resetContent);    	
	    	_player.off('vast.reset', resetContent);    	
	    	_player.off('vast.contentEnd', resetContent);
	    	_player.off('adFinished', resetContent);

	    	_player.off('trace.message', traceMessage);
	    	_player.off('trace.event', traceEvent);
	    }
		
		var playAd = function(xml) {
			if (_adPlaying) {
				// not interrupt playing ad
				return;
			}
			addListeners();
			setPlaybackMethodData();
			var needPauseAndPlay = !_isMobile || !_player.paused();
			if (needPauseAndPlay) {
				_player.pause();
			}
			_adPlaying = true;
			if (_markersHandler) {
				_savedMarkers = JSON.stringify(_player.markers.getMarkers());
			}
			var clientParams = {
				verbosity: 5,	// for debugging only
				// VAST xml
				adTagXML: function(callback) { 
					setTimeout(function() {
						callback(null, xml);
					}, 0);
				},
				playAdAlways: false,
				//Note: As requested we set the preroll timeout at the same place than the adsCancelTimeout
				adCancelTimeout: (_options && _options.timeouts && _options.timeouts.adStartTimeout) ? _options.timeouts.adStartTimeout : _defaultAdCancelTimeout,
				adsEnabled: true,
				initialPlayback: _options.initialPlayback,
				initialAudio: _options.initialAudio
			};
			if (_options && _options.skippable && _options.skippable.skipText) {
				clientParams.skipText = _options.skippable.skipText;
			}
			if (_options && _options.skippable && _options.skippable.skipButtonText) {
				clientParams.skipButtonText = _options.skippable.skipButtonText;
			}
			if (_options && _options.viewability) {
				_options.viewability.contextId = 'anoutstream';
				//_options.viewability.contextId = 'anbrighcoveplugin';
				clientParams.viewability = _options.viewability;
			}
			if (_options && _options.clickThruEnabled === false) {
				clientParams.disableClickThru = true;
			}
			if (_options && _options.skippable && _options.skippable.hasOwnProperty('enabled')) {
				clientParams.skippable = {};
				clientParams.skippable.enabled = _options.skippable.enabled;
				clientParams.skippable.videoThreshold = _options.skippable.videoThreshold * 1000;
				clientParams.skippable.videoOffset = _options.skippable.videoOffset * 1000;
			}
			if (_options && _options.wrapperLimit &&  _options.wrapperLimit > 0) {
				clientParams.wrapperLimit = _options.wrapperLimit;
			}
				
			_player.vastClient(clientParams);
			if (_options.initialPlayback !== 'click' || _mobilePrerollNeedClick) {
				if (!_prerollNeedClickToPlay) {
					setTimeout(function() {
						_player.play();
					}, 0);
				}
			}
			_Utils.showNextOverlay(false);
			getXmlForNextPlaylistItem();
		};

		function play(xml) {
			if (_options.timeOffset) {
				var timeMarkers = {
						markerStyle: {
							'width': '5px',
							'border-radius': '10%',
							'background-color': 'white'
						},
						markerTip: {
							display: false
						},
						onMarkerReached: function(marker) {
							if (_markerXml[marker.time]) {
								_mobilePrerollNeedClick = _isMobile && marker.time === 0;
								if (_mobilePrerollNeedClick && _player.playlist && typeof _player.playlist === 'function') {
									if (_player.playlist.currentIndex() > 0) {
										_mobilePrerollNeedClick = false;
									}
								}
								if (_mobilePrerollNeedClick) {
									_player.bigPlayButton.el_.style.opacity = 1;
									if (_isIos) {
										// iOS
										if (_isIPhone) {
											// iPhone
											_player.bigPlayButton.el_.style.display = 'block';
											showCover(false);
											_player.one('play', function() {
												playAd(_markerXml[marker.time]);
												delete _markerXml[marker.time];
											});
										}
										else {
											// iPad
											setTimeout(function() {
												showCover(false);
												_player.pause();
												_player.bigPlayButton.el_.style.display = 'block';
												_player.one('play', function() {
													playAd(_markerXml[marker.time]);
													delete _markerXml[marker.time];
												});
											}, 1000);
										}
									}
									else {
										// android
										showCover(false);
										_player.one('play', function() {
											playAd(_markerXml[marker.time]);
											delete _markerXml[marker.time];
										});
									}
								}
								else {
									_prerollNeedClickToPlay = false;
									if (marker.time === 0 && _player.paused()) {
										showCover(false);
										_prerollNeedClickToPlay = true;
										_player.bigPlayButton.el_.style.display = 'block';
										_player.bigPlayButton.el_.style.opacity = 1;
									}
									playAd(_markerXml[marker.time]);
									delete _markerXml[marker.time];
								}
							}
						},
						markers: []
					};
				  _markersHandler = new _MarkersHandler(videojs);
				var seconds = convertStringToSeconds(_options.timeOffset, function(seconds) {
					_markerXml[seconds] = xml;
					if (_markersHandler) {
						var markers = [];
						markers.push({time: seconds});
						if (_savedMarkers) {
							var temp = JSON.parse(_savedMarkers);
							temp = temp.concat(markers);
							_savedMarkers = JSON.stringify(temp);
						}
						else {
							_player.markers.add(markers);
						}
						if (seconds > 1) {
							showCover(false);
						}
					}
				});
				if (seconds >= 0) {
					timeMarkers.markers.push({time: seconds});
					_markerXml[seconds] = xml;
					if (seconds > 1) {
						showCover(false);
					}
				}
				_markersHandler.init(_player);
				_markersHandler.markers(timeMarkers);
			}
			else {	    		    
				// if there's already content loaded, request an add immediately
				if (_player.currentSrc() && _player.duration() > 0) {
					playAd(xml);
				}
				else {
					_player.one('loadeddata', function() {
						playAd(xml);
					});
				}
			}
		}
	    
		this.play = function (vjsPlayer, options) {
	    	_player = vjsPlayer;
	    	_options = options;
	    	
			// initialize graphics 
			if (!_cover) {
				_cover = document.createElement('div');
				_cover.id = 'apn-break-cover';
				_cover.style.width = '100%';
				_cover.style.height = '100%';
				_cover.style.backgroundColor = 'black';
				_cover.style.position = 'absolute';
				_cover.style.zIndex = 101;
				_player.el().appendChild(_cover);
			}
			_cover.style.display = 'none';

			_adIndicator = document.createElement('p');
			_adIndicator.className = 'vjs-overlay';
			_adIndicator.innerHTML = _options.adText ? _options.adText : "Ad";
			_adIndicator.style.display = 'none';
			_adIndicator.style.left = '10px';
			_player.el().appendChild(_adIndicator);

			if (_options && _options.usersyncUrl) {
				_userSyncUrl = _options.usersyncUrl;
			}
			if (isNaN(_player.duration()) || _player.duration() <= 0) {
				showCover(true);
			}
			_impbusCommunicator = new ImpbusCommunicator();
	    	_impbusCommunicator.getXML(_options, _player, function(xml, errorCode, errorMessage) {
	    		if (errorCode) {
					_logger.error(_prefix, 'Error to get VAST xml. Eror code: ' + errorCode + ". Error message: " + errorMessage);
					if (_isMobile) {
						setTimeout(function() {
							showCover(false);
							_player.bigPlayButton.el_.style.display = 'block';
							_player.one('play', function() {
								_player.bigPlayButton.el_.style.display = 'none';
							});
						}, 500);
					}
					else {
						showCover(false);
					}
				}
	    		else {
					if (_player.duration() > 0) {
						// main content passible playing
						play(xml);
					}
					else {
						showCover(true);
						if (_ua.device.type || _ua.device.model) {
							// mobile
							if (_player.autoplay() === true) {
								_player.autoplay('any');
							}
							_player.one("loadedmetadata",function() {
								play(xml);
							});
						}
						else {
							// desktop
							setTimeout(function() {
								if (_player.paused() && _player.bigPlayButton.el_.style.display !== 'block' && !_adPlaying) {
									showCover(false);
									_player.bigPlayButton.el_.style.display = 'block';
									_player.bigPlayButton.one('click', function() {
										_player.bigPlayButton.el_.style.display = 'none';
									});
								}	
							}, 1000);
							_player.one('playing', function() {
								if (_player.paused()) {
									showCover(false);
									_player.bigPlayButton.el_.style.display = 'block';
									_player.bigPlayButton.one('click', function() {
										_player.bigPlayButton.el_.style.display = 'none';
										play(xml);
									});
								}
								else {
									_player.bigPlayButton.el_.style.display = 'none';
									play(xml);
								}
							});
						}
					}
				}
				setTimeout(function() {
					_player.on('playlistitem', nextListItemHandler);
				}, 1000);
			});
		};
			
	    this.stop = function() {
	    	if (_adPlaying) {
	    		_player.trigger('vast.adsCancel');
	    	}
			if (_markersHandler) {
	  	  		_player.markers.destroy();
			}
	    };

	};

	module.exports = vastManager;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	var require;var require;(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
	'use strict';

	var METHODS = [
	    'handshakeVersion',
	    'initAd',
	    'startAd',
	    'stopAd',
	    'skipAd', // VPAID 2.0 new method
	    'resizeAd',
	    'pauseAd',
	    'resumeAd',
	    'expandAd',
	    'collapseAd',
	    'subscribe',
	    'unsubscribe'
	];

	var EVENTS = [
	    'AdLoaded',
	    'AdStarted',
	    'AdStopped',
	    'AdSkipped',
	    'AdSkippableStateChange', // VPAID 2.0 new event
	    'AdSizeChange', // VPAID 2.0 new event
	    'AdLinearChange',
	    'AdDurationChange', // VPAID 2.0 new event
	    'AdExpandedChange',
	    'AdRemainingTimeChange', // [Deprecated in 2.0] but will be still fired for backwards compatibility
	    'AdVolumeChange',
	    'AdImpression',
	    'AdVideoStart',
	    'AdVideoFirstQuartile',
	    'AdVideoMidpoint',
	    'AdVideoThirdQuartile',
	    'AdVideoComplete',
	    'AdClickThru',
	    'AdInteraction', // VPAID 2.0 new event
	    'AdUserAcceptInvitation',
	    'AdUserMinimize',
	    'AdUserClose',
	    'AdPaused',
	    'AdPlaying',
	    'AdLog',
	    'AdError'
	];

	var GETTERS = [
	    'getAdLinear',
	    'getAdWidth', // VPAID 2.0 new getter
	    'getAdHeight', // VPAID 2.0 new getter
	    'getAdExpanded',
	    'getAdSkippableState', // VPAID 2.0 new getter
	    'getAdRemainingTime',
	    'getAdDuration', // VPAID 2.0 new getter
	    'getAdVolume',
	    'getAdCompanions', // VPAID 2.0 new getter
	    'getAdIcons' // VPAID 2.0 new getter
	];

	var SETTERS = [
	    'setAdVolume'
	];


	/**
	 * This callback is displayed as global member. The callback use nodejs error-first callback style
	 * @callback NodeStyleCallback
	 * @param {string|null}
	 * @param {undefined|object}
	 */


	/**
	 * IVPAIDAdUnit
	 *
	 * @class
	 *
	 * @param {object} creative
	 * @param {HTMLElement} el
	 * @param {HTMLVideoElement} video
	 */
	function IVPAIDAdUnit(creative, el, video) {}


	/**
	 * handshakeVersion
	 *
	 * @param {string} VPAIDVersion
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.handshakeVersion = function (VPAIDVersion, callback) {};

	/**
	 * initAd
	 *
	 * @param {number} width
	 * @param {number} height
	 * @param {string} viewMode can be 'normal', 'thumbnail' or 'fullscreen'
	 * @param {number} desiredBitrate indicates the desired bitrate in kbps
	 * @param {object} [creativeData] used for additional initialization data
	 * @param {object} [environmentVars] used for passing implementation-specific of js version
	 * @param {NodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.initAd = function(width, height, viewMode, desiredBitrate, creativeData, environmentVars, callback) {};

	/**
	 * startAd
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.startAd = function(callback) {};

	/**
	 * stopAd
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.stopAd = function(callback) {};

	/**
	 * skipAd
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.skipAd = function(callback) {};

	/**
	 * resizeAd
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.resizeAd = function(width, height, viewMode, callback) {};

	/**
	 * pauseAd
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.pauseAd = function(callback) {};

	/**
	 * resumeAd
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.resumeAd = function(callback) {};

	/**
	 * expandAd
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.expandAd = function(callback) {};

	/**
	 * collapseAd
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.collapseAd = function(callback) {};

	/**
	 * subscribe
	 *
	 * @param {string} event
	 * @param {nodeStyleCallback} handler
	 * @param {object} context
	 */
	IVPAIDAdUnit.prototype.subscribe = function(event, handler, context) {};

	/**
	 * startAd
	 *
	 * @param {string} event
	 * @param {function} handler
	 */
	IVPAIDAdUnit.prototype.unsubscribe = function(event, handler) {};



	/**
	 * getAdLinear
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.getAdLinear = function(callback) {};

	/**
	 * getAdWidth
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.getAdWidth = function(callback) {};

	/**
	 * getAdHeight
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.getAdHeight = function(callback) {};

	/**
	 * getAdExpanded
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.getAdExpanded = function(callback) {};

	/**
	 * getAdSkippableState
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.getAdSkippableState = function(callback) {};

	/**
	 * getAdRemainingTime
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.getAdRemainingTime = function(callback) {};

	/**
	 * getAdDuration
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.getAdDuration = function(callback) {};

	/**
	 * getAdVolume
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.getAdVolume = function(callback) {};

	/**
	 * getAdCompanions
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.getAdCompanions = function(callback) {};

	/**
	 * getAdIcons
	 *
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.getAdIcons = function(callback) {};

	/**
	 * setAdVolume
	 *
	 * @param {number} volume
	 * @param {nodeStyleCallback} callback
	 */
	IVPAIDAdUnit.prototype.setAdVolume = function(volume, callback) {};

	addStaticToInterface(IVPAIDAdUnit, 'METHODS', METHODS);
	addStaticToInterface(IVPAIDAdUnit, 'GETTERS', GETTERS);
	addStaticToInterface(IVPAIDAdUnit, 'SETTERS', SETTERS);
	addStaticToInterface(IVPAIDAdUnit, 'EVENTS',  EVENTS);


	var VPAID1_METHODS = METHODS.filter(function(method) {
	    return ['skipAd'].indexOf(method) === -1;
	});

	addStaticToInterface(IVPAIDAdUnit, 'checkVPAIDInterface', function checkVPAIDInterface (creative) {
	    var result = VPAID1_METHODS.every(function(key) {
	        return typeof creative[key] === 'function';
	    });
	    return result;
	});

	module.exports = IVPAIDAdUnit;

	function addStaticToInterface(Interface, name, value) {
	    Object.defineProperty(Interface, name, {
	        writable: false,
	        configurable: false,
	        value: value
	    });
	}


	},{}],2:[function(require,module,exports){
	'use strict';

	var IVPAIDAdUnit = require('./IVPAIDAdUnit');
	var Subscriber = require('./subscriber');
	var checkVPAIDInterface = IVPAIDAdUnit.checkVPAIDInterface;
	var utils = require('./utils');
	var METHODS = IVPAIDAdUnit.METHODS;
	var ERROR = 'AdError';
	var AD_CLICK = 'AdClickThru';
	var FILTERED_EVENTS = IVPAIDAdUnit.EVENTS.filter(function (event) {
	    return event != AD_CLICK;
	});

	/**
	 * This callback is displayed as global member. The callback use nodejs error-first callback style
	 * @callback NodeStyleCallback
	 * @param {string|null}
	 * @param {undefined|object}
	 */


	/**
	 * VPAIDAdUnit
	 * @class
	 *
	 * @param VPAIDCreative
	 * @param {HTMLElement} [el] this will be used in initAd environmentVars.slot if defined
	 * @param {HTMLVideoElement} [video] this will be used in initAd environmentVars.videoSlot if defined
	 */
	function VPAIDAdUnit(VPAIDCreative, el, video, iframe) {
	    this._isValid = checkVPAIDInterface(VPAIDCreative);
	    if (this._isValid) {
	        this._creative = VPAIDCreative;
	        this._el = el;
	        this._videoEl = video;
	        this._iframe = iframe;
	        this._subscribers = new Subscriber();
	        utils.setFullSizeStyle(el);
	        $addEventsSubscribers.call(this);
	    }
	}

	VPAIDAdUnit.prototype = Object.create(IVPAIDAdUnit.prototype);

	/**
	 * isValidVPAIDAd will return if the VPAIDCreative passed in constructor is valid or not
	 *
	 * @return {boolean}
	 */
	VPAIDAdUnit.prototype.isValidVPAIDAd = function isValidVPAIDAd() {
	    return this._isValid;
	};

	IVPAIDAdUnit.METHODS.forEach(function(method) {
	    //NOTE: this methods arguments order are implemented differently from the spec
	    var ignores = [
	        'subscribe',
	        'unsubscribe',
	        'initAd'
	    ];

	    if (ignores.indexOf(method) !== -1) return;

	    VPAIDAdUnit.prototype[method] = function () {
	        var ariaty = IVPAIDAdUnit.prototype[method].length;
	        // TODO avoid leaking arguments
	        // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
	        var args = Array.prototype.slice.call(arguments);
	        var callback = (ariaty === args.length) ? args.pop() : undefined;

	        setTimeout(function () {
	            var result, error = null;
	            try {
	                result = this._creative[method].apply(this._creative, args);
	            } catch(e) {
	                error = e;
	            }

	            callOrTriggerEvent(callback, this._subscribers, error, result);
	        }.bind(this), 0);
	    };
	});


	/**
	 * initAd concreate implementation
	 *
	 * @param {number} width
	 * @param {number} height
	 * @param {string} viewMode can be 'normal', 'thumbnail' or 'fullscreen'
	 * @param {number} desiredBitrate indicates the desired bitrate in kbps
	 * @param {object} [creativeData] used for additional initialization data
	 * @param {object} [environmentVars] used for passing implementation-specific of js version, if el & video was used in constructor slot & videoSlot will be added to the object
	 * @param {NodeStyleCallback} callback
	 */
	VPAIDAdUnit.prototype.initAd = function initAd(width, height, viewMode, desiredBitrate, creativeData, environmentVars, callback) {
	    creativeData = creativeData || {};
	    environmentVars = utils.extend({
	        slot: this._el,
	        videoSlot: this._videoEl
	    }, environmentVars || {});

	    setTimeout(function () {
	        var error;
	        try {
	            this._creative.initAd(width, height, viewMode, desiredBitrate, creativeData, environmentVars);
	        } catch (e) {
	            error = e;
	        }

	        callOrTriggerEvent(callback, this._subscribers, error);
	    }.bind(this), 0);
	};

	/**
	 * subscribe
	 *
	 * @param {string} event
	 * @param {nodeStyleCallback} handler
	 * @param {object} context
	 */
	VPAIDAdUnit.prototype.subscribe = function subscribe(event, handler, context) {
	    this._subscribers.subscribe(handler, event, context);
	};


	/**
	 * unsubscribe
	 *
	 * @param {string} event
	 * @param {nodeStyleCallback} handler
	 */
	VPAIDAdUnit.prototype.unsubscribe = function unsubscribe(event, handler) {
	    this._subscribers.unsubscribe(handler, event);
	};

	//alias
	VPAIDAdUnit.prototype.on = VPAIDAdUnit.prototype.subscribe;
	VPAIDAdUnit.prototype.off = VPAIDAdUnit.prototype.unsubscribe;

	IVPAIDAdUnit.GETTERS.forEach(function(getter) {
	    VPAIDAdUnit.prototype[getter] = function (callback) {
	        setTimeout(function () {

	            var result, error = null;
	            try {
	                result = this._creative[getter]();
	            } catch(e) {
	                error = e;
	            }

	            callOrTriggerEvent(callback, this._subscribers, error, result);
	        }.bind(this), 0);
	    };
	});

	/**
	 * setAdVolume
	 *
	 * @param volume
	 * @param {nodeStyleCallback} callback
	 */
	VPAIDAdUnit.prototype.setAdVolume = function setAdVolume(volume, callback) {
	    setTimeout(function () {

	        var result, error = null;
	        try {
	            this._creative.setAdVolume(volume);
	            result = this._creative.getAdVolume();
	        } catch(e) {
	            error = e;
	        }

	        if (!error) {
	            error = utils.validate(result === volume, 'failed to apply volume: ' + volume);
	        }
	        callOrTriggerEvent(callback, this._subscribers, error, result);
	    }.bind(this), 0);
	};

	VPAIDAdUnit.prototype._destroy = function destroy() {
	    this.stopAd();
	    this._subscribers.unsubscribeAll();
	};

	function $addEventsSubscribers() {
	    // some ads implement
	    // so they only handle one subscriber
	    // to handle this we create our one
	    FILTERED_EVENTS.forEach(function (event) {
	        this._creative.subscribe($trigger.bind(this, event), event);
	    }.bind(this));

	    // map the click event to be an object instead of depending of the order of the arguments
	    // and to be consistent with the flash
	    this._creative.subscribe($clickThruHook.bind(this), AD_CLICK);

	    // because we are adding the element inside the iframe
	    // the user is not able to click in the video
	    if (this._videoEl) {
	        var documentElement = this._iframe.contentDocument.documentElement;
	        var videoEl = this._videoEl;
	        documentElement.addEventListener('click', function(e) {
	            if (e.target === documentElement) {
	                videoEl.click();
	            }
	        });
	    }
	}

	function $clickThruHook(url, id, playerHandles) {
	    this._subscribers.triggerSync(AD_CLICK, {url: url, id: id, playerHandles: playerHandles});
	}

	function $trigger(event) {
	    // TODO avoid leaking arguments
	    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
	    this._subscribers.trigger(event, Array.prototype.slice(arguments, 1));
	}

	function callOrTriggerEvent(callback, subscribers, error, result) {
	    if (callback) {
	        callback(error, result);
	    } else if (error) {
	        subscribers.trigger(ERROR, error);
	    }
	}

	module.exports = VPAIDAdUnit;


	},{"./IVPAIDAdUnit":1,"./subscriber":4,"./utils":5}],3:[function(require,module,exports){
	'use strict';

	var utils = require('./utils');
	var unique = utils.unique('vpaidIframe');
	var VPAIDAdUnit = require('./VPAIDAdUnit');

	var defaultTemplate = '<!DOCTYPE html>' +
	    '<html lang="en">' +
	    '<head><meta charset="UTF-8"></head>' +
	    '<body style="margin:0;padding:0"><div class="ad-element"></div>' +
	    '<script type="text/javascript" src="{{iframeURL_JS}}"><\/script>' +
	    '<script type="text/javascript">' +
	    'window.parent.postMessage(\'{"event": "ready", "id": "{{iframeID}}"}\', \'{{origin}}\');' +
	    '<\/script>' +
	    '</body>' +
	    '</html>';

	var AD_STOPPED = 'AdStopped';

	/**
	 * This callback is displayed as global member. The callback use nodejs error-first callback style
	 * @callback NodeStyleCallback
	 * @param {string|null}
	 * @param {undefined|object}
	 */

	/**
	 * VPAIDHTML5Client
	 * @class
	 *
	 * @param {HTMLElement} el that will contain the iframe to load adUnit and a el to add to adUnit slot
	 * @param {HTMLVideoElement} video default video element to be used by adUnit
	 * @param {object} [templateConfig] template: html template to be used instead of the default, extraOptions: to be used when rendering the template
	 * @param {object} [vpaidOptions] timeout: when loading adUnit
	 */
	function VPAIDHTML5Client(el, video, templateConfig, vpaidOptions) {
	    templateConfig = templateConfig || {};

	    this._id = unique();
	    this._destroyed = false;

	    this._frameContainer = utils.createElementInEl(el, 'div');
	    this._videoEl = video;
	    this._vpaidOptions = vpaidOptions || {timeout: 10000};

	    this._templateConfig = {
	        template: templateConfig.template || defaultTemplate,
	        extraOptions: templateConfig.extraOptions || {}
	    };
	}

	/**
	 * destroy
	 *
	 */
	VPAIDHTML5Client.prototype.destroy = function destroy() {
	    if (this._destroyed) {
	        return;
	    }
	    this._destroyed = true;
	    $unloadPreviousAdUnit.call(this);
	};

	/**
	 * isDestroyed
	 *
	 * @return {boolean}
	 */
	VPAIDHTML5Client.prototype.isDestroyed = function isDestroyed() {
	    return this._destroyed;
	};

	/**
	 * loadAdUnit
	 *
	 * @param {string} adURL url of the js of the adUnit
	 * @param {nodeStyleCallback} callback
	 */
	VPAIDHTML5Client.prototype.loadAdUnit = function loadAdUnit(adURL, callback) {
	    $throwIfDestroyed.call(this);
	    $unloadPreviousAdUnit.call(this);
	    var that = this;

	    var frame = utils.createIframeWithContent(
	        this._frameContainer,
	        this._templateConfig.template,
	        utils.extend({
	            iframeURL_JS: adURL,
	            iframeID: this.getID(),
	            origin: getOrigin()
	        }, this._templateConfig.extraOptions)
	    );

	    this._frame = frame;

	    this._onLoad = utils.callbackTimeout(
	        this._vpaidOptions.timeout,
	        onLoad.bind(this),
	        onTimeout.bind(this)
	    );

	    window.addEventListener('message', this._onLoad);

	    function onLoad (e) {
	        /*jshint validthis: false */
	        //don't clear timeout
	        if (e.origin !== getOrigin()) return;
	        var result = JSON.parse(e.data);

	        //don't clear timeout
	        if (result.id !== that.getID()) return;

	        var adUnit, error, createAd;
	        if (!that._frame.contentWindow) {

	            error = 'the iframe is not anymore in the DOM tree';

	        } else {
	            createAd = that._frame.contentWindow.getVPAIDAd;
	            error = utils.validate(typeof createAd === 'function', 'the ad didn\'t return a function to create an ad');
	        }

	        if (!error) {
	            var adEl = that._frame.contentWindow.document.querySelector('.ad-element');
	            adUnit = new VPAIDAdUnit(createAd(), adEl, that._videoEl, that._frame);
	            adUnit.subscribe(AD_STOPPED, $adDestroyed.bind(that));
	            error = utils.validate(adUnit.isValidVPAIDAd(), 'the add is not fully complaint with VPAID specification');
	        }

	        that._adUnit = adUnit;
	        $destroyLoadListener.call(that);
	        callback(error, error ? null : adUnit);

	        //clear timeout
	        return true;
	    }

	    function onTimeout() {
	        callback('timeout', null);
	    }
	};

	/**
	 * unloadAdUnit
	 *
	 */
	VPAIDHTML5Client.prototype.unloadAdUnit = function unloadAdUnit() {
	    $unloadPreviousAdUnit.call(this);
	};

	/**
	 * getID will return the unique id
	 *
	 * @return {string}
	 */
	VPAIDHTML5Client.prototype.getID = function () {
	    return this._id;
	};


	/**
	 * $removeEl
	 *
	 * @param {string} key
	 */
	function $removeEl(key) {
	    var el = this[key];
	    if (el) {
	        el.remove();
	        delete this[key];
	    }
	}

	function $adDestroyed() {
	    $removeAdElements.call(this);
	    delete this._adUnit;
	}

	function $unloadPreviousAdUnit() {
	    $removeAdElements.call(this);
	    $destroyAdUnit.call(this);
	}

	function $removeAdElements() {
	    $removeEl.call(this, '_frame');
	    $destroyLoadListener.call(this);
	}

	/**
	 * $destroyLoadListener
	 *
	 */
	function $destroyLoadListener() {
	    if (this._onLoad) {
	        window.removeEventListener('message', this._onLoad);
	        utils.clearCallbackTimeout(this._onLoad);
	        delete this._onLoad;
	    }
	}


	function $destroyAdUnit() {
	    if (this._adUnit) {
	        this._adUnit.stopAd();
	        delete this._adUnit;
	    }
	}

	/**
	 * $throwIfDestroyed
	 *
	 */
	function $throwIfDestroyed() {
	    if (this._destroyed) {
	        throw new Error ('VPAIDHTML5Client already destroyed!');
	    }
	}

	function getOrigin() {
	    if( window.location.origin ) {
	        return window.location.origin;
	    }
	    else {
	        return window.location.protocol + "//" +
	            window.location.hostname +
	            (window.location.port ? ':' + window.location.port: '');
	    }
	}

	module.exports = VPAIDHTML5Client;


	},{"./VPAIDAdUnit":2,"./utils":5}],4:[function(require,module,exports){
	'use strict';

	function Subscriber() {
	    this._subscribers = {};
	}

	Subscriber.prototype.subscribe = function subscribe(handler, eventName, context) {
	    if (!this.isHandlerAttached(handler, eventName)) {
	        this.get(eventName).push({handler: handler, context: context, eventName: eventName});
	    }
	};

	Subscriber.prototype.unsubscribe = function unsubscribe(handler, eventName) {
	    this._subscribers[eventName] = this.get(eventName).filter(function (subscriber) {
	        return handler !== subscriber.handler;
	    });
	};

	Subscriber.prototype.unsubscribeAll = function unsubscribeAll() {
	    this._subscribers = {};
	};

	Subscriber.prototype.trigger = function(eventName, data) {
	    var that = this;
	    var subscribers = this.get(eventName)
	        .concat(this.get('*'));

	    subscribers.forEach(function (subscriber) {
	        setTimeout(function () {
	            if (that.isHandlerAttached(subscriber.handler, subscriber.eventName)) {
	                subscriber.handler.call(subscriber.context, data);
	            }
	        }, 0);
	    });
	};

	Subscriber.prototype.triggerSync = function(eventName, data) {
	    var subscribers = this.get(eventName)
	        .concat(this.get('*'));

	    subscribers.forEach(function (subscriber) {
	        subscriber.handler.call(subscriber.context, data);
	    });
	};

	Subscriber.prototype.get = function get(eventName) {
	    if (!this._subscribers[eventName]) {
	        this._subscribers[eventName] = [];
	    }
	    return this._subscribers[eventName];
	};

	Subscriber.prototype.isHandlerAttached = function isHandlerAttached(handler, eventName) {
	    return this.get(eventName).some(function(subscriber) {
	        return handler === subscriber.handler;
	    })
	};

	module.exports = Subscriber;


	},{}],5:[function(require,module,exports){
	'use strict';

	/**
	 * noop a empty function
	 */
	function noop() {}

	/**
	 * validate if is not validate will return an Error with the message
	 *
	 * @param {boolean} isValid
	 * @param {string} message
	 */
	function validate(isValid, message) {
	    return isValid ? null : new Error(message);
	}

	var timeouts = {};
	/**
	 * clearCallbackTimeout
	 *
	 * @param {function} func handler to remove
	 */
	function clearCallbackTimeout(func) {
	    var timeout = timeouts[func];
	    if (timeout) {
	        clearTimeout(timeout);
	        delete timeouts[func];
	    }
	}

	/**
	 * callbackTimeout if the onSuccess is not called and returns true in the timelimit then onTimeout will be called
	 *
	 * @param {number} timer
	 * @param {function} onSuccess
	 * @param {function} onTimeout
	 */
	function callbackTimeout(timer, onSuccess, onTimeout) {
	    var callback, timeout;

	    timeout = setTimeout(function () {
	        onSuccess = noop;
	        delete timeout[callback];
	        onTimeout();
	    }, timer);

	    callback = function () {
	        // TODO avoid leaking arguments
	        // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
	        if (onSuccess.apply(this, arguments)) {
	            clearCallbackTimeout(callback);
	        }
	    };

	    timeouts[callback] = timeout;

	    return callback;
	}


	/**
	 * createElementInEl
	 *
	 * @param {HTMLElement} parent
	 * @param {string} tagName
	 * @param {string} id
	 */
	function createElementInEl(parent, tagName, id) {
	    var nEl = document.createElement(tagName);
	    if (id) nEl.id = id;
	    parent.appendChild(nEl);
	    return nEl;
	}

	/**
	 * createIframeWithContent
	 *
	 * @param {HTMLElement} parent
	 * @param {string} template simple template using {{var}}
	 * @param {object} data
	 */
	function createIframeWithContent(parent, template, data) {
	    var iframe = createIframe(parent, null, data.zIndex);
	    if (!setIframeContent(iframe, simpleTemplate(template, data))) return;
	    return iframe;
	}

	/**
	 * createIframe
	 *
	 * @param {HTMLElement} parent
	 * @param {string} url
	 */
	function createIframe(parent, url, zIndex) {
	    var nEl = document.createElement('iframe');
	    nEl.src = url || 'about:blank';
	    nEl.marginWidth = '0';
	    nEl.marginHeight = '0';
	    nEl.frameBorder = '0';
	    nEl.width = '100%';
	    nEl.height = '100%';
	    setFullSizeStyle(nEl);

	    if(zIndex){
	        nEl.style.zIndex = zIndex;
	    }

	    nEl.setAttribute('SCROLLING','NO');
	    parent.innerHTML = '';
	    parent.appendChild(nEl);
	    return nEl;
	}

	function setFullSizeStyle(element) {
	    element.style.position = 'absolute';
	    element.style.left = '0';
	    element.style.top = '0';
	    element.style.margin = '0px';
	    element.style.padding = '0px';
	    element.style.border = 'none';
	    element.style.width = '100%';
	    element.style.height = '100%';
	}

	/**
	 * simpleTemplate
	 *
	 * @param {string} template
	 * @param {object} data
	 */
	function simpleTemplate(template, data) {
	    Object.keys(data).forEach(function (key) {
	        var value = (typeof value === 'object') ? JSON.stringify(data[key]) : data[key];
	        template = template.replace(new RegExp('{{' + key + '}}', 'g'), value);
	    });
	    return template;
	}

	/**
	 * setIframeContent
	 *
	 * @param {HTMLIframeElement} iframeEl
	 * @param content
	 */
	function setIframeContent(iframeEl, content) {
	    var iframeDoc = iframeEl.contentWindow && iframeEl.contentWindow.document;
	    if (!iframeDoc) return false;

	    iframeDoc.write(content);

	    return true;
	}


	/**
	 * extend object with keys from another object
	 *
	 * @param {object} toExtend
	 * @param {object} fromSource
	 */
	function extend(toExtend, fromSource) {
	    Object.keys(fromSource).forEach(function(key) {
	        toExtend[key] = fromSource[key];
	    });
	    return toExtend;
	}


	/**
	 * unique will create a unique string everytime is called, sequentially and prefixed
	 *
	 * @param {string} prefix
	 */
	function unique(prefix) {
	    var count = -1;
	    return function () {
	        return prefix + '_' + (++count);
	    };
	}

	module.exports = {
	    noop: noop,
	    validate: validate,
	    clearCallbackTimeout: clearCallbackTimeout,
	    callbackTimeout: callbackTimeout,
	    createElementInEl: createElementInEl,
	    createIframeWithContent: createIframeWithContent,
	    createIframe: createIframe,
	    setFullSizeStyle: setFullSizeStyle,
	    simpleTemplate: simpleTemplate,
	    setIframeContent: setIframeContent,
	    extend: extend,
	    unique: unique
	};


	},{}],6:[function(require,module,exports){
	'use strict';

	/**
	 * Inner helper class that deals with the logic of the icon renderring.
	 *
	 * @param player {object} instance of the player that will play the ad.
	 *
	 * @constructor
	 */

	var VASTError = require('../vast/VASTError');

	var async = require('../../utils/async');
	var playerUtils = require('../../utils/playerUtils');
	var utilities = require('../../utils/utilityFunctions');

	function IconIntegrator(player) {
	  if (!(this instanceof IconIntegrator)) {
	    return new IconIntegrator(player);
	  }

	  this.player = player;
	  this.icons = [];
	  this.controlBarTimer = null;
	  this.cbHidden;
	}

	IconIntegrator.prototype.renderIcons = function renderIcons(icons, callback) {
	  var that = this;
	  callback = callback || utilities.noop;

	  if (!Array.isArray(icons) || icons.length === 0) {
	    return callback(new VASTError('On IconIntegrator, missing required icon array'));
	  }

	  async.waterfall([
	    function (next) {
	      next(null, icons);
	    },
	    this._createIcons.bind(this),
	    this._setupEvents.bind(this),
	    this._renderIcons.bind(this)
	  ], function (error, response) {
	    if (error && response) {
	      that._trackError(error, response);
	    }
	    callback(error, response);
	  });
	};

	IconIntegrator.prototype._createIcons = function createIcons(icons, callback) {
	  //var playerWidth = dom.getDimension(this.player.el()).width;
	  //var playerHeight = dom.getDimension(this.player.el()).height;
	  var that = this;

	  for (var i = 0; i < icons.length; i++) {
	    var iconObj = {};
	    iconObj.icon = icons[i];
	    // make sure we only one icon per program
	    var idx = getIconByProgram(iconObj.icon.program);
	    if (idx >= 0) {
	      this.icons.splice(idx, 1);
	    }
	    iconObj.content = getContent(iconObj.icon);
	    if (iconObj.content) {
	      this.icons.push(iconObj);
	    }
	  }

	  if (this.icons.length > 0) {
	    callback(null);
	  }
	  else {
	    callback(new VASTError("Could not create AdIcon content", 900));
	  }
	  return;

	  /*** Local Functions ***/
	  function getContent(icon) {
	    var content = null;
	    if (icon.staticResource) {
	      var imageTypes = ["image/gif", "image/jpeg", "image/png"];
	      if (imageTypes.indexOf(icon.creativeType)) {
	        content = "<img src='" + icon.staticResource + "' width='" + icon.width + "' height='" + icon.height + "'>";
	      }
	    }
	    /*else if (icon.htmlResource) {
	      // to do ...
	    }
	    else if (icon.iframeResource) {
	      // to do ...
	    }*/
	    return content;
	  }

	  function getIconByProgram(program) {
	    for (var i = 0; i < that.icons.length; i++) {
	      if (that.icons[i].icon.program === program) {
	        return i;
	      }
	    }
	    return -1;
	  }
	};

	IconIntegrator.prototype._setupEvents = function setupEvents(callback) {
	  var player = this.player;
	  var that = this;

	  playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel', 'vast.adSkip', 'adStop'], function(){
	    if (that.icons.length > 0) {
	      if (that.controlBarTimer) {
	        clearInterval(that.controlBarTimer);
	        that.controlBarTimer = null;
	      }
	      for (var i = 0; i < that.icons.length; i++) {
	        var icon = that.icons[i];
	        if (icon.div) {
	          player.el().removeChild(icon.div);
	        }
	      }
	      that.icons = [];
	    }
	  });
	  
	  return callback(null);
	};

	IconIntegrator.prototype._renderIcons = function renderIcons() {
	  var player = this.player;
	  var that = this;

	  for (var i = 0; i < this.icons.length; i++) {
	    var icon = this.icons[i];

	    //position by offset
	    var xPosition = "left";//or right
	    var xPositionOffset = 0;
	    var yPosition = "top";//or bottom
	    var yPositionOffset = 0;
	    var topMargin = 0;
	    var bottomMargin = 0;   // maybe control bar height

	    if (icon && icon.icon.xPosition === "left") {
	        xPosition = "left";
	        xPositionOffset = 0;
	    }
	    if (icon && icon.icon.xPosition === "right") {
	        xPosition = "right";
	        xPositionOffset = 0;
	    }
	    if (icon && Number(icon.icon.xPosition) >= 0) {
	        xPosition = "left";
	        xPositionOffset = Number(icon.xPosition);
	    }
	    if (icon && icon.icon.yPosition === "bottom") {
	        yPosition = "bottom";
	        yPositionOffset = 0;
	        yPositionOffset = yPositionOffset + bottomMargin;
	    }
	    if (icon && icon.icon.yPosition === "top") {
	        yPosition = "top";
	        yPositionOffset = 0;
	        yPositionOffset = yPositionOffset + topMargin;
	    }
	    if (icon && Number(icon.icon.yPosition) >= 0) {
	        yPosition = "top";
	        yPositionOffset = Number(icon.icon.yPosition);
	        yPositionOffset = yPositionOffset + topMargin;
	    }

	    var displayIcon = player.el().ownerDocument.createElement('div');
	    player.el().appendChild(displayIcon);

	    displayIcon.setAttribute("name", "adicon");
	    displayIcon.id = "adicon_" + icon.icon.program;
	    displayIcon.innerHTML = icon.content;
	    displayIcon.style.position = "absolute";
	    displayIcon.style[xPosition] = xPositionOffset + "px";
	    displayIcon.style[yPosition] = yPositionOffset + "px";
	    displayIcon.style.zIndex = 2147483647; //top most of 32bit
	    displayIcon.style.display = "none";
	    icon.origY = yPositionOffset;
	  
	    //set width,height of div element 
	    displayIcon.style.width = icon.width + "px";
	    displayIcon.style.height = icon.height + "px";

	    icon.div = displayIcon;

	    if (icon.icon.iconClickThrough) {
	      icon.div.style.cursor = "pointer";
	      icon.div.addEventListener('click', handleClick(icon));
	    }

	    startIcon(icon, yPosition);
	  }

	  if (this.icons.length > 0) {
	    this.controlBarTimer = setInterval(function() {
	      var compStyle = window.getComputedStyle(that.player.controlBar.el(), null);
	      var cbHiddenCur = compStyle.backfaceVisibility === 'hidden' || compStyle.transform != 'none';
	      if (cbHiddenCur != that.cbHidden) {
	        that.cbHidden = cbHiddenCur;
	        var cbHeight = cbHiddenCur ? 0 : that.player.controlBar.el().offsetHeight;
	        for (var k = 0; k < that.icons.length; k++) {
	          var ic = that.icons[k];
	          if (ic.div && ic.div.style.display ==='block') {
	            if (cbHeight > 0) {
	              // control bar visible
	              if (elementsIntersected(ic.div, that.player.controlBar.el())) {
	                if (ic.div.style.top && ic.div.style.top.length > 0) {
	                  var yPos = ic.origY - cbHeight;
	                  if (yPos < 0) {
	                    yPos = 0;
	                  }
	                  ic.div.style.top = yPos + 'px';
	                }
	                else {
	                  ic.div.style.bottom = (ic.origY + cbHeight) + 'px';
	                }
	                adgustIconsPosition(ic, cbHeight, that, 1);                  
	              }
	            }
	            else {
	              if (ic.div.style.top && ic.div.style.top.length > 0) {
	                ic.div.style.top = ic.origY + 'px';
	              }
	              else {
	                ic.div.style.bottom = (ic.origY + cbHeight) + 'px';
	              }
	            }
	          }
	        }
	      }
	    }, utilities.isIE11() ? 100 : 500);
	  }

	  /**** local functions ******/
	  function adgustIconsPosition(ic, cbHeight, that, level) {
	    for (var i = 0; i < that.icons.length; i++) {
	      var icon = that.icons[i];
	      if (icon.div.style.display === 'block' && icon.div != ic.div) {
	        if (elementsIntersected(ic.div, icon.div)) {
	          if (icon.div.style.top && icon.div.style.top.length > 0) {
	            var yPos = icon.origY - cbHeight;
	            if (yPos < 0) {
	              yPos = 0;
	            }
	            icon.div.style.top = yPos + 'px';
	          }
	          else {
	            icon.div.style.bottom = (icon.origY + cbHeight) + 'px';
	          }
	          // protection against infinite recursive
	          level++;
	          if (level < 5) {
	            adgustIconsPosition(icon, cbHeight, that, level);    
	          }              
	        }
	      }
	    }
	  }

	  function elementsIntersected(div1, div2) {
	    var collide = function(el1, el2) {
	      var rect1 = el1.getBoundingClientRect();
	      var rect2 = el2.getBoundingClientRect();
	  
	      return !(
	        rect1.top > rect2.bottom ||
	        rect1.right < rect2.left ||
	        rect1.bottom < rect2.top ||
	        rect1.left > rect2.right
	      );
	    };
	    var inside = function(el1, el2) {
	      var rect1 = el1.getBoundingClientRect();
	      var rect2 = el2.getBoundingClientRect();
	  
	      return (
	        ((rect2.top <= rect1.top) && (rect1.top <= rect2.bottom)) &&
	        ((rect2.top <= rect1.bottom) && (rect1.bottom <= rect2.bottom)) &&
	        ((rect2.left <= rect1.left) && (rect1.left <= rect2.right)) &&
	        ((rect2.left <= rect1.right) && (rect1.right <= rect2.right))
	      );
	    };
	    return collide(div1, div2) || inside(div1, div2) || inside(div2, div1);
	  }

	  function trackUrls(urls) {
	    urls.forEach(function (src) {
	      var img = new Image();
	      img.src = src;
	    });
	  }

	  function handleClick(icon) {
	    return function() {
	      icon.div.removeEventListener('click', handleClick(icon));
	      trackUrls(icon.icon.iconClickTrackings);
	      player.pause();
	      window.open(icon.icon.iconClickThrough, '_blank');
	    };
	  }

	  function startIcon(icon, yPosition) {
	    var offset = icon.icon.offset && icon.icon.offset > 0 ? icon.icon.offset : 0;
	    setTimeout(function() {
	      icon.div.style.display = 'block';
	      trackUrls(icon.icon.iconViewTrackings);

	      for (var j = 0; j < that.icons.length; j++) {
	        if (that.icons[j].div && that.icons[j].div != icon.div) {
	          if (elementsIntersected(that.icons[j].div, icon.div)) {
	            var rect1 = that.icons[j].div.getBoundingClientRect();
	            if (yPosition === 'top') {
	              icon.div.style.top = (that.icons[j].div.offsetTop + that.icons[j].div.offsetHeight + 1) + "px";
	              icon.origY = that.icons[j].div.offsetTop + that.icons[j].div.offsetHeight + 1;
	            }
	            else {
	              var rect2 = that.player.el().getBoundingClientRect();
	              icon.div.style.bottom = (rect2.height + rect2.top - rect1.top + 1) + "px";
	              icon.origY = rect2.height + rect2.top - rect1.top + 1;
	            }
	          }
	        }
	      }
	  
	      if (icon.icon.duration && icon.icon.duration > 0) {
	        var duration = icon.icon.duration;
	        setTimeout(function() {
	          var idx = that.icons.indexOf(icon);
	          if (idx >= 0) {
	            player.el().removeChild(icon.div);
	            that.icons.splice(idx, 1);
	          }
	        }, duration);
	      }
	    }, offset);
	  }
	};

	module.exports = IconIntegrator;
	},{"../../utils/async":38,"../../utils/playerUtils":43,"../../utils/utilityFunctions":45,"../vast/VASTError":19}],7:[function(require,module,exports){
	'use strict';

	var InLine = require('./InLine');
	var Wrapper = require('./Wrapper');

	function Ad(adJTree) {
	  if (!(this instanceof Ad)) {
	    return new Ad(adJTree);
	  }
	  this.initialize(adJTree);
	}

	Ad.prototype.initialize = function(adJTree) {
	  this.id = adJTree.attr('id');
	  this.sequence = adJTree.attr('sequence');
	  if (window.mol_vastVersion === 4) {
		  this.conditionalAd = adJTree.attr('conditionalAd');
	  }

	  if(adJTree.inLine) {
	    this.inLine = new InLine(adJTree.inLine);
	  }

	  if(adJTree.wrapper){
	    this.wrapper = new Wrapper(adJTree.wrapper);
	  }
	};

	module.exports = Ad;
	},{"./InLine":12,"./Wrapper":26}],8:[function(require,module,exports){
	'use strict';

	var xml = require('../../utils/xml');
	var utilities = require('../../utils/utilityFunctions');

	function Category(categoryJTree) {
		  if(!(this instanceof Category)) {
		    return new Category(categoryJTree);
		  }

		  this.authority = categoryJTree.attr('authority');
		  this.category = xml.keyValue(categoryJTree);
	}

	Category.parseCategories = function parseCategoties(categoriesJTree) {
		  var categories = [];
		  var categoriesData;
		  if (categories) {
			  categoriesData = utilities.isArray(categoriesJTree) ? categoriesJTree : [categoriesJTree];
			  categoriesData.forEach(function (category) {
				  var cat = new Category(category);
				  if (cat.category && cat.category.length > 0 && cat.authority && cat.authority.length > 0) {
					  categories.push(new Category(category));
				  }
			  });
		  }
		  return categories;
	};

	module.exports = Category;

	},{"../../utils/utilityFunctions":45,"../../utils/xml":46}],9:[function(require,module,exports){
	'use strict';

	var TrackingEvent = require('./TrackingEvent');

	var utilities = require('../../utils/utilityFunctions');

	var xml = require('../../utils/xml');

	var logger = require ('../../utils/consoleLogger');


	function Companion(companionJTree) {
	  if (!(this instanceof Companion)) {
	    return new Companion(companionJTree);
	  }

	  logger.info ("<Companion> found companion ad");
	  logger.debug ("<Companion>  companionJTree:", companionJTree);

	  //Required Elements
	  this.creativeType = xml.attr(companionJTree.staticResource, 'creativeType');
	  this.staticResource = xml.keyValue(companionJTree.staticResource);

	  logger.info ("<Companion>  creativeType: " + this.creativeType);
	  logger.info ("<Companion>  staticResource: " + this.staticResource);

	  // Weird bug when the JXON tree is built it doesn't handle casing properly in this situation...
	  var htmlResource = null;
	  if (xml.keyValue(companionJTree.HTMLResource)) {
	    htmlResource = xml.keyValue(companionJTree.HTMLResource);
	  } else if (xml.keyValue(companionJTree.hTMLResource)) {
	    htmlResource = xml.keyValue(companionJTree.hTMLResource);
	  }

	  if (htmlResource !== null)
	  {
	    logger.info ("<Companion> found html resource", htmlResource);
	  }

	  this.htmlResource = htmlResource;

	  var iframeResource = null;
	  if (xml.keyValue(companionJTree.IFrameResource)) {
	    iframeResource = xml.keyValue(companionJTree.IFrameResource);
	  } else if (xml.keyValue(companionJTree.iFrameresource)) {
	    iframeResource = xml.keyValue(companionJTree.iFrameresource);
	  }

	  if (iframeResource !== null)
	  {
	    logger.info ("<Companion> found iframe resource", iframeResource);
	  }

	  this.iframeResource = iframeResource;

	  //Optional fields
	  this.id = xml.attr(companionJTree, 'id');
	  this.width = xml.attr(companionJTree, 'width');
	  this.height = xml.attr(companionJTree, 'height');
	  this.assetWidth = xml.attr(companionJTree, 'assetWidth');
	  this.assetHeight = xml.attr(companionJTree, 'assetHeight');
	  this.expandedWidth = xml.attr(companionJTree, 'expandedWidth');
	  this.expandedHeight = xml.attr(companionJTree, 'expandedHeight');
	  this.apiFramework = xml.attr(companionJTree, 'apiFramework');
	  this.adSlotID = xml.attr(companionJTree, 'adSlotID');
	  this.companionClickThrough = xml.keyValue(companionJTree.companionClickThrough);
	  this.trackingEvents = parseTrackingEvents(companionJTree.trackingEvents && companionJTree.trackingEvents.tracking);
	  
	  if (window.mol_vastVersion === 4) {
		  this.pxratio = xml.attr(companionJTree, 'pxratio');
	  }

	  logger.info ("<Companion>  companionClickThrough: " + this.companionClickThrough);


	  /*** Local functions ***/
	  function parseTrackingEvents(trackingEvents) {
	    var trackings = [];
	    if (utilities.isDefined(trackingEvents)) {
	      trackingEvents = utilities.isArray(trackingEvents) ? trackingEvents : [trackingEvents];
	      trackingEvents.forEach(function (trackingData) {
	        trackings.push(new TrackingEvent(trackingData));
	      });
	    }
	    return trackings;
	  }
	}

	module.exports = Companion;
	},{"../../utils/consoleLogger":39,"../../utils/utilityFunctions":45,"../../utils/xml":46,"./TrackingEvent":16}],10:[function(require,module,exports){
	'use strict';

	var Linear = require('./Linear');
	var Companion = require('./Companion');
	var UniversalAdId = require('./UniversalAdId');
	var utilities = require('../../utils/utilityFunctions');

	function Creative(creativeJTree) {
	  if(!(this instanceof Creative)) {
	    return new Creative(creativeJTree);
	  }

	  this.id = creativeJTree.attr('id');
	  this.sequence = creativeJTree.attr('sequence');
	  this.adId = creativeJTree.attr('adId');
	  this.apiFramework = creativeJTree.attr('apiFramework');

	  if(creativeJTree.linear) {
	    this.linear = new Linear(creativeJTree.linear);
	  }

	  if (creativeJTree.companionAds) {
	    var companions = [];
	    var companionAds = creativeJTree.companionAds && creativeJTree.companionAds.companion;
	    if (utilities.isDefined(companionAds)) {
	      companionAds = utilities.isArray(companionAds) ? companionAds : [companionAds];
	      companionAds.forEach(function (companionData) {
	        companions.push(new Companion(companionData));
	      });
	    }
	    this.companionAds = companions;
	  }

	  if (window.mol_vastVersion === 4) {
		  this.universalAdId = new UniversalAdId(creativeJTree.universalAdId);
	  }
	}

	/**
	 * Returns true if the browser supports at the creative.
	 */
	Creative.prototype.isSupported = function(){
	  if(this.linear) {
	    return this.linear.isSupported();
	  }

	  return true;
	};

	Creative.parseCreatives = function parseCreatives(creativesJTree) {
	  var creatives = [];
	  var creativesData;
	  if (utilities.isDefined(creativesJTree) && utilities.isDefined(creativesJTree.creative)) {
	    creativesData = utilities.isArray(creativesJTree.creative) ? creativesJTree.creative : [creativesJTree.creative];
	    creativesData.forEach(function (creative) {
	      creatives.push(new Creative(creative));
	    });
	  }
	  return creatives;
	};

	module.exports = Creative;

	},{"../../utils/utilityFunctions":45,"./Companion":9,"./Linear":14,"./UniversalAdId":17}],11:[function(require,module,exports){
	'use strict';

	var utilities = require('../../utils/utilityFunctions');
	var xml = require('../../utils/xml');
	var parsers = require('./parsers');

	//var vastUtil = require('./vastUtil');

	var attributesList = [
	  'program',
	  'width',
	  'height',
	  'xPosition',
	  'yPosition',
	  'duration',
	  'offset',
	  'apiFramework',
	  'pxratio'
	];

	function Icon(iconJTree) {
	  if (!(this instanceof Icon)) {
	    return new Icon(iconJTree);
	  }

	  //Attributes
	  for(var x=0; x<attributesList.length; x++) {
	    var attribute = attributesList[x];
	    this[attribute] = iconJTree.attr(attribute);
	  }
	  if (this.duration) {
	    this.duration = parsers.duration(this.duration);
	  }
	  if (this.offset) {
	    this.offset = parsers.duration(this.offset);
	  }

	  //Required Elements
	  this.creativeType = xml.attr(iconJTree.staticResource, 'creativeType');
	  this.staticResource = xml.keyValue(iconJTree.staticResource);

	  var htmlResource = null;
	  if (xml.keyValue(iconJTree.HTMLResource)) {
	    htmlResource = xml.keyValue(iconJTree.HTMLResource);
	  } else if (xml.keyValue(iconJTree.hTMLResource)) {
	    htmlResource = xml.keyValue(iconJTree.hTMLResource);
	  }

	  this.htmlResource = htmlResource;

	  var iframeResource = null;
	  if (xml.keyValue(iconJTree.IFrameResource)) {
	    iframeResource = xml.keyValue(iconJTree.IFrameResource);
	  } else if (xml.keyValue(iconJTree.iFrameresource)) {
	    iframeResource = xml.keyValue(iconJTree.iFrameresource);
	  }

	  this.iframeResource = iframeResource;

	  this.iconViewTrackings = parseTrackings(iconJTree.iconViewTracking);

	  if (iconJTree.iconClicks) {
	    this.iconClickThrough = xml.keyValue(iconJTree.iconClicks.iconClickThrough);
	    this.iconClickTrackings = parseTrackings(iconJTree.iconClicks.iconClickTracking);
	  }

	  // Local functions
	  function parseTrackings(trackings) {
	    if (trackings) {
	      trackings = utilities.isArray(trackings) ? trackings : [trackings];
	      return utilities.transformArray(trackings, function (trackings) {
	        if (utilities.isNotEmptyString(trackings.keyValue)) {
	          return trackings.keyValue;
	        }
	        return undefined;
	      });
	    }
	    return [];
	  }
	}

	module.exports = Icon;

	},{"../../utils/utilityFunctions":45,"../../utils/xml":46,"./parsers":27}],12:[function(require,module,exports){
	'use strict';

	var vastUtil = require('./vastUtil');
	var Creative = require('./Creative');
	var Category = require('./Category');
	var ViewableImpression = require('./ViewableImpression');
	var Verification = require('./Verification');

	var utilities = require('../../utils/utilityFunctions');
	var xml = require('../../utils/xml');

	function InLine(inlineJTree) {
	  if (!(this instanceof InLine)) {
	    return new InLine(inlineJTree);
	  }

	  //Required Fields
	  this.adTitle = xml.keyValue(inlineJTree.adTitle);
	  this.adSystem = xml.keyValue(inlineJTree.adSystem);
	  this.impressions = vastUtil.parseImpressions(inlineJTree.impression);
	  this.creatives = Creative.parseCreatives(inlineJTree.creatives);

	  //Optional Fields
	  this.description = xml.keyValue(inlineJTree.description);
	  this.advertiser = xml.keyValue(inlineJTree.advertiser);
	  this.surveys = parseSurveys(inlineJTree.survey);
	  //this.error = xml.keyValue(inlineJTree.error);
	  this.errors = vastUtil.parseErrors(inlineJTree.error);
	  this.pricing = xml.keyValue(inlineJTree.pricing);
	  this.extensions = inlineJTree.extensions;
	  if (this.extensions) {
		  this.moat = parseMoat(this.extensions);
	  }
	  if (window.mol_vastVersion === 4) {
		  if (inlineJTree.category) {
			  this.categories = Category.parseCategories(inlineJTree.category);
		  }
		  if (inlineJTree.viewableImpression) {
			  this.viewableImpression = new ViewableImpression(inlineJTree.viewableImpression);
		  }
		  if (inlineJTree.adVerifications) {
			  this.adVerifications = Verification.parseAdVerifications(inlineJTree.adVerifications);
		  }
	  }

	  /*** Local Functions ***/
	  function parseSurveys(inlineSurveys) {
	    if (inlineSurveys) {
	      return utilities.transformArray(utilities.isArray(inlineSurveys) ? inlineSurveys : [inlineSurveys], function (survey) {
	        if(utilities.isNotEmptyString(survey.keyValue)){
	          return {
	            uri: survey.keyValue,
	            type: survey.attr('type')
	          };
	        }

	        return undefined;
	      });
	    }
	    return [];
	  }

	  function parseMoat(extensions) {
		  var getMoatConfigData = function(arrExtentions) {
			  for (var i = 0; i < arrExtentions.length; i++) {
				  var extension = arrExtentions[i].extension;
				  if (extension && extension.moat) {
					  var moat = {};
					  var value = xml.keyValue(extension.moat);
					  var arr = value.split(';');
					  for (var j = 0; j < arr.length; j++) {
						  var params = arr[j].split('=');
						  if (params && params.length === 2) {
							  moat[params[0]] = params[1];
						  }
					  }
					  return moat;
				  }
			  }
			  return undefined;
		  };
		  if (extensions) {
			  return getMoatConfigData(utilities.isArray(extensions) ? extensions : [extensions]);
		  }
		  return undefined;
	  }
	}


	/**
	 * Returns true if the browser supports all the creatives.
	 */
	InLine.prototype.isSupported = function(){
	  var i,len;

	  if(this.creatives.length === 0) {
	    return false;
	  }

	  for(i = 0, len = this.creatives.length; i< len; i+=1){
	    if(!this.creatives[i].isSupported()){
	      return false;
	    }
	  }
	  return true;
	};

	module.exports = InLine;

	},{"../../utils/utilityFunctions":45,"../../utils/xml":46,"./Category":8,"./Creative":10,"./Verification":23,"./ViewableImpression":25,"./vastUtil":28}],13:[function(require,module,exports){
	'use strict';

	var xml = require('../../utils/xml');
	var utilities = require('../../utils/utilityFunctions');

	function InteractiveCreativeFile(interactiveCreativeFileJTree) {
	  if(!(this instanceof InteractiveCreativeFile)) {
	    return new InteractiveCreativeFile(interactiveCreativeFileJTree);
	  }

	  this.type = interactiveCreativeFileJTree.attr('type');
	  this.apiFramework = interactiveCreativeFileJTree.attr('apiFramework');
	  this.src = xml.keyValue(interactiveCreativeFileJTree);
	}

	InteractiveCreativeFile.parseInteractiveCreativeFiles = function parseInteractiveCreativeFiles(icfsJTree) {
	  var interactiveCreativeFiles = [];
	  var interactiveCreativeFilesData;
	  if (utilities.isDefined(icfsJTree)) {
		  interactiveCreativeFilesData = utilities.isArray(icfsJTree) ? icfsJTree : [icfsJTree];
		  interactiveCreativeFilesData.forEach(function (fileJTree) {
			  interactiveCreativeFiles.push(new InteractiveCreativeFile(fileJTree));
	    });
	  }
	  return interactiveCreativeFiles;
	};

	module.exports = InteractiveCreativeFile;

	},{"../../utils/utilityFunctions":45,"../../utils/xml":46}],14:[function(require,module,exports){
	'use strict';

	var TrackingEvent = require('./TrackingEvent');
	var MediaFile = require('./MediaFile');
	var VideoClicks = require('./VideoClicks');
	var InteractiveCreativeFile = require('./InteractiveCreativeFile');
	var Icon = require('./Icon');

	var utilities = require('../../utils/utilityFunctions');
	var parsers = require('./parsers');

	var xml = require('../../utils/xml');


	function Linear(linearJTree) {
	  if (!(this instanceof Linear)) {
	    return new Linear(linearJTree);
	  }

	  //Required Elements
	  this.duration = parsers.duration(xml.keyValue(linearJTree.duration));
	  this.mediaFiles = parseMediaFiles(linearJTree.mediaFiles && linearJTree.mediaFiles.mediaFile);

	  //Optional fields
	  this.trackingEvents = parseTrackingEvents(linearJTree.trackingEvents && linearJTree.trackingEvents.tracking, this.duration);
	  this.skipoffset = parsers.offset(xml.attr(linearJTree, 'skipoffset'), this.duration);
	  
	  // adjust skipoffset to publisher settings
	  if (this.duration && window._molSettings && window._molSettings.skippable) {
		  if (window._molSettings.skippable.enabled) {
			 if (this.duration >= window._molSettings.skippable.videoThreshold) {
				 this.skipoffset = window._molSettings.skippable.videoOffset;
			 }
			 else {
				 this.skipoffset = null; 
			 }
		  }
		  else {
			  this.skipoffset = null; 
		  }
	  }

	  if (linearJTree.videoClicks) {
	    this.videoClicks = new VideoClicks(linearJTree.videoClicks);
	  }

	  if(linearJTree.adParameters) {
	    this.adParameters = xml.keyValue(linearJTree.adParameters);

	    if(xml.attr(linearJTree.adParameters, 'xmlEncoded')) {
	      this.adParameters = xml.decode(this.adParameters);
	    }
	  }
	  
	  if (window.mol_vastVersion === 4) {
		  if (linearJTree.mediaFiles && linearJTree.mediaFiles.mezzanine) {
			  this.mezzanine = xml.keyValue(linearJTree.mediaFiles.mezzanine);
		  }
		  if (linearJTree.mediaFiles && linearJTree.mediaFiles.interactiveCreativeFile) {
			  this.interactiveCreativeFiles = InteractiveCreativeFile.parseInteractiveCreativeFiles(linearJTree.mediaFiles.interactiveCreativeFile);
		  }
	  }

	  if (linearJTree.icons) {
	    this.icons = parseIcons(linearJTree.icons && linearJTree.icons.icon);
	  }

	  /*** Local functions ***/
	  function parseTrackingEvents(trackingEvents, duration) {
	    var trackings = [];
	    if (utilities.isDefined(trackingEvents)) {
	      trackingEvents = utilities.isArray(trackingEvents) ? trackingEvents : [trackingEvents];
	      trackingEvents.forEach(function (trackingData) {
	        trackings.push(new TrackingEvent(trackingData, duration));
	      });
	    }
	    return trackings;
	  }

	  function parseMediaFiles(mediaFilesJxonTree) {
	    var mediaFiles = [];
	    if (utilities.isDefined(mediaFilesJxonTree)) {
	      mediaFilesJxonTree = utilities.isArray(mediaFilesJxonTree) ? mediaFilesJxonTree : [mediaFilesJxonTree];

	      mediaFilesJxonTree.forEach(function (mfData) {
	        mediaFiles.push(new MediaFile(mfData));
	      });
	    }
	    return mediaFiles;
	  }

	  function parseIcons(iconsJxonTree) {
	    var icons = [];
	    if (utilities.isDefined(iconsJxonTree)) {
	      iconsJxonTree = utilities.isArray(iconsJxonTree) ? iconsJxonTree : [iconsJxonTree];

	      iconsJxonTree.forEach(function (iconData) {
	        icons.push(new Icon(iconData));
	      });
	    }
	    return icons;
	  }
	}

	/**
	 * Must return true if at least one of the MediaFiles' type is supported
	 */
	Linear.prototype.isSupported = function () {
	  var i, len;
	  for(i=0, len=this.mediaFiles.length; i<len; i+=1) {
	    if(this.mediaFiles[i].isSupported()) {
	      return true;
	    }
	  }

	  return false;
	};

	module.exports = Linear;

	},{"../../utils/utilityFunctions":45,"../../utils/xml":46,"./Icon":11,"./InteractiveCreativeFile":13,"./MediaFile":15,"./TrackingEvent":16,"./VideoClicks":24,"./parsers":27}],15:[function(require,module,exports){
	'use strict';

	var xml = require('../../utils/xml');
	var vastUtil = require('./vastUtil');

	var attributesList = [
	  //Required attributes
	  'delivery',
	  'type',
	  'width',
	  'height',
	  //Optional attributes
	  'codec',
	  'id',
	  'bitrate',
	  'minBitrate',
	  'maxBitrate',
	  'scalable',
	  'maintainAspectRatio',
	  'apiFramework'
	];

	function MediaFile(mediaFileJTree) {
	  if (!(this instanceof MediaFile)) {
	    return new MediaFile(mediaFileJTree);
	  }

	  //Required attributes
	  this.src = xml.keyValue(mediaFileJTree);

	  for(var x=0; x<attributesList.length; x++) {
	    var attribute = attributesList[x];
	    this[attribute] = mediaFileJTree.attr(attribute);
	  }
	}

	MediaFile.prototype.isSupported = function(){
	  if(vastUtil.isVPAID(this)) {
	    return !!vastUtil.findSupportedVPAIDTech(this.type);
	  }

	  if (this.type === 'video/x-flv') {
	    return false;
	  }

	  return true;
	};

	module.exports = MediaFile;

	},{"../../utils/xml":46,"./vastUtil":28}],16:[function(require,module,exports){
	'use strict';

	var parsers = require('./parsers');

	var xml = require('../../utils/xml');

	function TrackingEvent(trackingJTree, duration) {
	  if (!(this instanceof TrackingEvent)) {
	    return new TrackingEvent(trackingJTree, duration);
	  }

	  this.name = trackingJTree.attr('event');
	  this.uri = xml.keyValue(trackingJTree);

	  if('progress' === this.name) {
	    this.offset = parsers.offset(trackingJTree.attr('offset'), duration);
	  }
	}

	module.exports = TrackingEvent;
	},{"../../utils/xml":46,"./parsers":27}],17:[function(require,module,exports){
	'use strict';

	function UniversalAdId(universalAdIdJTree) {
		  if(!(this instanceof UniversalAdId)) {
		    return new UniversalAdId(universalAdIdJTree);
		  }

		  this.idRegistry = universalAdIdJTree.attr('idRegistry');
		  this.idValue = universalAdIdJTree.attr('idValue');
	}

	module.exports = UniversalAdId;

	},{}],18:[function(require,module,exports){
	'use strict';

	var Ad = require('./Ad');
	var VASTError = require('./VASTError');
	var VASTResponse = require('./VASTResponse');
	var vastUtil = require('./vastUtil');

	var async = require('../../utils/async');
	var http = require('../../utils/http').http;
	var utilities = require('../../utils/utilityFunctions');
	var xml = require('../../utils/xml');

	var logger = require ('../../utils/consoleLogger');

	function VASTClient(options) {
	  if (!(this instanceof VASTClient)) {
	    return new VASTClient(options);
	  }
	  var defaultOptions = {
	    WRAPPER_LIMIT: options && options.wrapperLimit && options.wrapperLimit > 0 ? options.wrapperLimit : 5
	  };

	  options = options || {};
	  this.settings = utilities.extend({}, options, defaultOptions);
	  this.errorURLMacros = [];
	}

	VASTClient.prototype.getVASTResponse = function getVASTResponse(adTagUrl, callback) {
	  var that = this;

	  var error = sanityCheck(adTagUrl, callback);
	  if (error) {
	    if (utilities.isFunction(callback)) {
	      return callback(error);
	    }
	    throw error;
	  }

	  async.waterfall([
	      this._getVASTAd.bind(this, adTagUrl),
	      buildVASTResponse
	    ],
	    callback);

	  /*** Local functions ***/
	  function buildVASTResponse(adsChain, cb) {
	    try {
	      var response = that._buildVASTResponse(adsChain);
	      cb(null, response);
	    } catch (e) {
	      cb(e);
	    }
	  }

	  function sanityCheck(adTagUrl, cb) {
	    if (!adTagUrl) {
	      return new VASTError('on VASTClient.getVASTResponse, missing ad tag URL');
	    }

	    if (!utilities.isFunction(cb)) {
	      return new VASTError('on VASTClient.getVASTResponse, missing callback function');
	    }
	  }
	};

	VASTClient.prototype._getVASTAd = function (adTagUrl, callback) {
	  var that = this;

	  getAdWaterfall(adTagUrl, function (error, vastTree) {
	    var waterfallAds = vastTree && utilities.isArray(vastTree.ads) ? vastTree.ads : null;
	    if (error) {
	      that._trackError(error, waterfallAds);
	      return callback(error, waterfallAds);
	    }
	    getAd(waterfallAds.shift(), [], waterfallHandler);

	    /*** Local functions ***/
	    function waterfallHandler(error, adChain) {
	      if (error) {
	        that._trackError(error, adChain);
	        if (waterfallAds.length > 0) {
	          getAd(waterfallAds.shift(),[], waterfallHandler);
	        } else {
	          callback(error, adChain);
	        }
	      } else {
	        callback(null, adChain);
	      }
	    }
	  });

	  /*** Local functions ***/
	  function getAdWaterfall(adTagUrl, callback) {
	    var requestVastXML = that._requestVASTXml.bind(that, adTagUrl);
	    async.waterfall([
	      requestVastXML,
	      buildVastWaterfall
	    ], callback);
	  }

	  function buildVastWaterfall(xmlStr, callback) {
	    var vastTree;
	    try {
	      vastTree = xml.toJXONTree(xmlStr);
	      logger.debug ("built JXONTree from VAST response:", vastTree);

	      if(utilities.isArray(vastTree.ad)) {
	        vastTree.ads = vastTree.ad;
	      } else if(vastTree.ad){
	        vastTree.ads = [vastTree.ad];
	      } else {
	        vastTree.ads = [];
	      }
	      callback(validateVASTTree(vastTree), vastTree);

	    } catch (e) {
	      callback(new VASTError("on VASTClient.getVASTAd.buildVastWaterfall, error parsing xml", 100), null);
	    }
	  }

	  function validateVASTTree(vastTree) {
	    var vastVersion = xml.attr(vastTree, 'version');

	    if (!vastTree.ad) {
	      return new VASTError('on VASTClient.getVASTAd.validateVASTTree, no Ad in VAST tree', 303);
	    }

	    //if (vastVersion && (vastVersion != 3 && vastVersion != 2)) {
	    if (vastVersion && (vastVersion != 3 && vastVersion != 2 && vastVersion != 4)) {
	      return new VASTError('on VASTClient.getVASTAd.validateVASTTree, not supported VAST version "' + vastVersion + '"', 102);
	    }
	    window.mol_vastVersion = vastVersion;

	    return null;
	  }

	  function getAd(adTagUrl, adChain, callback) {
	    if (adChain.length >= that.settings.WRAPPER_LIMIT) {
	      return callback(new VASTError("on VASTClient.getVASTAd.getAd, players wrapper limit reached (the limit is " + 
	        that.settings.WRAPPER_LIMIT + ")", 302), adChain);
	    }

	    async.waterfall([
	      function (next) {
	        if (utilities.isString(adTagUrl)) {
	          requestVASTAd(adTagUrl, next);
	        } else {
	          next(null, adTagUrl);
	        }
	      },
	      buildAd
	    ], function (error, ad) {
	      if (ad) {
	        adChain.push(ad);
	      }

	      if (error) {
	        return callback(error, adChain);
	      }

	      if (ad.wrapper) {
	        return getAd(ad.wrapper.VASTAdTagURI, adChain, callback);
	      }

	      return callback(null, adChain);
	    });
	  }

	  function buildAd(adJxonTree, callback) {
	    try {
	      var ad = new Ad(adJxonTree);
	      callback(validateAd(ad), ad);
	    } catch (e) {
	      callback(new VASTError('on VASTClient.getVASTAd.buildAd, error parsing xml', 100), null);
	    }
	  }

	  function validateAd(ad) {
	    var wrapper = ad.wrapper;
	    var inLine = ad.inLine;
	    var errMsgPrefix = 'on VASTClient.getVASTAd.validateAd, ';

	    if (inLine && wrapper) {
	      return new VASTError(errMsgPrefix +"InLine and Wrapper both found on the same Ad", 101);
	    }

	    if (!inLine && !wrapper) {
	      return new VASTError(errMsgPrefix + "nor wrapper nor inline elements found on the Ad", 101);
	    }

	    if (inLine && !inLine.isSupported()) {
	      return new VASTError(errMsgPrefix + "could not find MediaFile that is supported by this video player", 403);
	    }

	    if (wrapper && !wrapper.VASTAdTagURI) {
	      return new VASTError(errMsgPrefix + "missing 'VASTAdTagURI' in wrapper", 101);
	    }

	    return null;
	  }

	  function requestVASTAd(adTagUrl, callback) {
	    that._requestVASTXml(adTagUrl, function (error, xmlStr) {
	      if (error) {
	        return callback(error);
	      }
	      try {
	        var vastTree = xml.toJXONTree(xmlStr);
	        callback(validateVASTTree(vastTree), vastTree.ad);
	      } catch (e) {
	        callback(new VASTError("on VASTClient.getVASTAd.requestVASTAd, error parsing xml", 100));
	      }
	    });
	  }
	};

	VASTClient.prototype._requestVASTXml = function requestVASTXml(adTagUrl, callback) {
	  try {
	    if (utilities.isFunction(adTagUrl)) {
	      adTagUrl(requestHandler);
	    } else {
	      logger.info ("requesting adTagUrl: " + adTagUrl);
	      http.get(adTagUrl, requestHandler, {
	        withCredentials: true
	      });
	    }
	  } catch (e) {
	    callback(e);
	  }

	  /*** Local functions ***/
	  function requestHandler(error, response, status) {
	    if (error) {
	      var errMsg = utilities.isDefined(status) ?
	      "on VASTClient.requestVastXML, HTTP request error with status '" + status + "'" :
	        "on VASTClient.requestVastXML, Error getting the the VAST XML with he passed adTagXML fn";
	      return callback(new VASTError(errMsg, 301), null);
	    }

	    callback(null, response);
	  }
	};

	VASTClient.prototype._buildVASTResponse = function buildVASTResponse(adsChain) {
	  var response = new VASTResponse();
	  addAdsToResponse(response, adsChain);
	  validateResponse(response);

	  return response;

	  //*** Local function ****
	  function addAdsToResponse(response, ads) {
	    ads.forEach(function (ad) {
	      response.addAd(ad);
	    });
	  }

	  function validateResponse(response) {
	    var progressEvents = response.trackingEvents.progress;

	    if (!response.hasLinear()) {
	      throw new VASTError("on VASTClient._buildVASTResponse, Received an Ad type that is not supported", 200);
	    }

	    if (response.duration === undefined) {
	      throw new VASTError("on VASTClient._buildVASTResponse, Missing duration field in VAST response", 101);
	    }

	    if (progressEvents) {
	      progressEvents.forEach(function (progressEvent) {
	        if (!utilities.isNumber(progressEvent.offset)) {
	          throw new VASTError("on VASTClient._buildVASTResponse, missing or wrong offset attribute on progress tracking event", 101);
	        }
	      });
	    }
	  }
	};

	VASTClient.prototype._trackError = function (error, adChain) {
	  if (!utilities.isArray(adChain) || adChain.length === 0) { //There is nothing to track
	    return;
	  }

	  var errorURLMacros = [];
	  adChain.forEach(addErrorUrlMacros);
	  vastUtil.track(errorURLMacros, {ERRORCODE: error.code || 900});  //900 <== Undefined error

	  /*** Local functions  ***/
	  function addErrorUrlMacros(ad) {
	    /*if (ad.wrapper && ad.wrapper.error && typeof(ad.wrapper.error) === 'string') {
	        errorURLMacros.push(ad.wrapper.error);
	    }

	    if (ad.inLine && ad.inLine.error && typeof(ad.inLine.error) === 'string') {
	    	errorURLMacros.push(ad.inLine.error);
	    }*/
		  
	      if (ad.wrapper && ad.wrapper.errors && Array.isArray(ad.wrapper.errors)) {
	    	  errorURLMacros = errorURLMacros.concat(ad.wrapper.errors);
	      }

	      if (ad.inLine && ad.inLine.errors && Array.isArray(ad.inLine.errors)) {
	    	  errorURLMacros = errorURLMacros.concat(ad.inLine.errors);
	      }
	  }
	};

	module.exports = VASTClient;

	},{"../../utils/async":38,"../../utils/consoleLogger":39,"../../utils/http":41,"../../utils/utilityFunctions":45,"../../utils/xml":46,"./Ad":7,"./VASTError":19,"./VASTResponse":21,"./vastUtil":28}],19:[function(require,module,exports){
	'use strict';

	function VASTError(message, code) {
	  this.message = 'VAST Error: ' + (message || '');
	  if (code) {
	    this.code = code;
	  }
	}

	VASTError.prototype = new Error();
	VASTError.prototype.name = "VAST Error";

	module.exports = VASTError;
	},{}],20:[function(require,module,exports){
	'use strict';

	/**
	 * Inner helper class that deals with the logic of the individual steps needed to setup an ad in the player.
	 *
	 * @param player {object} instance of the player that will play the ad. It assumes that the videojs-contrib-ads plugin
	 *                        has been initialized when you use its utility functions.
	 *
	 * @constructor
	 */

	var VASTResponse = require('./VASTResponse');
	var VASTError = require('./VASTError');
	var VASTTracker = require('./VASTTracker');
	var vastUtil = require('./vastUtil');

	var async = require('../../utils/async');
	var dom = require('../../utils/dom');
	var playerUtils = require('../../utils/playerUtils');
	var utilities = require('../../utils/utilityFunctions');

	var logger = require ('../../utils/consoleLogger');

	function VASTIntegrator(player) {
	  if (!(this instanceof VASTIntegrator)) {
	    return new VASTIntegrator(player);
	  }

	  this.player = player;
	  this.enableFullscreenClickIFrame = false;
	}

	VASTIntegrator.prototype.playAd = function playAd(vastResponse, callback) {
	  var that = this;
	  callback = callback || utilities.noop;

	  if (!(vastResponse instanceof VASTResponse)) {
	    return callback(new VASTError('On VASTIntegrator, missing required VASTResponse'));
	  }

	  async.waterfall([
	    function (next) {
	      next(null, vastResponse);
	    },
	    this._selectAdSource.bind(this),
	    this._createVASTTracker.bind(this),
	    this._addClickThrough.bind(this),
	    this._addClickThroughDivBlocker.bind(this),
	    this._addSkipButton.bind(this),
	    this._setupEvents.bind(this),
	    this._playSelectedAd.bind(this)
	  ], function (error, response) {
	    if (error && response) {
	        if (window.MoatApiReference) {
	        	window.MoatApiReference.dispatchEvent({type: 'AdError', adVolume: that.player.volume()});
	        }
	      that._trackError(error, response);
	    }
	    callback(error, response);
	  });

	  this._adUnit = {
	    _src: null,
	    type: 'VAST',
	    pauseAd: function () {
	      that.player.pause(true);
	    },

	    resumeAd: function () {
	      that.player.play(true);
	    },

	    isPaused: function () {
	      return that.player.paused(true);
	    },

	    getSrc: function () {
	      return this._src;
	    }
	  };

	  return this._adUnit;
	};

	VASTIntegrator.prototype._selectAdSource = function selectAdSource(response, callback) {
	  var source;

	  var playerWidth = dom.getDimension(this.player.el()).width;
	  response.mediaFiles.sort(function compareTo(a, b) {
	    var deltaA = Math.abs(playerWidth - a.width);
	    var deltaB = Math.abs(playerWidth - b.width);
	    return deltaA - deltaB;
	  });

	  source = this.player.selectSource(response.mediaFiles).source;
	  if (source) {
	    this.player.trigger({type: 'trace.message', data: {message: 'Playing ' + source.src + ' (type = ' + source.type + ')'}});
	  }
	  
	  if (source) {
	    logger.info ("selected source: ", source);
	    if (this._adUnit) {
	      this._adUnit._src = source;
	    }
	    return callback(null, source, response);
	  }

	  // code 403 <== Couldn't find MediaFile that is supported by this video player
	  callback(new VASTError("Could not find Ad mediafile supported by this player", 403), response);
	};

	VASTIntegrator.prototype._createVASTTracker = function createVASTTracker(adMediaFile, response, callback) {
	  try {
	    callback(null, adMediaFile, new VASTTracker(adMediaFile.src, response), response);
	  } catch (e) {
	    callback(e, response);
	  }
	};

	VASTIntegrator.prototype._setupEvents = function setupEvents(adMediaFile, tracker, response, callback) {
	  var previouslyMuted;
	  var player = this.player;
	  player.on('fullscreenchange', trackFullscreenChange);
	  player.on('vast.adStart', trackImpressions);
	  player.on('pause', trackPause);
	  player.on('timeupdate', trackProgress);
	  player.on('volumechange', trackVolumeChange);

	  playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], unbindEvents);
	  playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel', 'vast.adSkip'], function(evt){
	    if(evt.type === 'vast.adEnd'){
	      tracker.trackComplete();
	    }
	    if (window.MoatApiReference) {
	    	var type = evt.type === 'vast.adEnd' ? 'AdVideoComplete' : 'AdStopped';
	  	  window.MoatApiReference.dispatchEvent({type: type, adVolume: player.volume()});
	    }
	  });
	  
	  player.one('adStop', function() {
		 player.trigger('vast.adsCancel'); 
	  });

	  return callback(null, adMediaFile, response);

	  /*** Local Functions ***/
	  function unbindEvents() {
	    player.off('fullscreenchange', trackFullscreenChange);
	    player.off('vast.adStart', trackImpressions);
	    player.off('pause', trackPause);
	    player.off('timeupdate', trackProgress);
	    player.off('volumechange', trackVolumeChange);
	  }

	  function trackFullscreenChange() {
	    if (player.isFullscreen()) {
	      tracker.trackFullscreen();
	    } else {
	      tracker.trackExitFullscreen();
	    }
	  }

	  function trackPause() {
	    //NOTE: whenever a video ends the video Element triggers a 'pause' event before the 'ended' event.
	    //      We should not track this pause event because it makes the VAST tracking confusing again we use a
	    //      Threshold of 2 seconds to prevent false positives on IOS.
			if (window._molSettings.breakDuration) {
				if (window._molSettings.realVideoDuration) {
				    if (Math.abs(window._molSettings.realVideoDuration - player.currentTime()) < 2) {
				        return;
				    }
				}
			}
			else if (Math.abs(player.duration() - player.currentTime()) < 2) {
		      return;
		    }

	    if (window.MoatApiReference) {
	    	  window.MoatApiReference.dispatchEvent({type: 'AdPaused', adVolume: player.volume()});
	    }
	    tracker.trackPause();
	    playerUtils.showBigPlayButton(player, true);
	    playerUtils.once(player, ['play', 'vast.adEnd', 'vast.adsCancel'], function (evt) {
	      if(evt.type === 'play'){
		    if (window.MoatApiReference) {
		    	  window.MoatApiReference.dispatchEvent({type: 'AdPlaying', adVolume: player.volume()});
		    }
	        tracker.trackResume();
	        playerUtils.showBigPlayButton(player, false);
	      }
	    });
	  }

	  function trackProgress() {
	    var currentTimeInMs = player.currentTime() * 1000;
	    tracker.trackProgress(currentTimeInMs);
	  }

	  function trackImpressions() {
	    if (window.MoatApiReference) {
	    	  window.MoatApiReference.dispatchEvent({type: 'AdImpression', adVolume: player.volume()});
	    }
	    tracker.trackImpressions();
	    tracker.trackCreativeView();
	  }

	  function trackVolumeChange() {
	    if (window.MoatApiReference) {
	  	  window.MoatApiReference.dispatchEvent({type: 'AdVolumeChange', adVolume: player.volume()});
	    }
	    var muted = player.muted();
	    if (muted) {
	      tracker.trackMute();
	    } else if (previouslyMuted) {
	      tracker.trackUnmute();
	    }
	    previouslyMuted = muted;
	  }
	};

	VASTIntegrator.prototype._addSkipButton = function addSkipButton(source, tracker, response, callback) {
	  var skipOffsetInSec;
	  var that = this;

	  if (utilities.isNumber(response.skipoffset)) {
	    skipOffsetInSec = response.skipoffset / 1000;
	    addSkipButtonToPlayer(this.player, skipOffsetInSec);
	  }
	  callback(null, source, tracker, response);

	  /*** Local function ***/
	  function addSkipButtonToPlayer(player, skipOffset) {
	    var skipButton = createSkipButton(player);
	    var updateSkipButton = updateSkipButtonState.bind(that, skipButton, skipOffset, player);

	    player.el().appendChild(skipButton);
	    player.on('timeupdate', updateSkipButton);

	    playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], removeSkipButton);

	    function removeSkipButton() {
	      player.off('timeupdate', updateSkipButton);
	      dom.remove(skipButton);
	    }
	  }

	  function createSkipButton(player) {
	    var skipButton = window.document.createElement("div");
	    dom.addClass(skipButton, "vast-skip-button");
	    skipButton.id = 'adSkipButton';

	    skipButton.onclick = function (e) {
	      if (dom.hasClass(skipButton, 'enabled')) {
	          if (window.MoatApiReference) {
	        	  window.MoatApiReference.dispatchEvent({type: 'AdSkipped', adVolume: player.volume()});
	          }
	        tracker.trackSkip();
	        player.trigger('vast.adSkip');
	      }
	      playerUtils.showBigPlayButton(player, false);

	      //We prevent event propagation to avoid problems with the clickThrough and so on
	      if (window.Event.prototype.stopPropagation !== undefined) {
	        e.stopPropagation();
	      } else {
	        return false;
	      }
	    };

	    return skipButton;
	  }

	  function updateSkipButtonState(skipButton, skipOffset, player) {
	    var timeLeft = Math.ceil(skipOffset - player.currentTime());
	    if (timeLeft > 0) {
	        //skipButton.innerHTML = "Skip in " + utilities.toFixedDigits(timeLeft, 2) + "...";
	        skipButton.innerHTML = '<p class="vast-skip-button-text">' + window._molSettings.skipText.replace('%%TIME%%', utilities.toFixedDigits(timeLeft, 2)) + '</p>';
	    } else {
	      if (!dom.hasClass(skipButton, 'enabled')) {
	        dom.addClass(skipButton, 'enabled');
	        //skipButton.innerHTML = "Skip ad";
	        skipButton.innerHTML = window._molSettings.skipButtonText;
	      }
	    }
	    var iframeBackButton = window.document.getElementById('iframeBackButton');
	    if (!iframeBackButton) {
	        skipButton.style.display = 'block';
	    }
	  }
	};

	VASTIntegrator.prototype._addClickThrough = function addClickThrough(mediaFile, tracker, response, callback) {
	  var enableFullscreenClickIFrame = this.enableFullscreenClickIFrame;
	  
	  var player = this.player;
	  var blocker = createClickThroughBlocker(player, tracker, response);
	  var updateBlocker = updateBlockerURL.bind(this, blocker, response, player);

	  player.el().insertBefore(blocker, player.controlBar.el());
	  player.on('timeupdate', updateBlocker);
	  playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], removeBlocker);
	  
	  if (enableFullscreenClickIFrame) {
		  player.on('fullscreenchange', updateDisplayStyle);
	  }

	  return callback(null, mediaFile, tracker, response);

	  /*** Local Functions ***/

	  function createClickThroughBlocker(player, tracker, response) {
			if (window._molSettings.disableClickThru) {
			    var blockerDiv = window.document.createElement("div");
			    dom.addClass(blockerDiv, 'vast-blocker');
				return blockerDiv;
			}
	    var blocker = window.document.createElement("a");
	    var clickThroughMacro = response.clickThrough;

	    dom.addClass(blocker, 'vast-blocker');
	    blocker.href = generateClickThroughURL(clickThroughMacro, player);

	    if (utilities.isString(clickThroughMacro)) {
	      blocker.target = "_blank";
	    }

	    var clickHandler = function(e) {
	        if (player.paused()) {
	            player.play();

	            //We prevent event propagation to avoid problems with the player's normal pause mechanism
	            if (window.Event.prototype.stopPropagation !== undefined) {
	              e.stopPropagation();
	            }
	            return false;
	        }

	          player.pause();
	          tracker.trackClick();

	          if (window.MoatApiReference) {
	        	  window.MoatApiReference.dispatchEvent({type: 'AdClickThru', adVolume: player.volume()});
	          }
	          if (utilities.isIDevice()) {
	              window.open(generateClickThroughURL(clickThroughMacro, player), '_blank');
	              if (window.Event.prototype.stopPropagation !== undefined) {
	                  e.stopPropagation();
	              }
	          }
	    };
	  
	    if (utilities.isIDevice()) {
	        blocker.ontouchend = clickHandler;
	    }
	    else {
	        blocker.onclick = clickHandler;
	    }
	    
	    if (player.isFullscreen() && enableFullscreenClickIFrame) {
	    	blocker.style.display = 'none';
	    }

	    return blocker;
	  }

	  function updateBlockerURL(blocker, response, player) {
	    blocker.href = generateClickThroughURL(response.clickThrough, player);
	  }

	  function generateClickThroughURL(clickThroughMacro, player) {
	    var variables = {
	      ASSETURI: mediaFile.src,
	      CONTENTPLAYHEAD: vastUtil.formatProgress(player.currentTime() * 1000)
	    };

	    return clickThroughMacro ? vastUtil.parseURLMacro(clickThroughMacro, variables) : '#';
	  }
	  
	  function updateDisplayStyle() {
		  blocker.style.display = player.isFullscreen() ? 'none' : 'block';
	  }

	  function removeBlocker() {
	    player.off('timeupdate', updateBlocker);
		player.off('fullscreenchange', updateDisplayStyle);
	    dom.remove(blocker);
	  }
	};

	VASTIntegrator.prototype._addClickThroughDivBlocker = function addClickThrough(mediaFile, tracker, response, callback) {
		if (!this.enableFullscreenClickIFrame) {
			return callback(null, mediaFile, tracker, response);
		}
		var player = this.player;
		  var blocker = createClickThroughDiv(player, tracker, response);
		  var updateBlocker = updateBlockerURL.bind(this, blocker, response, player);
		  var blockerUrl;
		  var iFrame;
		  var iFrameBackButton;

		  player.el().insertBefore(blocker, player.controlBar.el());
		  player.on('timeupdate', updateBlocker);
		  playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], removeBlocker);

		  player.on('fullscreenchange', updateDisplayStyle);

		  return callback(null, mediaFile, tracker, response);
		
		  function createClickThroughDiv(player, tracker) {
		    var blocker = window.document.createElement("div");

		    dom.addClass(blocker, 'vast-blocker');

			if (!window._molSettings.disableClickThru) {
			    blocker.onclick = function (e) {
			      if (player.paused()) {
			        player.play();
		
			        //We prevent event propagation to avoid problems with the player's normal pause mechanism
			        if (window.Event.prototype.stopPropagation !== undefined) {
			          e.stopPropagation();
			        }
			        return false;
			      }
		
			      player.pause();
			      tracker.trackClick();
		
			      if (window.MoatApiReference) {
			    	  window.MoatApiReference.dispatchEvent({type: 'AdClickThru', adVolume: player.volume()});
			      }
			      
			      // create IFrame with back button
			      iFrame = window.document.createElement("iframe");
				  dom.addClass(iFrame, 'vast-blocker');
				  iFrame.src = blockerUrl;
				  blocker.appendChild(iFrame);
				  
				  iFrameBackButton = window.document.createElement("div");
				  dom.addClass(iFrameBackButton, "vast-back-button");
			      dom.addClass(iFrameBackButton, 'enabled');
				  iFrameBackButton.innerHTML = "Back";
				  iFrameBackButton.id = 'iframeBackButton';
				  blocker.appendChild(iFrameBackButton);
				  iFrameBackButton.addEventListener ("click", function() {
					  blocker.removeChild(iFrame);
					  iFrame = null;
					  blocker.removeChild(iFrameBackButton);
					  iFrameBackButton = null;
		
					  // show controls
					  var skipButton = window.document.getElementById('adSkipButton');
					  if (skipButton) {
						  skipButton.style.display = 'block'; 
					  }
					  player.controls(true);
					  
					  if (window.Event.prototype.stopPropagation !== undefined) {
				          e.stopPropagation();
					  }
				  });
				  
				  // hide controls
				  setTimeout(function() {
					  playerUtils.showBigPlayButton(player, false);
				  }, 1);
				  var skipButton = window.document.getElementById('adSkipButton');
				  if (skipButton) {
					  skipButton.style.display = 'none'; 
				  }
				  player.controls(false);
		
			    };
			}

		    if (!player.isFullscreen()) {
		    	blocker.style.display = 'none';
		    }

		    return blocker;
		  }

		  function updateBlockerURL(blocker, response, player) {
			  blockerUrl = generateClickThroughURL(response.clickThrough, player);
		  }

		  function generateClickThroughURL(clickThroughMacro, player) {
		    var variables = {
		      ASSETURI: mediaFile.src,
		      CONTENTPLAYHEAD: vastUtil.formatProgress(player.currentTime() * 1000)
		    };

		    return clickThroughMacro ? vastUtil.parseURLMacro(clickThroughMacro, variables) : '#';
		  }

		  function updateDisplayStyle() {
			  blocker.style.display = player.isFullscreen() ? 'block' : 'none';
			  if (!player.isFullscreen() && iFrame) {
				  blocker.removeChild(iFrame);
				  iFrame = null;
				  blocker.removeChild(iFrameBackButton);
				  iFrameBackButton = null;
				  
				  playerUtils.showBigPlayButton(player, true);
				  var skipButton = window.document.getElementById('adSkipButton');
				  if (skipButton) {
					  skipButton.style.display = 'none'; 
				  }
				  player.controls(true);
			  }
		  }

		  function removeBlocker() {
		    player.off('timeupdate', updateBlocker);
			player.off('fullscreenchange', updateDisplayStyle);
		    dom.remove(blocker);
		  }
	};

	VASTIntegrator.prototype._playSelectedAd = function playSelectedAd(source, response, callback) {
	  var player = this.player;

	  //window.MoatApiReference = null;

	  player.preload("auto"); //without preload=auto the durationchange event is never fired
	  player.src(source);

	  logger.debug ("<VASTIntegrator._playSelectedAd> waiting for durationchange to play the ad...");

	  playerUtils.once(player, ['durationchange', 'error', 'vast.adsCancel'], function (evt) {
	    if (evt.type === 'durationchange') {
	      logger.debug ("<VASTIntegrator._playSelectedAd> got durationchange; calling playAd()");
	      playAd();
	    } else if(evt.type === 'error') {
	      callback(new VASTError("on VASTIntegrator, Player is unable to play the Ad", 400), response);
	    }
	    //NOTE: If the ads get canceled we do nothing/
	  });

	  /**** local functions ******/
	  function playAd() {

	    playerUtils.once(player, ['playing', 'vast.adsCancel'], function (evt) {
	      if(evt.type === 'vast.adsCancel'){
	        return;
	      }

	      /*Copyright (c) 2011-2016 Moat Inc. All Rights Reserved.*/
	      /*function initMoatTracking(a,c,d,h,k){var f=document.createElement("script"),b=[];c={adData:{ids:c,duration:d,url:k},dispatchEvent:function(a){this.sendEvent?(b&&(b.push(a),a=b,b=!1),this.sendEvent(a)):b.push(a)}};d="_moatApi"+Math.floor(1E8*Math.random());var e,g;try{e=a.ownerDocument,g=e.defaultView||e.parentWindow}catch(l){e=document,g=window}g[d]=c;f.type="text/javascript";a&&a.insertBefore(f,a.childNodes[0]||null);f.src="https://z.moatads.com/"+h+"/moatvideo.js#"+d;return c};
	      window.MoatApiReference = null;
	      if (response.ads && response.ads.length > 0 && response.ads[0].inLine && response.ads[0].inLine.moat) {
	    	  var ids = {level1: response.ads[0].inLine.moat.advid,
	    			     level2: response.ads[0].inLine.moat.cpgid,
	    			     level3: response.ads[0].inLine.moat.cpid,
	    			     level4: response.ads[0].inLine.moat.crid};
	    	  if (response.ads[0].inLine.moat.site_id) {
	    		  ids.slicer1 = response.ads[0].inLine.moat.site_id;
	    	  }
	    	  window.MoatApiReference = initMoatTracking(player.el_, ids, player.duration(), response.ads[0].inLine.moat.partnercode, player.currentSource().src);
	    	  //window.MoatApiReference = initMoatTracking(player.el_, ids, player.duration(), 'ninemediavpaid78961164', player.currentSource().src);
	      }
	      if (window._molSettings.viewabilityTracking) {
	    	  window._molSettings.viewabilityTracking.init(window._molSettings.viewability.contextId, 
	    			  player.duration(), player.el_.offsetWidth, player.el_.offsetHeight);
	      }*/
	      
	      logger.debug ("<VASTIntegrator._playSelectedAd/playAd> got playing event; triggering vast.adStart...");

	      player.trigger('vast.adStart');

	      if (utilities.isMobile()) {
	          // VIDLA-2336 (simulate user activity to make sure control-bar is visible on mobile devices)
	          for (var i = 0; i < 5; i++) {
	          	setTimeout(function() {
	          		player.userActive(true);
	          	}, i * 2000);
	          }
	      }

	      if (window.MoatApiReference) {
	    	  window.MoatApiReference.dispatchEvent({type: 'AdVideoStart', adVolume: player.volume()});
	      }

	      player.on('ended', proceed);
	      player.on('vast.adsCancel', proceed);
	      player.on('vast.adSkip', proceed);

	      function proceed(evt) {

	          if(evt.type === 'ended') {
	              // Ignore ended event if the Ad time was not 'near' the end
	              // avoids issues where IOS controls could skip the Ad
	            	if (window._molSettings.breakDuration) {
	            		if (window._molSettings.realVideoDuration) {
	            		    if ((window._molSettings.realVideoDuration - player.currentTime()) > 3) {
	            		        return;
	            		    }
	            		}
	            	}
	            	else if ((player.duration() - player.currentTime()) > 3) {
	    				return;
	    			}
	            }

	        /*if(evt.type === 'ended' && (player.duration() - player.currentTime()) > 3 ) {
	          // Ignore ended event if the Ad time was not 'near' the end
	          // avoids issues where IOS controls could skip the Ad
	          return;
	        }*/

	        player.off('ended', proceed);
	        player.off('vast.adsCancel', proceed);
	        player.off('vast.adSkip', proceed);

	        //NOTE: if the ads get cancel we do nothing apart removing the listners
	        if(evt.type === 'ended' || evt.type === 'vast.adSkip'){
	          callback(null, response);
	        }
	      }
	    });

	    logger.debug ("<VASTIntegrator._playSelectedAd/playAd> calling player.play()...");

	    player.play();
	  }
	};

	VASTIntegrator.prototype._trackError = function trackError(error, response) {
	  vastUtil.track(response.errorURLMacros, {ERRORCODE: error.code || 900});
	};

	module.exports = VASTIntegrator;
	},{"../../utils/async":38,"../../utils/consoleLogger":39,"../../utils/dom":40,"../../utils/playerUtils":43,"../../utils/utilityFunctions":45,"./VASTError":19,"./VASTResponse":21,"./VASTTracker":22,"./vastUtil":28}],21:[function(require,module,exports){
	'use strict';

	var Ad = require('./Ad');
	var VideoClicks = require('./VideoClicks');
	var Linear = require('./Linear');
	var InLine = require('./InLine');
	var Wrapper = require('./Wrapper');

	var utilities = require('../../utils/utilityFunctions');
	//var xml = require('../../utils/xml');

	window.InLine__A = InLine;
	function VASTResponse() {
	  if (!(this instanceof VASTResponse)) {
	    return new VASTResponse();
	  }

	  this._linearAdded = false;
	  this.vastVersion = undefined;
	  this.ads = [];
	  this.errorURLMacros = [];
	  this.impressions = [];
	  this.clickTrackings = [];
	  this.customClicks = [];
	  this.trackingEvents = {};
	  this.mediaFiles = [];
	  this.clickThrough = undefined;
	  this.adTitle = '';
	  this.duration = undefined;
	  this.skipoffset = undefined;
	  this.icons = [];
	}

	VASTResponse.prototype.addAd = function (ad) {
	  var inLine, wrapper;
	  if (ad instanceof Ad) {
	    inLine = ad.inLine;
	    wrapper = ad.wrapper;

	    this.ads.push(ad);

	    if (inLine) {
	      this._addInLine(inLine);
	    }

	    if (wrapper) {
	      this._addWrapper(wrapper);
	    }
	  }
	};

	/*VASTResponse.prototype._addErrorTrackUrl = function (error) {
		  var errorURL = error instanceof xml.JXONTree ? xml.keyValue(error) : error;
		  if (errorURL) {
		    this.errorURLMacros.push(errorURL);
		  }
		};*/
	VASTResponse.prototype._addErrorTrackUrls = function (errors) {
		  utilities.isArray(errors) && appendToArray(this.errorURLMacros, errors);
		};

	VASTResponse.prototype._addImpressions = function (impressions) {
	  utilities.isArray(impressions) && appendToArray(this.impressions, impressions);
	};

	VASTResponse.prototype._addClickThrough = function (clickThrough) {
	  if (utilities.isNotEmptyString(clickThrough)) {
	    this.clickThrough = clickThrough;
	  }
	};

	VASTResponse.prototype._addClickTrackings = function (clickTrackings) {
	  utilities.isArray(clickTrackings) && appendToArray(this.clickTrackings, clickTrackings);
	};

	VASTResponse.prototype._addCustomClicks = function (customClicks) {
	  utilities.isArray(customClicks) && appendToArray(this.customClicks, customClicks);
	};

	VASTResponse.prototype._addTrackingEvents = function (trackingEvents) {
	  var eventsMap = this.trackingEvents;

	  if (trackingEvents) {
	    trackingEvents = utilities.isArray(trackingEvents) ? trackingEvents : [trackingEvents];
	    trackingEvents.forEach(function (trackingEvent) {
	      if (!eventsMap[trackingEvent.name]) {
	        eventsMap[trackingEvent.name] = [];
	      }
	      eventsMap[trackingEvent.name].push(trackingEvent);
	    });
	  }
	};

	VASTResponse.prototype._addTitle = function (title) {
	  if (utilities.isNotEmptyString(title)) {
	    this.adTitle = title;
	  }
	};

	VASTResponse.prototype._addDuration = function (duration) {
	  if (utilities.isNumber(duration)) {
	    this.duration = duration;
	  }
	};

	VASTResponse.prototype._addVideoClicks = function (videoClicks) {
	  if (videoClicks instanceof VideoClicks) {
	    this._addClickThrough(videoClicks.clickThrough);
	    this._addClickTrackings(videoClicks.clickTrackings);
	    this._addCustomClicks(videoClicks.customClicks);
	  }
	};

	VASTResponse.prototype._addMediaFiles = function (mediaFiles) {
	  utilities.isArray(mediaFiles) && appendToArray(this.mediaFiles, mediaFiles);
	};

	VASTResponse.prototype._addSkipoffset = function (offset) {
		  if (window._molSettings && window._molSettings.skippable) {
			  if (window._molSettings.skippable.enabled) {
				  if (!this.duration || !window._molSettings.skippable.videoThreshold || this.duration >= window._molSettings.skippable.videoThreshold) {
					  this.skipoffset = window._molSettings.skippable.videoOffset;
				  }
			  }
		  }
		  else if (offset) {
		    this.skipoffset = offset;
		  }
	};

	VASTResponse.prototype._addAdParameters = function (adParameters) {
	  if (adParameters) {
	    this.adParameters = adParameters;
	  }
	};

	VASTResponse.prototype._addIcons = function (icons) {
	  utilities.isArray(icons) && appendToArray(this.icons, icons);
	};

	VASTResponse.prototype._addLinear = function (linear) {
	  if (linear instanceof Linear) {
	    this._addDuration(linear.duration);
	    this._addTrackingEvents(linear.trackingEvents);
	    this._addVideoClicks(linear.videoClicks);
	    this._addMediaFiles(linear.mediaFiles);
	    this._addSkipoffset(linear.skipoffset);
	    this._addAdParameters(linear.adParameters);
	    this._addIcons(linear.icons);
	    this._linearAdded = true;
	  }
	};

	VASTResponse.prototype._addInLine = function (inLine) {
	  var that = this;

	  if (inLine instanceof InLine) {
	    this._addTitle(inLine.adTitle);
	    this._addErrorTrackUrls(inLine.errors);
	    this._addImpressions(inLine.impressions);

	    inLine.creatives.forEach(function (creative) {
	      if (creative.linear) {
	        that._addLinear(creative.linear);
	      }
	    });
	  }
	};

	VASTResponse.prototype._addWrapper = function (wrapper) {
	  var that = this;

	  if (wrapper instanceof Wrapper) {
	    this._addErrorTrackUrls(wrapper.errors);
	    this._addImpressions(wrapper.impressions);

	    wrapper.creatives.forEach(function (creative) {
	      var linear = creative.linear;
	      if (linear) {
	        that._addVideoClicks(linear.videoClicks);
	        that.clickThrough = undefined;//We ensure that no clickThrough has been added
	        that._addTrackingEvents(linear.trackingEvents);
	        that._addIcons(linear.icons);
	      }
	    });
	  }
	};

	VASTResponse.prototype.hasLinear = function(){
	  return this._linearAdded;
	};

	function appendToArray(array, items) {
	  items.forEach(function (item) {
	    if (item) {
	      array.push(item);
	    }
	  });
	}

	module.exports = VASTResponse;


	},{"../../utils/utilityFunctions":45,"./Ad":7,"./InLine":12,"./Linear":14,"./VideoClicks":24,"./Wrapper":26}],22:[function(require,module,exports){
	'use strict';

	var VASTError = require('./VASTError');
	var VASTResponse = require('./VASTResponse');
	var vastUtil = require('./vastUtil');
	var utilities = require('../../utils/utilityFunctions');

	function VASTTracker(assetURI, vastResponse) {
	  if (!(this instanceof VASTTracker)) {
	    return new VASTTracker(assetURI, vastResponse);
	  }

	  this.sanityCheck(assetURI, vastResponse);
	  this.initialize(assetURI, vastResponse);

	}

	VASTTracker.prototype.initialize = function(assetURI, vastResponse) {
	  this.response = vastResponse;
	  this.assetURI = assetURI;
	  this.progress = 0;
	  this.quartiles = {
	    firstQuartile: {tracked: false, time: Math.round(25 * vastResponse.duration) / 100},
	    midpoint: {tracked: false, time: Math.round(50 * vastResponse.duration) / 100},
	    thirdQuartile: {tracked: false, time: Math.round(75 * vastResponse.duration) / 100}
	  };
	};

	VASTTracker.prototype.sanityCheck = function(assetURI, vastResponse) {
	  if (!utilities.isString(assetURI) || utilities.isEmptyString(assetURI)) {
	    throw new VASTError('on VASTTracker constructor, missing required the URI of the ad asset being played');
	  }

	  if (!(vastResponse instanceof VASTResponse)) {
	    throw new VASTError('on VASTTracker constructor, missing required VAST response');
	  }
	};

	VASTTracker.prototype.trackURLs = function trackURLs(urls, variables) {
	  if (utilities.isArray(urls) && urls.length > 0) {
	    variables = utilities.extend({
	      ASSETURI: this.assetURI,
	      CONTENTPLAYHEAD: vastUtil.formatProgress(this.progress)
	    }, variables || {});

	    vastUtil.track(urls, variables);
	  }
	};

	VASTTracker.prototype.trackEvent = function trackEvent(eventName, trackOnce) {
	    if (this.response.trackingEvents[eventName] && window._molSettings.viewabilityTracking) {
	    	  window._molSettings.viewabilityTracking.invokeEvent(eventName);
	    }
	  this.trackURLs(getEventUris(this.response.trackingEvents[eventName]));
	  if (trackOnce) {
	    this.response.trackingEvents[eventName] = undefined;
	  }

	  /*** Local function ***/
	  function getEventUris(trackingEvents) {
	    var uris;

	    if (trackingEvents) {
	      uris = [];
	      trackingEvents.forEach(function (event) {
	          if (!event.uri) {
	              return;
	          }

	          uris.push(event.uri);
	      });
	    }
	    return uris;
	  }
	};

	VASTTracker.prototype.trackProgress = function trackProgress(newProgressInMs) {
	  var that = this;
	  var events = [];
	  var ONCE = true;
	  var ALWAYS = false;
	  var trackingEvents = this.response.trackingEvents;

	  if (utilities.isNumber(newProgressInMs)) {
	    addTrackEvent('start', ONCE, newProgressInMs > 0);
	    addTrackEvent('rewind', ALWAYS, hasRewound(this.progress, newProgressInMs));
	    addQuartileEvents(newProgressInMs);
	    trackProgressEvents(newProgressInMs);
	    trackEvents();
	    this.progress = newProgressInMs;
	  }

	  /*** Local function ***/
	  function hasRewound(currentProgress, newProgress) {
	    var REWIND_THRESHOLD = 3000; //IOS video clock is very unreliable and we need a 3 seconds threshold to ensure that there was a rewind an that it was on purpose.
	    return currentProgress > newProgressInMs && Math.abs(newProgress - currentProgress) > REWIND_THRESHOLD;
	  }

	  function addTrackEvent(eventName, trackOnce, canBeAdded) {
	    if (trackingEvents[eventName] && canBeAdded) {
	      events.push({
	        name: eventName,
	        trackOnce: !!trackOnce
	      });
	    }
	  }

	  function addQuartileEvents(progress) {
	    var quartiles = that.quartiles;
	    var firstQuartile = that.quartiles.firstQuartile;
	    var midpoint = that.quartiles.midpoint;
	    var thirdQuartile = that.quartiles.thirdQuartile;

	    if (!firstQuartile.tracked) {
	      trackQuartile('firstQuartile', progress);
	    } else if (!midpoint.tracked) {
	      trackQuartile('midpoint', progress);
	    } else if (!thirdQuartile.tracked){
	      trackQuartile('thirdQuartile', progress);
	    }

	    /*** Local function ***/
	    function trackQuartile(quartileName, progress){
	      var quartile = quartiles[quartileName];
	      if(canBeTracked(quartile, progress)){
	        quartile.tracked = true;
	        addTrackEvent(quartileName, ONCE, true);
	      }
	    }
	  }

	  function canBeTracked(quartile, progress) {
	    var quartileTime = quartile.time;
	    //We only fire the quartile event if the progress is bigger than the quartile time by 5 seconds at most.
	    return progress >= quartileTime && progress <= (quartileTime + 5000);
	  }

	  function trackProgressEvents(progress) {
	    if (!utilities.isArray(trackingEvents.progress)) {
	      return; //Nothing to track
	    }

	    var pendingProgressEvts = [];

	    trackingEvents.progress.forEach(function (evt) {
	      if (evt.offset <= progress) {
	        that.trackURLs([evt.uri]);
	      } else {
	        pendingProgressEvts.push(evt);
	      }
	    });
	    trackingEvents.progress = pendingProgressEvts;
	  }

	  function trackEvents() {
	    events.forEach(function (event) {
	      that.trackEvent(event.name, event.trackOnce);
	    });
	  }
	};

	[
	  'rewind',
	  'fullscreen',
	  'exitFullscreen',
	  'pause',
	  'resume',
	  'mute',
	  'unmute',
	  'acceptInvitation',
	  'acceptInvitationLinear',
	  'collapse',
	  'expand'
	].forEach(function (eventName) {
	    VASTTracker.prototype['track' + utilities.capitalize(eventName)] = function () {
	      this.trackEvent(eventName);
	    };
	  });

	[
	  'start',
	  'skip',
	  'close',
	  'closeLinear'
	].forEach(function (eventName) {
	    VASTTracker.prototype['track' + utilities.capitalize(eventName)] = function () {
	      this.trackEvent(eventName, true);
	    };
	  });

	[
	  'firstQuartile',
	  'midpoint',
	  'thirdQuartile'
	].forEach(function (quartile) {
	    VASTTracker.prototype['track' + utilities.capitalize(quartile)] = function () {
	      this.quartiles[quartile].tracked = true;
	      this.trackEvent(quartile, true);
	    };
	  });

	VASTTracker.prototype.trackComplete = function () {
	  if(this.quartiles.thirdQuartile.tracked){
	    this.trackEvent('complete', true);
	  }
	};

	VASTTracker.prototype.trackErrorWithCode = function trackErrorWithCode(errorcode) {
	  if (utilities.isNumber(errorcode)) {
	    this.trackURLs(this.response.errorURLMacros, {ERRORCODE: errorcode});
	  }
	};

	VASTTracker.prototype.trackImpressions = function trackImpressions() {
	  this.trackURLs(this.response.impressions);
	};

	VASTTracker.prototype.trackCreativeView = function trackCreativeView() {
	  this.trackEvent('creativeView');
	};

	VASTTracker.prototype.trackClick = function trackClick() {
	    if (window._molSettings.viewabilityTracking) {
	  	  window._molSettings.viewabilityTracking.invokeEvent('ad-click');
	    }
	  this.trackURLs(this.response.clickTrackings);
	};

	module.exports = VASTTracker;

	},{"../../utils/utilityFunctions":45,"./VASTError":19,"./VASTResponse":21,"./vastUtil":28}],23:[function(require,module,exports){
	'use strict';

	var xml = require('../../utils/xml');
	var vastUtil = require('./vastUtil');
	var utilities = require('../../utils/utilityFunctions');

	function Verification(verificationJTree) {
	  if(!(this instanceof Verification)) {
	    return new Verification(verificationJTree);
	  }

	  this.vendor = verificationJTree.attr('vendor');
	  if (verificationJTree.javaScriptResource) {
		  this.javaScriptResources = parseResources(verificationJTree.javaScriptResource);
	  }
	  if (vastUtil.isFlashSupported() && verificationJTree.flashResource) {
		  this.javaScriptResources = parseResources(verificationJTree.javaScriptResource);
	  }
	  if (verificationJTree.viewableImpression) {
		  this.viewableImpression = {id: verificationJTree.viewableImpression.attr('id'), uri: xml.keyValue(verificationJTree.viewableImpression)};
	  }
	  
	  function parseResources(resources) {
		  var arr = [];
		  var arrData;
		  if (resources) {
			  arrData = utilities.isArray(resources) ? resources : [resources];
			  arrData.forEach(function (elem) {
				  arr.push({apiFramework: elem.attr('apiFramework'), uri: xml.keyValue(elem)});
			  });
		  }
		  return arr;
	  }
	}

	Verification.parseAdVerifications = function parseAdVerifications(verificationsJTree) {
	  var verifications = [];
	  var verificationsData;
	  if (utilities.isDefined(verificationsJTree) && utilities.isDefined(verificationsJTree.verification)) {
		  verificationsData = utilities.isArray(verificationsJTree.verification) ? verificationsJTree.verification : [verificationsJTree.verification];
		  verificationsData.forEach(function (verification) {
	    	verifications.push(new Verification(verification));
	    });
	  }
	  return verifications;
	};

	module.exports = Verification;

	},{"../../utils/utilityFunctions":45,"../../utils/xml":46,"./vastUtil":28}],24:[function(require,module,exports){
	'use strict';

	var utilities = require('../../utils/utilityFunctions');
	var xml = require('../../utils/xml');

	function VideoClicks(videoClickJTree) {
	  if (!(this instanceof VideoClicks)) {
	    return new VideoClicks(videoClickJTree);
	  }

	  this.clickThrough = xml.keyValue(videoClickJTree.clickThrough);
	  this.clickTrackings = parseClickTrackings(videoClickJTree.clickTracking);
	  this.customClicks = parseClickTrackings(videoClickJTree.customClick);

	  /*** Local functions ***/
	  function parseClickTrackings(trackingData) {
	    var clickTrackings = [];
	    if (trackingData) {
	      trackingData = utilities.isArray(trackingData) ? trackingData : [trackingData];
	      trackingData.forEach(function (clickTrackingData) {
	        clickTrackings.push(xml.keyValue(clickTrackingData));
	      });
	    }
	    return clickTrackings;
	  }
	}

	module.exports = VideoClicks;
	},{"../../utils/utilityFunctions":45,"../../utils/xml":46}],25:[function(require,module,exports){
	'use strict';

	var xml = require('../../utils/xml');
	var utilities = require('../../utils/utilityFunctions');

	function ViewableImpression(viewableImpressionJTree) {
		  if(!(this instanceof ViewableImpression)) {
		    return new ViewableImpression(viewableImpressionJTree);
		  }

		  //Optional Fields
		  this.id = viewableImpressionJTree.attr('id');
		  if (viewableImpressionJTree.viewable) {
			  this.viewables = parseUriArray(viewableImpressionJTree.viewable);
		  }
		  if (viewableImpressionJTree.notViewable) {
			  this.notViewables = parseUriArray(viewableImpressionJTree.notViewable);
		  }
		  if (viewableImpressionJTree.viewUndetermined) {
			  this.viewUndetermineds = parseUriArray(viewableImpressionJTree.viewUndetermined);
		  }

		  function parseUriArray(arrJTree) {
			  var arr = [];
			  var arrData;
			  if (arrJTree) {
				  arrData = utilities.isArray(arrJTree) ? arrJTree : [arrJTree];
				  arrData.forEach(function (elem) {
					  arr.push(xml.keyValue(elem));
				  });
			  }
			  return arr;
		 }
	}

	module.exports = ViewableImpression;

	},{"../../utils/utilityFunctions":45,"../../utils/xml":46}],26:[function(require,module,exports){
	'use strict';

	var vastUtil = require('./vastUtil');
	var Creative = require('./Creative');
	var ViewableImpression = require('./ViewableImpression');
	var Verification = require('./Verification');

	var utilities = require('../../utils/utilityFunctions');
	var xml = require('../../utils/xml');

	function Wrapper(wrapperJTree) {
	  if(!(this instanceof Wrapper)) {
	    return new Wrapper(wrapperJTree);
	  }

	  //Required elements
	  this.adSystem = xml.keyValue(wrapperJTree.adSystem);
	  this.impressions = vastUtil.parseImpressions(wrapperJTree.impression);
	  this.VASTAdTagURI = xml.keyValue(wrapperJTree.vASTAdTagURI);

	  //Optional elements
	  this.creatives = Creative.parseCreatives(wrapperJTree.creatives);
	  //this.error = xml.keyValue(wrapperJTree.error);
	  this.errors = vastUtil.parseErrors(wrapperJTree.error);
	  this.extensions = wrapperJTree.extensions;

	  //Optional attrs
	  this.followAdditionalWrappers = utilities.isDefined(xml.attr(wrapperJTree, 'followAdditionalWrappers'))? xml.attr(wrapperJTree, 'followAdditionalWrappers'): true;
	  this.allowMultipleAds = xml.attr(wrapperJTree, 'allowMultipleAds');
	  this.fallbackOnNoAd = xml.attr(wrapperJTree, 'fallbackOnNoAd');

	  if (window.mol_vastVersion === 4) {
		  if (wrapperJTree.viewableImpression) {
			  this.viewableImpression = new ViewableImpression(wrapperJTree.viewableImpression);
		  }
		  if (wrapperJTree.adVerifications) {
			  this.adVerifications = Verification.parseAdVerifications(wrapperJTree.adVerifications);
		  }
	  }
	}

	module.exports = Wrapper;

	},{"../../utils/utilityFunctions":45,"../../utils/xml":46,"./Creative":10,"./Verification":23,"./ViewableImpression":25,"./vastUtil":28}],27:[function(require,module,exports){
	'use strict';

	var utilities = require('../../utils/utilityFunctions');

	var durationRegex = /(\d\d):(\d\d):(\d\d)(\.(\d\d\d))?/;

	var parsers = {

	  duration: function parseDuration(durationStr) {

	    var match, durationInMs;

	    if (utilities.isString(durationStr)) {
	      match = durationStr.match(durationRegex);
	      if (match) {
	        durationInMs = parseHoursToMs(match[1]) + parseMinToMs(match[2]) + parseSecToMs(match[3]) + parseInt(match[5] || 0);
	      }
	    }

	    return isNaN(durationInMs) ? null : durationInMs;

	    /*** local functions ***/
	    function parseHoursToMs(hourStr) {
	      return parseInt(hourStr, 10) * 60 * 60 * 1000;
	    }

	    function parseMinToMs(minStr) {
	      return parseInt(minStr, 10) * 60 * 1000;
	    }

	    function parseSecToMs(secStr) {
	      return parseInt(secStr, 10) * 1000;
	    }
	  },

	  offset: function parseOffset(offset, duration) {
	    if(isPercentage(offset)){
	      return calculatePercentage(offset, duration);
	    }
	    return parsers.duration(offset);

	    /*** Local function ***/
	    function isPercentage(offset) {
	      var percentageRegex = /^\d+(\.\d+)?%$/g;
	      return percentageRegex.test(offset);
	    }

	    function calculatePercentage(percentStr, duration) {
	      if(duration) {
	        return calcPercent(duration, parseFloat(percentStr.replace('%', '')));
	      }
	      return null;
	    }

	    function calcPercent(quantity, percent){
	      return quantity * percent / 100;
	    }
	  }

	};


	module.exports = parsers;
	},{"../../utils/utilityFunctions":45}],28:[function(require,module,exports){
	'use strict';

	var utilities = require('../../utils/utilityFunctions');
	var VPAIDHTML5Tech = require('../vpaid/VPAIDHTML5Tech');

	var vastUtil = {

	  track: function track(URLMacros, variables) {
	    var sources = vastUtil.parseURLMacros(URLMacros, variables);
	    var trackImgs = [];
	    sources.forEach(function (src) {
	      var img = new Image();
	      img.src = src;
	      trackImgs.push(img);
	    });
	    return trackImgs;
	  },

	  parseURLMacros: function parseMacros(URLMacros, variables) {
	    var parsedURLs = [];

	    variables = variables || {};

	    if (!(variables["CACHEBUSTING"])) {
	      variables["CACHEBUSTING"] = Math.round(Math.random() * 1.0e+10);
	    }

	    URLMacros.forEach(function (URLMacro) {
	      parsedURLs.push(vastUtil._parseURLMacro(URLMacro, variables));
	    });

	    return parsedURLs;
	  },

	  parseURLMacro: function parseMacro(URLMacro, variables) {
	    variables = variables || {};

	    if (!(variables["CACHEBUSTING"])) {
	      variables["CACHEBUSTING"] = Math.round(Math.random() * 1.0e+10);
	    }

	    return vastUtil._parseURLMacro(URLMacro, variables);
	  },

	  _parseURLMacro: function parseMacro(URLMacro, variables) {
	    variables = variables || {};

	    utilities.forEach(variables, function (value, key) {
	      URLMacro = URLMacro.replace(new RegExp("\\[" + key + "\\\]", 'gm'), value);
	    });

	    return URLMacro;
	  },

	  parseDuration: function parseDuration(durationStr) {
	    var durationRegex = /(\d\d):(\d\d):(\d\d)(\.(\d\d\d))?/;
	    var match, durationInMs;

	    if (utilities.isString(durationStr)) {
	      match = durationStr.match(durationRegex);
	      if (match) {
	        durationInMs = parseHoursToMs(match[1]) + parseMinToMs(match[2]) + parseSecToMs(match[3]) + parseInt(match[5] || 0);
	      }
	    }

	    return isNaN(durationInMs) ? null : durationInMs;

	    /*** local functions ***/
	    function parseHoursToMs(hourStr) {
	      return parseInt(hourStr, 10) * 60 * 60 * 1000;
	    }

	    function parseMinToMs(minStr) {
	      return parseInt(minStr, 10) * 60 * 1000;
	    }

	    function parseSecToMs(secStr) {
	      return parseInt(secStr, 10) * 1000;
	    }
	  },

	  parseImpressions: function parseImpressions(impressions) {
		    if (impressions) {
		      impressions = utilities.isArray(impressions) ? impressions : [impressions];
		      return utilities.transformArray(impressions, function (impression) {
		        if (utilities.isNotEmptyString(impression.keyValue)) {
		          return impression.keyValue;
		        }
		        return undefined;
		      });
		    }
		    return [];
		  },

		  parseErrors: function parseErrors(errors) {
		    if (errors) {
		    	errors = utilities.isArray(errors) ? errors : [errors];
		      return utilities.transformArray(errors, function (error) {
		        if (utilities.isNotEmptyString(error.keyValue)) {
		          return error.keyValue;
		        }
		        return undefined;
		      });
		    }
		    return [];
		  },

	  //We assume that the progress is going to arrive in milliseconds
	  formatProgress: function formatProgress(progress) {
	    var hours, minutes, seconds, milliseconds;
	    hours = progress / (60 * 60 * 1000);
	    hours = Math.floor(hours);
	    minutes = (progress / (60 * 1000)) % 60;
	    minutes = Math.floor(minutes);
	    seconds = (progress / 1000) % 60;
	    seconds = Math.floor(seconds);
	    milliseconds = progress % 1000;
	    return utilities.toFixedDigits(hours, 2) + ':' + utilities.toFixedDigits(minutes, 2) + ':' + utilities.toFixedDigits(seconds, 2) + '.' + utilities.toFixedDigits(milliseconds, 3);
	  },

	  parseOffset: function parseOffset(offset, duration) {
	    if (isPercentage(offset)) {
	      return calculatePercentage(offset, duration);
	    }
	    return vastUtil.parseDuration(offset);

	    /*** Local function ***/
	    function isPercentage(offset) {
	      var percentageRegex = /^\d+(\.\d+)?%$/g;
	      return percentageRegex.test(offset);
	    }

	    function calculatePercentage(percentStr, duration) {
	      if (duration) {
	        return calcPercent(duration, parseFloat(percentStr.replace('%', '')));
	      }
	      return null;
	    }

	    function calcPercent(quantity, percent) {
	      return quantity * percent / 100;
	    }
	  },


	  //List of supported VPAID technologies
	  VPAID_techs: [
	    //VPAIDFlashTech,
	    VPAIDHTML5Tech
	  ],

	  isVPAID: function isVPAIDMediaFile(mediaFile) {
	    return !!mediaFile && mediaFile.apiFramework === 'VPAID';
	  },

	  findSupportedVPAIDTech: function findSupportedVPAIDTech(mimeType) {
	    var i, len, VPAIDTech;

	    for (i = 0, len = this.VPAID_techs.length; i < len; i += 1) {
	      VPAIDTech = this.VPAID_techs[i];
	      if (VPAIDTech.supports(mimeType)) {
	        return VPAIDTech;
	      }
	    }
	    return null;
	  },

	  isFlashSupported: function isFlashSupported() {
		  return false;
	  },

	};

	module.exports = vastUtil;

	},{"../../utils/utilityFunctions":45,"../vpaid/VPAIDHTML5Tech":30}],29:[function(require,module,exports){
	'use strict';

	var VASTError = require('../vast/VASTError');

	var utilities = require('../../utils/utilityFunctions');

	function VPAIDAdUnitWrapper(vpaidAdUnit, opts) {
	  if (!(this instanceof VPAIDAdUnitWrapper)) {
	    return new VPAIDAdUnitWrapper(vpaidAdUnit, opts);
	  }
	  sanityCheck(vpaidAdUnit, opts);

	  this.options = utilities.extend({}, opts);
	  this.adStarted = false;

	  this._adUnit = vpaidAdUnit;

	  /*** Local Functions ***/
	  function sanityCheck(adUnit, opts) {
	    if (!adUnit || !VPAIDAdUnitWrapper.checkVPAIDInterface(adUnit)) {
	      throw new VASTError('on VPAIDAdUnitWrapper, the passed VPAID adUnit does not fully implement the VPAID interface');
	    }

	    if (!utilities.isObject(opts)) {
	      throw new VASTError("on VPAIDAdUnitWrapper, expected options hash  but got '" + opts + "'");
	    }

	    if (!("responseTimeout" in opts) || !utilities.isNumber(opts.responseTimeout) ){
	      throw new VASTError("on VPAIDAdUnitWrapper, expected responseTimeout in options");
	    }
	  }
	}

	VPAIDAdUnitWrapper.checkVPAIDInterface = function checkVPAIDInterface(VPAIDAdUnit) {
	  //NOTE: skipAd is not part of the method list because it only appears in VPAID 2.0 and we support VPAID 1.0
	  var VPAIDInterfaceMethods = [
	    'handshakeVersion', 'initAd', 'startAd', 'stopAd', 'resizeAd', 'pauseAd', 'expandAd', 'collapseAd'
	  ];

	  for (var i = 0, len = VPAIDInterfaceMethods.length; i < len; i++) {
	    if (!VPAIDAdUnit || !utilities.isFunction(VPAIDAdUnit[VPAIDInterfaceMethods[i]])) {
	      return false;
	    }
	  }


	  return canSubscribeToEvents(VPAIDAdUnit) && canUnsubscribeFromEvents(VPAIDAdUnit);

	  /*** Local Functions ***/

	  function canSubscribeToEvents(adUnit) {
	    return utilities.isFunction(adUnit.subscribe) || utilities.isFunction(adUnit.addEventListener) || utilities.isFunction(adUnit.on);
	  }

	  function canUnsubscribeFromEvents(adUnit) {
	    return utilities.isFunction(adUnit.unsubscribe) || utilities.isFunction(adUnit.removeEventListener) || utilities.isFunction(adUnit.off);

	  }
	};

	VPAIDAdUnitWrapper.prototype.adUnitAsyncCall = function () {
	  var args = utilities.arrayLikeObjToArray(arguments);
	  var method = args.shift();
	  var cb = args.pop();
	  var timeoutId;

	  sanityCheck(method, cb, this._adUnit);
	  args.push(wrapCallback());

	  this._adUnit[method].apply(this._adUnit, args);
	  timeoutId = setTimeout(function () {
	    timeoutId = null;
	    cb(new VASTError("on VPAIDAdUnitWrapper, timeout while waiting for a response on call '" + method + "'"));
	    cb = utilities.noop;
	  }, this.options.responseTimeout);

	  /*** Local functions ***/
	  function sanityCheck(method, cb, adUnit) {
	    if (!utilities.isString(method) || !utilities.isFunction(adUnit[method])) {
	      throw new VASTError("on VPAIDAdUnitWrapper.adUnitAsyncCall, invalid method name");
	    }

	    if (!utilities.isFunction(cb)) {
	      throw new VASTError("on VPAIDAdUnitWrapper.adUnitAsyncCall, missing callback");
	    }
	  }

	  function wrapCallback() {
	    return function () {
	      if (timeoutId) {
	        clearTimeout(timeoutId);
	      }
	      cb.apply(this, arguments);
	    };
	  }
	};

	VPAIDAdUnitWrapper.prototype.on = function (evtName, handler) {
	  var addEventListener = this._adUnit.addEventListener || this._adUnit.subscribe || this._adUnit.on;
	  addEventListener.call(this._adUnit, evtName, handler);
	};

	VPAIDAdUnitWrapper.prototype.off = function (evtName, handler) {
	  var removeEventListener = this._adUnit.removeEventListener || this._adUnit.unsubscribe || this._adUnit.off;
	  removeEventListener.call(this._adUnit, evtName, handler);
	};

	VPAIDAdUnitWrapper.prototype.waitForEvent = function (evtName, cb, context) {
		  var that = this;
	  var timeoutId;
	  sanityCheck(evtName, cb);
	  context = context || null;

	  this.on(evtName, responseListener);

	  timeoutId = setTimeout(function () {
		  that.off(evtName, responseListener);
			// ignore events if ad is finished
			if (window._timeoutIds.indexOf(timeoutId) >= 0) {
	      if (that.options && that.options.player) {
	        that.options.player.trigger({type: 'trace.message', data: {message: 'Timeout while waiting for event ' + evtName}});
	      }
				cb(new VASTError("on VPAIDAdUnitWrapper.waitForEvent, timeout while waiting for event '" + evtName + "'"));
			}
	    timeoutId = null;
	    cb = utilities.noop;
	  }, this.options.responseTimeout);

	  // EN
	  window._timeoutIds.push(timeoutId);

	  /*** Local functions ***/
	  function sanityCheck(evtName, cb) {
	    if (!utilities.isString(evtName)) {
	      throw new VASTError("on VPAIDAdUnitWrapper.waitForEvent, missing evt name");
	    }

	    if (!utilities.isFunction(cb)) {
	      throw new VASTError("on VPAIDAdUnitWrapper.waitForEvent, missing callback");
	    }
	  }

	  function responseListener() {
	    if (that.options && that.options.player) {
	      that.options.player.trigger({type: 'trace.event', data: {event: evtName}});
	    }
		  that.off(evtName, responseListener);
	    var args = utilities.arrayLikeObjToArray(arguments);

	    if (timeoutId) {
	      clearTimeout(timeoutId);
	      timeoutId = null;
	    }

	    args.unshift(null);
	    cb.apply(context, args);
	  }
	};

	// VPAID METHODS
	VPAIDAdUnitWrapper.prototype.handshakeVersion = function (version, cb) {
	  this.adUnitAsyncCall('handshakeVersion', version, cb);
	};

	/* jshint maxparams:6 */
	VPAIDAdUnitWrapper.prototype.initAd = function (width, height, viewMode, desiredBitrate, adUnitData, cb) {
		console.log('[BC-MOL] VPAIDAdUnitWrapper->Calling initAd on creative');
		this.waitForEvent('AdLoaded', cb);
	  this._adUnit.initAd(width, height, viewMode, desiredBitrate, adUnitData);
	};

	VPAIDAdUnitWrapper.prototype.resizeAd = function (width, height, viewMode, cb) {
	  // NOTE: AdSizeChange event is only supported on VPAID 2.0 so for the moment we are not going to use it
	  // and will assume that everything is fine after the async call
		console.log('[BC-MOL] VPAIDAdUnitWrapper->Calling resizeAd on creative');
	  this.adUnitAsyncCall('resizeAd', width, height, viewMode, cb);
	  if (window.MoatApiReference) {
	  	window.MoatApiReference.dispatchEvent({type: 'AdSizeChange', adVolume: this.options.player.volume()});
	  }
	};

	VPAIDAdUnitWrapper.prototype.startAd = function (cb) {
		console.log('[BC-MOL] VPAIDAdUnitWrapper->Calling startAd on creative');
		if (!this.adStarted) {
			this.waitForEvent('AdStarted', cb);
		}
	  this._adUnit.startAd();
	  if (this.adStarted) {
	    cb(null);
	  }
	};

	VPAIDAdUnitWrapper.prototype.stopAd = function (cb) {
		console.log('[BC-MOL] VPAIDAdUnitWrapper->Calling stopAd on creative');
	  this.waitForEvent('AdStopped', cb);
	  this._adUnit.stopAd();
	};

	VPAIDAdUnitWrapper.prototype.pauseAd = function (cb) {
		console.log('[BC-MOL] VPAIDAdUnitWrapper->Calling pauseAd on creative');
	  this.waitForEvent('AdPaused', cb);
	  this._adUnit.pauseAd();
	};

	VPAIDAdUnitWrapper.prototype.resumeAd = function (cb) {
		console.log('[BC-MOL] VPAIDAdUnitWrapper->Calling resumeAd on creative');
	  this.waitForEvent('AdPlaying', cb);
	  this._adUnit.resumeAd();
	};

	VPAIDAdUnitWrapper.prototype.expandAd = function (cb) {
		console.log('[BC-MOL] VPAIDAdUnitWrapper->Calling expandAd on creative');
	  this.waitForEvent('AdExpandedChange', cb);
	  this._adUnit.expandAd();
	};

	VPAIDAdUnitWrapper.prototype.collapseAd = function (cb) {
		console.log('[BC-MOL] VPAIDAdUnitWrapper->Calling collapseAd on creative');
	  this.waitForEvent('AdExpandedChange', cb);
	  this._adUnit.collapseAd();
	};

	VPAIDAdUnitWrapper.prototype.skipAd = function (cb) {
		console.log('[BC-MOL] VPAIDAdUnitWrapper->Calling skipAd on creative');
	  this.waitForEvent('AdSkipped', cb);
	  this._adUnit.skipAd();
	};

	//VPAID property getters
	[
	  'adLinear',
	  'adWidth',
	  'adHeight',
	  'adExpanded',
	  'adSkippableState',
	  'adRemainingTime',
	  'adDuration',
	  'adVolume',
	  'adCompanions',
	  'adIcons'
	].forEach(function (property) {
	  var getterName = 'get' + utilities.capitalize(property);

	  VPAIDAdUnitWrapper.prototype[getterName] = function (cb) {
	    this.adUnitAsyncCall(getterName, cb);
	  };
	});

	//VPAID property setters
	VPAIDAdUnitWrapper.prototype.setAdVolume = function(volume, cb){
	  this.adUnitAsyncCall('setAdVolume',volume, cb);
	};

	module.exports = VPAIDAdUnitWrapper;

	},{"../../utils/utilityFunctions":45,"../vast/VASTError":19}],30:[function(require,module,exports){
	'use strict';

	var MimeTypes = require('../../utils/mimetypes');

	var VASTError = require('../vast/VASTError');

	var VPAIDHTML5Client = require('VPAIDHTML5Client/js/VPAIDHTML5Client');

	var utilities = require('../../utils/utilityFunctions');
	var dom = require('../../utils/dom');

	var logger = require ('../../utils/consoleLogger');

	function VPAIDHTML5Tech(mediaFile) {

	  if(!(this instanceof VPAIDHTML5Tech)) {
	    return new VPAIDHTML5Tech(mediaFile);
	  }

	  sanityCheck(mediaFile);

	  this.name = 'vpaid-html5';
	  this.containerEl = null;
	  this.videoEl = null;
	  this.vpaidHTMLClient = null;

	  this.mediaFile = mediaFile;

	  function sanityCheck(mediaFile) {
	      if (!mediaFile || !utilities.isString(mediaFile.src)) {
	        throw new VASTError(VPAIDHTML5Tech.INVALID_MEDIA_FILE);
	      }
	  }
	}

	VPAIDHTML5Tech.VPAIDHTML5Client = VPAIDHTML5Client;

	VPAIDHTML5Tech.supports = function (type) {
	  return !utilities.isOldIE() && MimeTypes.html5.indexOf(type) > -1;
	};

	VPAIDHTML5Tech.prototype.loadAdUnit = function loadAdUnit(containerEl, videoEl, callback) {
	  sanityCheck(containerEl, videoEl, callback);

	  this.containerEl = containerEl;
	  this.videoEl = videoEl;
	  this.vpaidHTMLClient = new VPAIDHTML5Tech.VPAIDHTML5Client(containerEl, videoEl, {});
	  this.vpaidHTMLClient.loadAdUnit(this.mediaFile.src, callback);

	  function sanityCheck(container, video, cb) {
	    if (!dom.isDomElement(container)) {
	      throw new VASTError(VPAIDHTML5Tech.INVALID_DOM_CONTAINER_EL);
	    }

	    if (!dom.isDomElement(video) || video.tagName.toLowerCase() !== 'video') {
	      throw new VASTError(VPAIDHTML5Tech.INVALID_DOM_CONTAINER_EL);
	    }

	    if (!utilities.isFunction(cb)) {
	      throw new VASTError(VPAIDHTML5Tech.MISSING_CALLBACK);
	    }
	  }
	};

	VPAIDHTML5Tech.prototype.unloadAdUnit = function unloadAdUnit() {
	  if (this.vpaidHTMLClient) {
	    try {
	      this.vpaidHTMLClient.destroy();
	    } catch(e) {
	      logger.error ('VAST ERROR: trying to unload the VPAID adunit');
	    }

	    this.vpaidHTMLClient = null;
	  }

	  if (this.containerEl) {
	    dom.remove(this.containerEl);
	    this.containerEl = null;
	  }
	};

	var PREFIX = 'on VPAIDHTML5Tech';
	VPAIDHTML5Tech.INVALID_MEDIA_FILE = PREFIX + ', invalid MediaFile';
	VPAIDHTML5Tech.INVALID_DOM_CONTAINER_EL = PREFIX + ', invalid container HtmlElement';
	VPAIDHTML5Tech.INVALID_DOM_VIDEO_EL = PREFIX + ', invalid HTMLVideoElement';
	VPAIDHTML5Tech.MISSING_CALLBACK = PREFIX + ', missing valid callback';

	module.exports = VPAIDHTML5Tech;

	},{"../../utils/consoleLogger":39,"../../utils/dom":40,"../../utils/mimetypes":42,"../../utils/utilityFunctions":45,"../vast/VASTError":19,"VPAIDHTML5Client/js/VPAIDHTML5Client":3}],31:[function(require,module,exports){
	'use strict';

	var MimeTypes = require('../../utils/mimetypes');
	var VASTError = require('../vast/VASTError');
	var VASTResponse = require('../vast/VASTResponse');
	var VASTTracker = require('../vast/VASTTracker');
	var vastUtil = require('../vast/vastUtil');

	var VPAIDAdUnitWrapper = require('./VPAIDAdUnitWrapper');

	var async = require('../../utils/async');
	var dom = require('../../utils/dom');
	var playerUtils = require('../../utils/playerUtils');
	var utilities = require('../../utils/utilityFunctions');

	var logger = require ('../../utils/consoleLogger');

	function VPAIDIntegrator(player, settings) {
	  if (!(this instanceof VPAIDIntegrator)) {
	    return new VPAIDIntegrator(player);
	  }

	  this.VIEW_MODE = {
	    NORMAL: 'normal',
	    FULLSCREEN: "fullscreen",
	    THUMBNAIL: "thumbnail"
	  };
	  this.player = player;
	  this.containerEl = createVPAIDContainerEl(player);
	  this.options = {
	    responseTimeout: 5000,
	    VPAID_VERSION: '2.0'
	  };
	  this.settings = settings;
	  
	  this.contentSource = player.tech_.el_.src;
	  this.needsShowPlayer = false;
	  
	  this.errorHasBeenTracked = false;
	  this.adFinished = false;
	  
	  this.timeUpdateTimer = null;
	  
	  /*** Local functions ***/

	  function createVPAIDContainerEl() {
	    var containerEl = document.createElement('div');
	    containerEl.id = 'BC-VPAID-container';
	    dom.addClass(containerEl, 'VPAID-container');
	    player.el().insertBefore(containerEl, player.controlBar.el());
	    return containerEl;
	  }
	}

	VPAIDIntegrator.prototype.playAd = function playVPaidAd(vastResponse, callback) {
	  if (!(vastResponse instanceof VASTResponse)) {
	    return callback(new VASTError('on VASTIntegrator.playAd, missing required VASTResponse'));
	  }

	  var that = this;
	  var player = this.player;
	  logger.debug ("<VPAIDIntegrator.playAd> looking for supported tech...");
	  var tech = this._findSupportedTech(vastResponse, this.settings);

	  callback = callback || utilities.noop;

	  this._adUnit = null;

	  dom.addClass(player.el(), 'vjs-vpaid-ad');
	  
	  player.on('vast.adsCancel', triggerVpaidAdEnd);
	  player.one('vpaid.adEnd', function(){
	    player.off('vast.adsCancel', triggerVpaidAdEnd);
	    removeAdUnit();
	  });

	  if (tech) {
	    logger.info ("<VPAIDIntegrator.playAd> found tech: ", tech);

	    async.waterfall([
	      function (next) {
	        next(null, tech, vastResponse);
	      },
	      this._loadAdUnit.bind(this),
	      this._playAdUnit.bind(this),
	      this._finishPlaying.bind(this)

	    ], adComplete);

	    this._adUnit = {
	      _paused: true,
	      type: 'VPAID',
	      pauseAd: function() {
	        player.trigger('vpaid.pauseAd');
	        player.pause(true);//we make sure that the video content gets stopped.
	      },
	      resumeAd: function() {
	          player.trigger('vpaid.resumeAd');
	      },
	      isPaused: function() {
	        return this._paused;
	      },
	      getSrc: function() {
	        return tech.mediaFile;
	      }
	    };

	  } else {
	    logger.debug ("<VPAIDIntegrator.playAd> could not find suitable tech");
	    var error = new VASTError('on VPAIDIntegrator.playAd, could not find a supported mediaFile', 403);
	    adComplete(error, this._adUnit, vastResponse);
	  }

	  return this._adUnit;

	  /*** Local functions ***/
	  function adComplete(error, adUnit, vastResponse) {
	    if (error && vastResponse) {
	      that._trackError(vastResponse, error.code);
	    }
	    player.trigger('vpaid.adEnd');
	    callback(error, vastResponse);
	  }

	  function triggerVpaidAdEnd(){
		    //player.trigger('stopAd');
	    player.trigger('vpaid.adEnd');
	  }

	  function removeAdUnit() {
	    if (tech) {
	    	console.log('[BC-MOL] VPAIDIntegrator->Calling unloadAdUnit (implicitly invokes stopAd and unsubscribes VPAID events)');
	      tech.unloadAdUnit();
	    }
	    dom.removeClass(player.el(), 'vjs-vpaid-ad');
	  }
	};

	VPAIDIntegrator.prototype._findSupportedTech = function (vastResponse, settings) {
	  if (!(vastResponse instanceof VASTResponse)) {
	    return null;
	  }

	  var vpaidMediaFiles = vastResponse.mediaFiles.filter(vastUtil.isVPAID);
	  var preferredTech = settings && settings.preferredTech;
	  var skippedSupportTechs = [];
	  var i, len, mediaFile, VPAIDTech, isPreferedTech;

	  for (i = 0, len = vpaidMediaFiles.length; i < len; i += 1) {
	    mediaFile = vpaidMediaFiles[i];
	    VPAIDTech = vastUtil.findSupportedVPAIDTech(mediaFile.type);

	    // no supported VPAID tech found, skip mediafile
	    if (!VPAIDTech) { continue; }

	    // do we have a prefered tech, does it play this media file ?
	    isPreferedTech = preferredTech ?
	      (mediaFile.type === preferredTech || (MimeTypes[preferredTech] && MimeTypes[preferredTech].indexOf(mediaFile.type) > -1 )) :
	      false;

	    // our prefered tech can read this mediafile, defaulting to it.
	    if (isPreferedTech) {
	      return new VPAIDTech(mediaFile, settings);
	    }

	    skippedSupportTechs.push({ mediaFile: mediaFile, tech: VPAIDTech });
	  }

	  if (skippedSupportTechs.length) {
	    var firstTech = skippedSupportTechs[0];
	    return new firstTech.tech(firstTech.mediaFile, settings);
	  }

	  return null;
	};

	VPAIDIntegrator.prototype._createVPAIDAdUnitWrapper = function(adUnit, src, responseTimeout, player) {
		return new VPAIDAdUnitWrapper(adUnit, {src: src, responseTimeout: responseTimeout, player: player});
	};

	VPAIDIntegrator.prototype._loadAdUnit = function (tech, vastResponse, next) {
	  var that = this;
	  var player = this.player;
	  var vjsTechEl = player.el().querySelector('.vjs-tech');
	  //var responseTimeout = this.settings.responseTimeout || this.options.responseTimeout;
	  var responseTimeout = this.settings.adCancelTimeout || this.options.responseTimeout;
	  tech.loadAdUnit(this.containerEl, vjsTechEl, function (error, adUnit) {
	    if (error) {
	      return next(error, adUnit, vastResponse);
	    }

	    try {
	      var frms = document.getElementsByTagName('IFRAME');
	      if (frms && frms.length > 0) {
	        frms[0].addEventListener('mouseover', function() {
	          //console.log("****** user activity");
	            player.userActive(true);
	            if (!dom.hasClass(player.el(), 'vjs-has-started')) {
	                dom.addClass(player.el(), 'vjs-has-started');
	            }
	          });
	        }
	        player.trigger({type: 'trace.message', data: {message: 'Playing ' + tech.mediaFile.src + ' (type = ' + tech.mediaFile.type + 
	      	  ', apiFramework = ' + tech.mediaFile.apiFramework + ')'}});
	      var WrappedAdUnit = that._createVPAIDAdUnitWrapper(adUnit, tech.mediaFile.src, responseTimeout, player);
	      var techClass = 'vjs-' + tech.name + '-ad';
	      dom.addClass(player.el(), techClass);
	      player.one('vpaid.adEnd', function() {
	        dom.removeClass(player.el(),techClass);
	      });
	      next(null, WrappedAdUnit, vastResponse);
	    } catch (e) {
	      next(e, adUnit, vastResponse);
	    }
	  });
	};

	VPAIDIntegrator.prototype._playAdUnit = function (adUnit, vastResponse, callback) {
	  async.waterfall([
	    function (next) {
	      next(null, adUnit, vastResponse);
	    },
	    this._handshake.bind(this),
	    this._setupEvents.bind(this),
	    this._initAd.bind(this),
	    //this._setupEvents.bind(this),
	    this._addSkipButton.bind(this),
	    this._linkPlayerControls.bind(this),
	    this._startAd.bind(this)
	  ], callback);
	};

	VPAIDIntegrator.prototype._handshake = function handshake(adUnit, vastResponse, next) {
	  adUnit.handshakeVersion(this.options.VPAID_VERSION, function (error, version) {
	    if (error) {
	      return next(error, adUnit, vastResponse);
	    }

	    if (version && isSupportedVersion(version)) {
	      return next(null, adUnit, vastResponse);
	    }

	    return next(new VASTError('on VPAIDIntegrator._handshake, unsupported version "' + version + '"'), adUnit, vastResponse);
	  });

	  function isSupportedVersion(version) {
	    var majorNum = major(version);
	    return majorNum >= 1 && majorNum <= 2;
	  }

	  function major(version) {
	    var parts = version.split('.');
	    return parseInt(parts[0], 10);
	  }
	};

	VPAIDIntegrator.prototype._initAd = function (adUnit, vastResponse, next) {
	  var tech = this.player.el().querySelector('.vjs-tech');
	  var dimension = dom.getDimension(tech);
	  adUnit.initAd(dimension.width, dimension.height, this.VIEW_MODE.NORMAL, -1, {AdParameters: vastResponse.adParameters || ''}, function (error) {
	    next(error, adUnit, vastResponse);
	  });
	};

	VPAIDIntegrator.prototype._createVASTTracker = function(adUnitSrc, vastResponse) {
	  return new VASTTracker(adUnitSrc, vastResponse);
	};

	VPAIDIntegrator.prototype._setupEvents = function (adUnit, vastResponse, next) {
	  var adUnitSrc = adUnit.options.src;
	  var tracker = this._createVASTTracker(adUnitSrc, vastResponse);
	  var player = this.player;
	  var contentSource = this.contentSource;
	  var that = this;
	  
	  this.tracker = tracker;
	  
	  this.impressionTriggered = false;

	  adUnit.on('AdSkipped', function () {
		  	player.trigger({type: 'trace.event', data: {event: 'vpaid.AdSkipped'}});
		      if (window.MoatApiReference) {
		    	  window.MoatApiReference.dispatchEvent({type: 'AdSkipped', adVolume: player.volume()});
		      }
	    player.trigger('vpaid.AdSkipped');
	    tracker.trackSkip();
	    playerUtils.showBigPlayButton(player, false);
	    
	    adUnit.stopAd(utilities.noop);
	    // VIDLA-2676 - force player to clean resources
	  	setTimeout(function() {
	        player.trigger('vast.adsCancel');
	  	}, 1);
	    //player.trigger('adStop');
	  });

	  function triggerImpression() {
		  if (!that.impressionTriggered) {
			  that.impressionTriggered = true;
		      if (window.MoatApiReference) {
		    	  window.MoatApiReference.dispatchEvent({type: 'AdImpression', adVolume: player.volume()});
		      }
			  player.trigger({type: 'trace.event', data: {event: 'vpaid.AdImpression'}});
			  player.trigger('vpaid.AdImpression');
			  tracker.trackImpressions();
		  }
	  }
	  adUnit.on('AdImpression', function () {
		  triggerImpression();
	  });

	  adUnit.on('AdStarted', function () {
		  if (adUnit.adStarted) {
			  // ignore second AdStarted event
			  return;
		  }
	    if (window._molSettings.viewabilityTracking) {
	      window._molSettings.viewabilityTracking.init(window._molSettings.viewability.contextId, 
	          player.duration(), player.el_.offsetWidth, player.el_.offsetHeight);
	    }
	    adUnit.adStarted = true;
	    if (!dom.hasClass(player.el(), 'vjs-has-started')) {
	      dom.addClass(player.el(), 'vjs-has-started');
	    }
	    player.trigger('vpaid.AdStarted');
	    tracker.trackCreativeView();
	    if (!window._molSettings.playsInBreak && adUnit.getAdDuration) {
	      adUnit.getAdDuration(function(that, dur) {
	        if (dur > 0) {
	          player.duration(dur);
	        }
	      });
	    }
	  	triggerImpression();
	    notifyPlayToPlayer();
	    player.one('adStop', function() {
	      if (adUnit.stopAd) {
	        adUnit.stopAd(utilities.noop);
	      }
	    });
	    
	    if (utilities.isIDevice()) {
	    	// VIDLA-2836 (Ad click thru does not landing click thru url)
	    	// iPhone and iPad
	    	var elems = document.getElementsByClassName('vjs-resize-manager');
	    	if (elems && elems.length > 0) {
	    		var parent = elems[0].parentElement;
	    		if (parent) {
	    			parent.removeChild(elems[0]);
	    		}
	    	}
	    }

	  });

	  function updateTimeControls() {
		  	var convertTimeToStr = function(time) {
				var secs = parseInt(time + 0.5);
				var mins = parseInt(secs / 60);
				secs -= (mins * 60);
				var str = mins.toString() + ':' + (secs > 9 ? ''  : '0') + secs.toString();
				return str;
			};
			
			var bcTimeDisplay = document.getElementById('bc_time_display');
			if (!bcTimeDisplay) {
				bcTimeDisplay = document.createElement('div');
				player.controlBar.getChild('currentTimeDisplay').el_.appendChild(bcTimeDisplay);
				bcTimeDisplay.id = 'bc_time_display';
				bcTimeDisplay.class = 'vjs-current-time-display';
				bcTimeDisplay['aria-live'] = 'off';
				bcTimeDisplay.innerHTML = '<span class="vjs-control-text"></span>0:00';
	      showOriginalTimeDisplay(player, false);
			}
			else {
	      showOriginalTimeDisplay(player, false);
				bcTimeDisplay.style.display = 'block';
			}
			adUnit.getAdRemainingTime(function(that, time) {
				if (time >= 0) {
					var curTime = player.duration() - time;
					if (curTime >= 0) {
						bcTimeDisplay.childNodes[1].nodeValue = convertTimeToStr(curTime);
					}
				}
			});
	  }
		  
	  adUnit.on('AdVideoStart', function () {
		  player.trigger({type: 'trace.event', data: {event: 'AdVideoStart'}});
	      if (window.MoatApiReference) {
	    	  window.MoatApiReference.dispatchEvent({type: 'AdVideoStart', adVolume: player.volume()});
	      }

	    player.trigger('vpaid.AdVideoStart');
	    tracker.trackStart();
		if (!window._molSettings.playsInBreak && adUnit.getAdDuration) {
			adUnit.getAdDuration(function(that, dur) {
				if (dur > 0) {
					player.duration(dur);
				}
			});
		}
	    notifyPlayToPlayer();
	    playerUtils.showBigPlayButton(player, false);
	    if (utilities.isMobile()) {
	        // VIDLA-2336 (simulate user activity to make sure control bar is visible on mobile devices)
	        for (var i = 0; i < 4; i++) {
	        	setTimeout(function() {
	        		document.getElementsByTagName('IFRAME')[0].dispatchEvent(new Event('mouseover'));
	        	}, i * 1000);
	        }
	    }
	    if (contentSource === player.tech_.el_.src) {
	        player.trigger({type: 'trace.message', data: {message: 'VPAID creative uses its own video tag'}});
	        //player.tech_.el_.style.display = 'none';
	        //player.controlBar.hide();
	        that.needsShowPlayer = true;
	    	if (!window._molSettings.playsInBreak) {
	    		that.timeUpdateTimer = setInterval(updateTimeControls, 500);
	      }
	      else {
	        player.controlBar.hide();
	      }
	    }
	  });

	  adUnit.on('AdPlaying', function () {
		  if (that.adFinished) {
			  return;
		  }
	      if (window.MoatApiReference) {
	    	  window.MoatApiReference.dispatchEvent({type: 'AdPlaying', adVolume: player.volume()});
	      }
	    player.trigger('vpaid.AdPlaying');
	    tracker.trackResume();
	    notifyPlayToPlayer();
	    playerUtils.showBigPlayButton(player, false);
	  });

	  adUnit.on('AdPaused', function () {
		  if (that.adFinished) {
			  return;
		  }
	      if (window.MoatApiReference) {
	    	  window.MoatApiReference.dispatchEvent({type: 'AdPaused', adVolume: player.volume()});
	      }
	    player.trigger('vpaid.AdPaused');
	    tracker.trackPause();
	    notifyPauseToPlayer();
		  var iframeBackButton = window.document.getElementById('iframeBackButton');
		  if (iframeBackButton) {
			  playerUtils.showBigPlayButton(player, false);
			  return;
		  }
	    playerUtils.showBigPlayButton(player, true);
	  });

	  function notifyPlayToPlayer(){
	    if(that._adUnit && that._adUnit.isPaused()){
	      that._adUnit._paused = false;
	    }
	    player.trigger('play');

	  }

	  function notifyPauseToPlayer() {
	    if(that._adUnit){
	      that._adUnit._paused = true;
	    }
	    player.trigger('pause');
	  }

	  adUnit.on('AdVideoFirstQuartile', function () {
		  if (that.adFinished) {
			  return;
		  }
			player.trigger({type: 'trace.event', data: {event: 'vpaid.AdVideoFirstQuartile'}});
	    if (window.MoatApiReference) {
	    	window.MoatApiReference.dispatchEvent({type: 'AdVideoFirstQuartile', adVolume: player.volume()});
	    }
	    player.trigger('vpaid.AdVideoFirstQuartile');
	    tracker.trackFirstQuartile();
	  });

	  adUnit.on('AdVideoMidpoint', function () {
		  if (that.adFinished) {
			  return;
		  }
			player.trigger({type: 'trace.event', data: {event: 'vpaid.AdVideoMidpoint'}});
	    if (window.MoatApiReference) {
	    	window.MoatApiReference.dispatchEvent({type: 'AdVideoMidpoint', adVolume: player.volume()});
	    }
	    player.trigger('vpaid.AdVideoMidpoint');
	    tracker.trackMidpoint();
	  });

	  adUnit.on('AdVideoThirdQuartile', function () {
		  if (that.adFinished) {
			  return;
		  }
			player.trigger({type: 'trace.event', data: {event: 'vpaid.AdVideoThirdQuartile'}});
	    if (window.MoatApiReference) {
	    	window.MoatApiReference.dispatchEvent({type: 'AdVideoThirdQuartile', adVolume: player.volume()});
	    }
	    player.trigger('vpaid.AdVideoThirdQuartile');
	    tracker.trackThirdQuartile();
	  });

	  adUnit.on('AdVideoComplete', function () {
		  if (that.adFinished) {
			  return;
		  }
			player.trigger({type: 'trace.event', data: {event: 'vpaid.AdVideoComplete'}});
	    player.trigger('vpaid.AdVideoComplete');
	    tracker.trackComplete();
	    playerUtils.showBigPlayButton(player, false);
	    if (window.MoatApiReference) {
	  	  window.MoatApiReference.dispatchEvent({type: 'AdVideoComplete', adVolume: player.volume()});
	    }
	    // VIDLA-2406 forse ad to stop
	    if (adUnit.stopAd) {
	      adUnit.stopAd(utilities.noop);
	    }
	  });

	  adUnit.on('AdClickThru', function (data) {
		  if (that.adFinished) {
			  return;
		  }
		  var enableFullscreenClickIFrame = false;
		player.trigger({type: 'trace.event', data: {event: 'vpaid.AdClickThru'}});
	      if (window.MoatApiReference) {
	    	  window.MoatApiReference.dispatchEvent({type: 'AdClickThru', adVolume: player.volume()});
	      }
	    player.trigger('vpaid.AdClickThru');
	    var url = data.url;
	    var playerHandles = data.playerHandles;
	    var clickThruUrl = utilities.isNotEmptyString(url) ? url : generateClickThroughURL(vastResponse.clickThrough);

		if (playerHandles && window._molSettings.disableClickThru) {
			return;
		}
		
	    tracker.trackClick();
	    if (playerHandles && clickThruUrl) {
	    	if (player.isFullscreen() && enableFullscreenClickIFrame) {
	    		addClickThroughDivBlocker(clickThruUrl);
	    	}
	    	else {
	    		window.open(clickThruUrl, '_blank');
	    	}
	    }
	    
	    // VIDLA-2269 (Ad does not pause when browsing out to a click url from a vpaid ad)
	    adUnit.pauseAd(utilities.noop);

	    function generateClickThroughURL(clickThroughMacro) {
	      var variables = {
	        ASSETURI: adUnit.options.src,
	        CONTENTPLAYHEAD: 0 //In VPAID there is no method to know the current time from the adUnit
	      };

	      return clickThroughMacro ? vastUtil.parseURLMacro(clickThroughMacro, variables) : null;
	    }
	  });

	  adUnit.on('AdUserAcceptInvitation', function () {
			player.trigger({type: 'trace.event', data: {event: 'vpaid.AdUserAcceptInvitation'}});
	    player.trigger('vpaid.AdUserAcceptInvitation');
	    tracker.trackAcceptInvitation();
	    tracker.trackAcceptInvitationLinear();
	  });

	  adUnit.on('AdUserClose', function () {
			player.trigger({type: 'trace.event', data: {event: 'vpaid.AdUserClose'}});
		      if (window.MoatApiReference) {
		    	  window.MoatApiReference.dispatchEvent({type: 'AdUserClose', adVolume: player.volume()});
		      }
	    player.trigger('vpaid.AdUserClose');
	    tracker.trackClose();
	    tracker.trackCloseLinear();
	  });

	  adUnit.on('AdUserMinimize', function () {
			player.trigger({type: 'trace.event', data: {event: 'vpaid.AdUserMinimize'}});
	    player.trigger('vpaid.AdUserMinimize');
	    tracker.trackCollapse();
	  });

	  adUnit.on('AdError', function () {
		  if (that.adFinished) {
			  return;
		  }
		  // VIDLA-2389 suppress eror tracking after ad impression has been reported
		  if (!that.impressionTriggered && !that.errorHasBeenTracked) {
			  player.trigger({type: 'trace.event', data: {event: 'vpaid.AdError'}});
		      if (window.MoatApiReference) {
		    	  window.MoatApiReference.dispatchEvent({type: 'AdError', adVolume: player.volume()});
		      }
		      player.trigger('vpaid.AdError');
		    //NOTE: we track errors code 901, as noted in VAST 3.0
		    tracker.trackErrorWithCode(901);
		    that.errorHasBeenTracked = true;
		  }
		  playerUtils.showBigPlayButton(player, false);
	  });

	  adUnit.on('AdVolumeChange', function () {
			player.trigger({type: 'trace.event', data: {event: 'vpaid.AdVolumeChange'}});
	    player.trigger('vpaid.AdVolumeChange');
	    var lastVolume = player.volume();
	    adUnit.getAdVolume(function (error, currentVolume) {
	      if (lastVolume !== currentVolume) {
	        if (currentVolume === 0 && lastVolume > 0) {
	          tracker.trackMute();
	        }

	        if (currentVolume > 0 && lastVolume === 0) {
	          tracker.trackUnmute();
	        }

	        player.volume(currentVolume);
	      }
	    });
	  });

	  adUnit.on('AdSizeChange', function () {
		  if (player.vast && player.vast.needSyncPlay) {
			  if (player.paused() !== player.tech_.el_.paused) {
	        // ad uses main content tag
	        if (contentSource != player.tech_.el_.src) {
	          if (player.tech_.el_.paused) {
	            if (window.MoatApiReference) {
	                window.MoatApiReference.dispatchEvent({type: 'AdPaused', adVolume: player.volume()});
	            }
	            notifyPauseToPlayer();
	            playerUtils.showBigPlayButton(player, true);
	          }
	          else {
	            if (window.MoatApiReference) {
	                window.MoatApiReference.dispatchEvent({type: 'AdPlaying', adVolume: player.volume()});
	            }
	            notifyPlayToPlayer();
	            playerUtils.showBigPlayButton(player, false);
	          }
	        }
			  }
			  player.vast.needSyncPlay = false;
		  } 
	  });

	  function addClickThroughDivBlocker(clickThruUrl) {
		  var blocker = createClickThroughDiv(player, clickThruUrl);
		  var iFrame;
		  var iFrameBackButton;

		  player.el().insertBefore(blocker, player.controlBar.el());

		  player.on('fullscreenchange', updateDisplayStyle);

		  function createClickThroughDiv(player, url) {
		    var blocker = window.document.createElement("div");

		    dom.addClass(blocker, 'vast-blocker');

		    if (window.MoatApiReference) {
	    	  window.MoatApiReference.dispatchEvent({type: 'AdClickThru', adVolume: player.volume()});
		    }
	      
		    // create IFrame with back button
		    iFrame = window.document.createElement("iframe");
		    dom.addClass(iFrame, 'vast-blocker');
		    iFrame.src = url;
		    blocker.appendChild(iFrame);
		  
		    iFrameBackButton = window.document.createElement("div");
		    dom.addClass(iFrameBackButton, "vast-back-button");
		    dom.addClass(iFrameBackButton, 'enabled');
		    iFrameBackButton.innerHTML = "Back";
		    iFrameBackButton.id = 'iframeBackButton';
		    blocker.appendChild(iFrameBackButton);
		    iFrameBackButton.addEventListener ("click", function(e) {
			  // show controls
			  var skipButton = window.document.getElementById('adSkipButton');
			  if (skipButton) {
				  skipButton.style.display = 'block'; 
			  }
			  player.controls(true);
			  
			  player.el().removeChild(blocker);
			  resumeAdUnit();
			  
			  if (window.Event.prototype.stopPropagation !== undefined) {
		          e.stopPropagation();
			  }
		    });
			  
		    // hide controls
		    setTimeout(function() {
			  playerUtils.showBigPlayButton(player, false);
		    }, 1);
		    var skipButton = window.document.getElementById('adSkipButton');
		    if (skipButton) {
			  skipButton.style.display = 'none'; 
		    }
		    player.controls(false);

		    return blocker;
		  }

		  function updateDisplayStyle() {
			  if (!player.isFullscreen()) {			  
				  playerUtils.showBigPlayButton(player, true);
				  var skipButton = window.document.getElementById('adSkipButton');
				  if (skipButton) {
					  skipButton.style.display = 'none'; 
				  }
				  player.controls(true);
				  player.el().removeChild(blocker);
				  resumeAdUnit();
			  }
		  }
	  }

	  var updateViewSize = resizeAd.bind(this, player, adUnit, this.VIEW_MODE);
	  var updateViewSizeThrottled = utilities.throttle(updateViewSize, 100);
	  var autoResize = this.settings.autoResize;

	  if (autoResize) {
	    dom.addEventListener(window, 'resize', updateViewSizeThrottled);
	    dom.addEventListener(window, 'orientationchange', updateViewSizeThrottled);
	  }

	  player.on('vast.resize', updateViewSize);
	  player.on('vpaid.pauseAd', pauseAdUnit);
	  player.on('vpaid.resumeAd', resumeAdUnit);
	  player.on('stopAd', stopAdUnit);

	  player.one('vpaid.adEnd', function () {
	    player.off('vast.resize', updateViewSize);
	    player.off('vpaid.pauseAd', pauseAdUnit);
	    player.off('vpaid.resumeAd', resumeAdUnit);
	    player.off('stopAd', stopAdUnit);

	    if (autoResize) {
	      dom.removeEventListener(window, 'resize', updateViewSizeThrottled);
	      dom.removeEventListener(window, 'orientationchange', updateViewSizeThrottled);
	    }
	  });

	  next(null, adUnit, vastResponse);

	  /*** Local Functions ***/
	  function pauseAdUnit() {
	    adUnit.pauseAd(utilities.noop);
	  }

	  function resumeAdUnit() {
	    adUnit.resumeAd(utilities.noop);
	  }
	  
	  function stopAdUnit() {
	    if (adUnit.stopAd) {
	      adUnit.stopAd(utilities.noop);
	    }
	  }
	};

	VPAIDIntegrator.prototype._addSkipButton = function (adUnit, vastResponse, next) {
	  var skipButton;
	  var player = this.player;
	  var tracker = this.tracker;

	  // VIDLA-2084 (publisher-specified SKIP behavior for VPAID creatives)
	  var that = this;
	  var skipOffsetInSec;
	  var duration;
	  var remainingTime;
	  var progressInterval;
	  if (!window._molSettings.disableSkippability) {
		  if (vastResponse.skipoffset && utilities.isNumber(vastResponse.skipoffset)) {
			  skipOffsetInSec = vastResponse.skipoffset / 1000;
			  pubAddSkipButtonToPlayer(player, skipOffsetInSec);
		  }
		  else {
			  // check if publisher had explicitly disable skippability
			  var disableSkippabilityByPublisher = false;
			  if (window._molSettings && window._molSettings.skippable) {
				  if (window._molSettings.skippable.enabled === false) {
					  disableSkippabilityByPublisher = true; 
				  }
				  if (vastResponse.duration && window._molSettings.skippable.videoThreshold && 
					  vastResponse.duration < window._molSettings.skippable.videoThreshold) {
					  disableSkippabilityByPublisher = true; 
				  }
			  }
			  if (!disableSkippabilityByPublisher) {
				  adUnit.on('AdSkippableStateChange', updateSkipButtonState);
				  playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], removeSkipButton);
			  }
		  }
	  }

	  next(null, adUnit, vastResponse);

	  /*** Local function ***/
	  function updateSkipButtonState() {
	    player.trigger('vpaid.AdSkippableStateChange');
	    adUnit.getAdSkippableState(function (error, isSkippable) {
	      if (isSkippable) {
	        if (!skipButton) {
	          addSkipButton(player);
	        }
	      } else {
	        removeSkipButton(player);
	      }
	    });
	  }

	  function addSkipButton(player) {
	    skipButton = createSkipButton(player);
	    player.el().appendChild(skipButton);
	  }

	  function removeSkipButton() {
	    dom.remove(skipButton);
	    skipButton = null;
	  }

	  function createSkipButton() {
	    var skipButton = window.document.createElement("div");
	    dom.addClass(skipButton, "vast-skip-button");
	    dom.addClass(skipButton, "enabled");
	    //skipButton.innerHTML = "Skip ad";
	    skipButton.innerHTML = window._molSettings.skipButtonText;
	    skipButton.id = 'adSkipButton';

	    skipButton.onclick = function (e) {
	        adUnit.getAdSkippableState(function (error, isSkippable) {
	            if (isSkippable) {
	                adUnit.skipAd(utilities.noop);//We skip the adUnit
	            } else {
	            	tracker.trackSkip();
	                adUnit.stopAd(utilities.noop);
	            }
	          });
	      //adUnit.skipAd(utilities.noop);//We skip the adUnit

	      //We prevent event propagation to avoid problems with the clickThrough and so on
	      if (window.Event.prototype.stopPropagation !== undefined) {
	        e.stopPropagation();
	      } else {
	        return false;
	      }
	    };

	    return skipButton;
	  }
		
		// VIDLA-2084 (publisher-specified SKIP behavior for VPAID creatives)
		// EN - support publisher SKIP settings
		/*** Local function ***/
		function pubAddSkipButtonToPlayer(player, skipOffset) {
		  var skipButton = pubCreateSkipButton(player);
		  var updateSkipButton = pubUpdateSkipButtonState.bind(that, skipButton, skipOffset);
		
		  player.el().appendChild(skipButton);
		  //player.on('timeupdate', updateSkipButton);
		  progressInterval = setInterval(updateSkipButton, 500);
		
		  playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], pubRemoveSkipButton);
		
		  function removeSkipButton() {
		    //player.off('timeupdate', updateSkipButton);
		    dom.remove(skipButton);
		    skipButton = null;
		  }
		
		  function pubRemoveSkipButton() {
			  if (progressInterval) {
				  clearInterval(progressInterval);
				  progressInterval = null;
			  }
			  removeSkipButton();
		  }
		}
		
		function pubCreateSkipButton(player) {
		  var skipButton = window.document.createElement("div");
		  dom.addClass(skipButton, "vast-skip-button");
		  skipButton.style.display = 'none';
		  skipButton.id = 'adSkipButton';
		
		  skipButton.onclick = function (e) {
		    if (dom.hasClass(skipButton, 'enabled')) {
		        adUnit.getAdSkippableState(function (error, isSkippable) {
	                adUnit.skipAd(utilities.noop);//We skip the adUnit
		            if (!isSkippable) {
		            	tracker.trackSkip();
		                adUnit.stopAd(utilities.noop);
		            	setTimeout(function() {
			                player.trigger('vast.adsCancel');
		            	}, 1);
		            }
		          });
		        //adUnit.skipAd(utilities.noop);//We skip the adUnit
		    }
		    playerUtils.showBigPlayButton(player, false);
		
		    //We prevent event propagation to avoid problems with the clickThrough and so on
		    if (window.Event.prototype.stopPropagation !== undefined) {
		      e.stopPropagation();
		    } else {
		      return false;
		    }
		  };
		
		  return skipButton;
		}
		
		function pubUpdateSkipButtonState(skipButton, skipOffset) {
			//var timeLeft = Math.ceil(skipOffset - player.currentTime());
			adUnit.getAdDuration(function(that, dur) {
				if (dur > 0) {
					duration = dur;
				}
			});
			adUnit.getAdRemainingTime(function(that, time) {
				remainingTime = time; 
			});
			if (!duration || !remainingTime) {
				return;
			}
			//console.log("******: skipOffset = " + skipOffset + ", duration = " + duration + ", remainingTime = " + remainingTime);
			//var remainingTime = adUnit._adUnit.getAdRemainingTime();
			var timeLeft = Math.ceil(skipOffset - (duration - remainingTime));
		  if (timeLeft > 0) {
		      skipButton.innerHTML = '<p class="vast-skip-button-text">' + window._molSettings.skipText.replace('%%TIME%%', utilities.toFixedDigits(timeLeft, 2)) + '</p>';
		  } else {
		    if (!dom.hasClass(skipButton, 'enabled')) {
		      dom.addClass(skipButton, 'enabled');
		      skipButton.innerHTML = window._molSettings.skipButtonText;
		    }
		  }
		  var iframeBackButton = window.document.getElementById('iframeBackButton');
		  if (!iframeBackButton) {
			  if (player.isFullscreen() && utilities.isAndroid()) {
				  skipButton.style.display = 'none';
				  return;
			  }
			  skipButton.style.display = 'block';
		  }
		  //skipButton.style.display = 'block';
		}
	};

	VPAIDIntegrator.prototype._linkPlayerControls = function (adUnit, vastResponse, next) {
	  var that = this;
	  linkVolumeControl(this.player, adUnit);
	  linkFullScreenControl(this.player, adUnit, this.VIEW_MODE);

	  next(null, adUnit, vastResponse);

	  /*** Local functions ***/
	  function linkVolumeControl(player, adUnit) {
	    player.on('volumechange', updateAdUnitVolume);
	    adUnit.on('AdVolumeChange', updatePlayerVolume);

	    player.one('vpaid.adEnd', function () {
	      player.off('volumechange', updateAdUnitVolume);
	    });


	    /*** local functions ***/
	    function updateAdUnitVolume() {
	      var vol = player.muted() ? 0 : player.volume();
	      adUnit.setAdVolume(vol, logError);
	    }

	    function updatePlayerVolume() {
		  if (window.MoatApiReference) {
			  	window.MoatApiReference.dispatchEvent({type: 'AdVolumeChange', adVolume: player.volume()});
		  }
	      player.trigger('vpaid.AdVolumeChange');
	      var lastVolume = player.volume();
	      adUnit.getAdVolume(function (error, vol) {
	        if (error) {
	          logError(error);
	        } else {
	          if (lastVolume !== vol) {
	            player.volume(vol);
	          }
	        }
	      });
	    }
	  }

	  function linkFullScreenControl(player, adUnit, VIEW_MODE) {
	    var updateViewSize = resizeAd.bind(that, player, adUnit, VIEW_MODE);

	    player.on('fullscreenchange', updateViewSize);

	    player.one('vpaid.adEnd', function () {
	      player.off('fullscreenchange', updateViewSize);
	    });
	  }
	};

	VPAIDIntegrator.prototype._startAd = function (adUnit, vastResponse, next) {
	  var player = this.player;
	  var alreadyGotAdStarted = adUnit.adStarted;

	  if (alreadyGotAdStarted) {
		  player.trigger('vast.adStart');
		  player.trigger({type: 'trace.event', data: {event: 'vpaid.AdStarted'}});
	  }
	  adUnit.startAd(function (error) {
	    if (!error && !alreadyGotAdStarted) {
	      player.trigger('vast.adStart');
	    }
	    next(error, adUnit, vastResponse);
	  });
	};

	VPAIDIntegrator.prototype._finishPlaying = function (adUnit, vastResponse, next) {
	  var player = this.player;
	  var that = this;
	  adUnit.on('AdStopped', function () {
	    if (window.MoatApiReference) {
	    	  window.MoatApiReference.dispatchEvent({type: 'AdStopped', adVolume: player.volume()});
	     }
	   player.trigger('vpaid.AdStopped');
	   finishPlayingAd(null);
	  });

	  adUnit.on('AdError', function (error) {
	     if (that.impressionTriggered) {
	        finishPlayingAd(null);
	    }
	    else {
	    	var errMsg = error? error.message : 'on VPAIDIntegrator, error while waiting for the adUnit to finish playing';
	        finishPlayingAd(new VASTError(errMsg));
	    }
	  });

	  /*** local functions ***/
	  var needsShowPlayer = this.needsShowPlayer;
	  function finishPlayingAd(error) {
		  that.adFinished = true;
			playerUtils.showBigPlayButton(player, false);
			if (needsShowPlayer) {
				if (that.timeUpdateTimer) {
					clearInterval(that.timeUpdateTimer);
					that.timeUpdateTimer = null;
					var bcTimeDisplay = document.getElementById('bc_time_display');
					if (bcTimeDisplay) {
						player.controlBar.getChild('currentTimeDisplay').el_.removeChild(bcTimeDisplay);
					}
	        showOriginalTimeDisplay(player, true);
	      }
		    player.controlBar.show();
				player.tech_.el_.style.display = 'block';
			}
	    next(error, adUnit, vastResponse);
	  }
	};

	VPAIDIntegrator.prototype._trackError = function trackError(response, errorCode) {
		if (!this.errorHasBeenTracked) {
			this.errorHasBeenTracked = true;
			vastUtil.track(response.errorURLMacros, {ERRORCODE: errorCode || 901});
		}
	};

	function showOriginalTimeDisplay(player, show) {
	  var children = player.controlBar.getChild('currentTimeDisplay').el_.children;
	  for (var i = 0; i < children.length; i++) {
	    if (children[i].id != 'bc_time_display') {
	      children[i].style.display = show ? '' : 'none';
	    }
	  }
	}

	function resizeAd(player, adUnit, VIEW_MODE) {
		var skipButton = document.getElementById('adSkipButton');
	  var tech = player.el().querySelector('.vjs-tech');
	  var dimension = dom.getDimension(tech);
	  var MODE = player.isFullscreen() ? VIEW_MODE.FULLSCREEN : VIEW_MODE.NORMAL;
	  if (MODE === VIEW_MODE.NORMAL) {
	    if (player.vast) {
	      player.vast.needSyncPlay = true;
	    }
		  dimension.width = player.el_.offsetWidth;
		  dimension.height = player.el_.offsetHeight;
		  if (utilities.isAndroid() && skipButton) {
			  skipButton.style.display = 'block';
		  }
	  }
	  if (MODE === VIEW_MODE.FULLSCREEN) {
		  console.log('****** to fullscreen dimension = ' + dimension.width + ',' + dimension.height);
		  if (utilities.isAndroid() && skipButton) {
			  skipButton.style.display = 'none';
		  }
	  }
	  adUnit.resizeAd(dimension.width, dimension.height, MODE, logError);
	}

	function logError(error) {
	  if (error) {
	    logger.error ('ERROR: ' + error.message, error);
	  }
	}

	module.exports = VPAIDIntegrator;

	},{"../../utils/async":38,"../../utils/consoleLogger":39,"../../utils/dom":40,"../../utils/mimetypes":42,"../../utils/playerUtils":43,"../../utils/utilityFunctions":45,"../vast/VASTError":19,"../vast/VASTResponse":21,"../vast/VASTTracker":22,"../vast/vastUtil":28,"./VPAIDAdUnitWrapper":29}],32:[function(require,module,exports){
	'use strict';

	var dom = require('../../utils/dom');

	var element = document.createElement('div');
	element.className = 'vjs-ads-label vjs-control vjs-label-hidden';
	element.innerHTML = 'Advertisement';

	var AdsLabelFactory = function(baseComponent) {
	  return {
	    /** @constructor */
	    init: function init(player, options) {
	      options.el = element;
	      baseComponent.call(this, player, options);

	      // We asynchronously reposition the ads label element
	      setTimeout(function () {
	        var currentTimeComp = player.controlBar &&( player.controlBar.getChild("timerControls") || player.controlBar.getChild("currentTimeDisplay") );
	        if(currentTimeComp) {
	          player.controlBar.el().insertBefore(element, currentTimeComp.el());
	        }
	        dom.removeClass(element, 'vjs-label-hidden');
	      }, 0);
	    },

	    el: function getElement() {
	      return element;
	    }
	  };
	};

	module.exports = AdsLabelFactory;
	},{"../../utils/dom":40}],33:[function(require,module,exports){
	'use strict';

	var baseVideoJsComponent = videojs.getComponent('Component');

	var AdsLabel = require('./ads-label')(baseVideoJsComponent);

	videojs.registerComponent('AdsLabel', videojs.extend(baseVideoJsComponent, AdsLabel));

	},{"./ads-label":32}],34:[function(require,module,exports){
	'use strict';

	/**
	 * The component that shows a black screen until the ads plugin has decided if it can or it can not play the ad.
	 *
	 * Note: In case you wonder why instead of this black poster we don't just show the spinner loader.
	 *       IOS devices do not work well with animations and the browser chrashes from time to time That is why we chose to
	 *       have a secondary black poster.
	 *
	 *       It also makes it much more easier for the users of the plugin since it does not change the default behaviour of the
	 *       spinner and the player works the same way with and without the plugin.
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	var element = document.createElement('div');

	var BlackPosterFactory = function(baseComponent) {
	  return {
	    /** @constructor */
	    init: function init(player, options) {
	      options.el = element;
	      element.className = 'vjs-black-poster';
	      baseComponent.call(this, player, options);

	      var posterImg = player.getChild('posterImage');

	      //We need to do it asynchronously to be sure that the black poster el is on the dom.
	      setTimeout(function() {
	        if(posterImg && player && player.el()) {
	          player.el().insertBefore(element, posterImg.el());
	        }
	      }, 0);
	    },
	    el: function getElement() {
	      return element;
	    }
	  };
	};

	module.exports = BlackPosterFactory;
	},{}],35:[function(require,module,exports){
	'use strict';

	var baseVideoJsComponent = videojs.getComponent('Component');

	var BlackPoster = require('./black-poster')(baseVideoJsComponent);

	videojs.registerComponent('BlackPoster', videojs.extend(baseVideoJsComponent, BlackPoster));

	},{"./black-poster":34}],36:[function(require,module,exports){
	'use strict';

	var VASTClient = require('../ads/vast/VASTClient');
	var VASTError = require('../ads/vast/VASTError');
	var vastUtil = require('../ads/vast/vastUtil');

	var VASTIntegrator = require('../ads/vast/VASTIntegrator');
	var VPAIDIntegrator = require('../ads/vpaid/VPAIDIntegrator');
	var IconIntegrator = require('../ads/icon/IconIntegrator');

	var async = require('../utils/async');
	var dom = require('../utils/dom');
	var playerUtils = require('../utils/playerUtils');
	var utilities = require('../utils/utilityFunctions');
	var ViewabilityTracking = require("../utils/anVideoViewability");

	var logger = require ('../utils/consoleLogger');

	module.exports = function VASTPlugin(options) {
	  var snapshot;
	  var player = this;
	  var vast = new VASTClient({wrapperLimit: options.wrapperLimit});
	  var adsCanceled = false;
	  var playlistNextButton;
	  var defaultOpts = {
	    // maximum amount of time in ms to wait to receive `adsready` from the ad
	    // implementation after play has been requested. Ad implementations are
	    // expected to load any dynamic libraries and make any requests to determine
	    // ad policies for a video during this time.
	    timeout: 500,

	    //TODO:finish this IOS FIX
	    //Whenever you play an add on IOS, the native player kicks in and we loose control of it. On very heavy pages the 'play' event
	    // May occur after the video content has already started. This is wrong if you want to play a preroll ad that needs to happen before the user
	    // starts watching the content. To prevent this usec
	    iosPrerollCancelTimeout: 2000,

	    // maximun amount of time for the ad to actually start playing. If this timeout gets
	    // triggered the ads will be cancelled
	    adCancelTimeout: 3000,

	    // Boolean flag that configures the player to play a new ad before the user sees the video again
	    // the current video
	    playAdAlways: false,

	    // Flag to enable or disable the ads by default.
	    adsEnabled: true,

	    // Boolean flag to enable or disable the resize with window.resize or orientationchange
	    autoResize: true,

	    // verbosity of console logging:
	    // 0 - error
	    // 1 - error, warn
	    // 2 - error, warn, info
	    // 3 - error, warn, info, log
	    // 4 - error, warn, info, log, debug
	    verbosity: 0,
	    
	    // plugin options
	    playsInBreak: false,
	    skipText: 'Skip in %%TIME%% seconds',
	    skipButtonText: 'Skip ad',
	    initialPlayback: "auto",
	    initialAudio: "on",
	    disableClickThru: false,
	    
	    firstPlay: true
	  };

	  var settings = utilities.extend({}, defaultOpts, options || {});
	  
	  if(utilities.isUndefined(settings.adTagUrl) && utilities.isDefined(settings.url)){
	    settings.adTagUrl = settings.url;
	  }

	  if (utilities.isString(settings.adTagUrl)) {
	    settings.adTagUrl = utilities.echoFn(settings.adTagUrl);
	  }
	  
	  if (settings.viewability && settings.viewability.config) {
		  settings.viewabilityTracking = new ViewabilityTracking(player);
	  }
	  
	  window._molSettings = settings;
	  window._timeoutIds = [];
	  
	  window.MoatApiReference = null;

	  if (utilities.isDefined(settings.adTagXML) && !utilities.isFunction(settings.adTagXML)) {
	    return trackAdError(new VASTError('on VideoJS VAST plugin, the passed adTagXML option does not contain a function'));
	  }

	  if (!utilities.isDefined(settings.adTagUrl) && !utilities.isFunction(settings.adTagXML)) {
	    return trackAdError(new VASTError('on VideoJS VAST plugin, missing adTagUrl on options object'));
	  }

	  logger.setVerbosity (settings.verbosity);

	  if (!settings.playsInBreak) {
		  snapshot = playerUtils.getPlayerSnapshot(player);
		  snapshot.playing = true;	// force to play content after ad ended
	  }
	  
	  if (settings.initialPlayback === 'click') {
		  playerUtils.showBigPlayButton(player, true);
	  }

	  playerUtils.prepareForAds(player);

	  if (settings.playAdAlways) {
	    // No matter what happens we play a new ad before the user sees the video again.
	    player.on('vast.contentEnd', function () {
	      setTimeout(function () {
	        player.trigger('vast.reset');
	      }, 0);
	    });
	  }

	  player.on('vast.firstPlay', tryToPlayPrerollAd);

	  player.on('vast.reset', function () {
	    //If we are reseting the plugin, we don't want to restore the content
	    snapshot = null;
	    cancelAds();
	  });

	  player.vast = {
	    isEnabled: function () {
	      return settings.adsEnabled;
	    },

	    enable: function () {
	      settings.adsEnabled = true;
	    },

	    disable: function () {
	      settings.adsEnabled = false;
	    }
	  };

	  return player.vast;

	  /**** Local functions ****/
	  function tryToPlayPrerollAd() {
		// make sure we are going to use same plugin instance twice
		player.off('vast.firstPlay', tryToPlayPrerollAd);
		
		playerUtils.showBigPlayButton(player, false);

		if (settings.initialAudio === 'off') {
			settings.contentVolume = {muted: player.muted(), volume: player.volume()};
			player.muted(true);
		}

	    //We remove the poster to prevent flickering whenever the content starts playing
	    playerUtils.removeNativePoster(player);

	    playerUtils.once(player, ['vast.adsCancel', 'vast.adEnd'], function () {
	    	playerUtils.showBigPlayButton(player, false);
	      removeAdUnit();
	      restoreVideoContent();
	      setTimeout(function () {
	          player.trigger('adFinished');
	      }, 0);
	    });

	    async.waterfall([
	      checkAdsEnabled,
	      preparePlayerForAd,
	      startAdCancelTimeout,
	      playPrerollAd
	    ], function (error, response) {
	      if (error) {
	        trackAdError(error, response);
	      } else {
	        player.trigger('vast.adEnd');
	      }
	    });

	    /*** Local functions ***/

	    function removeAdUnit() {
	      if (player.vast && player.vast.adUnit) {
	        player.vast.adUnit = null; //We remove the adUnit
	        player.vast.VPAID = null;
	      }
	      window._molSettings.firstPlay = false;
	    }

	    function restoreVideoContent() {
	      setupContentEvents();
	      if (snapshot) {
	        playerUtils.restorePlayerSnapshot(player, snapshot);
	        snapshot = null;
	      }
	    }

	    function setupContentEvents() {
	      playerUtils.once(player, ['playing', 'vast.reset', 'vast.firstPlay'], function (evt) {
	        if (evt.type !== 'playing') {
	          return;
	        }

	        player.trigger('vast.contentStart');

	        playerUtils.once(player, ['ended', 'vast.reset', 'vast.firstPlay'], function (evt) {
	          if (evt.type === 'ended') {
	            player.trigger('vast.contentEnd');
	          }
	        });
	      });
	    }

	    function checkAdsEnabled(next) {
	      if (settings.adsEnabled) {
	        return next(null);
	      }
	      next(new VASTError('Ads are not enabled'));
	    }

	    function preparePlayerForAd(next) {
	      if (canPlayPrerollAd()) {
	        //snapshot = playerUtils.getPlayerSnapshot(player);
	        player.pause();
	        addSpinnerIcon();

	        if(player.paused()) {
	          next(null);
	        } else {
	          playerUtils.once(player, ['playing'], function() {
	            player.pause();
	            next(null);
	          });
	        }
	      } else {
	        next(new VASTError('video content has been playing before preroll ad'));
	      }
	    }

	    function canPlayPrerollAd() {
	      return !utilities.isIPhone() || player.currentTime() <= settings.iosPrerollCancelTimeout;
	    }

	    function startAdCancelTimeout(next) {
	      var adCancelTimeoutId;
	      adsCanceled = false;

	      adCancelTimeoutId = setTimeout(function () {
	       	  adCancelTimeoutId = null;
	        trackAdError(new VASTError('timeout while waiting for the video to start playing', 402));
	        playerUtils.showBigPlayButton(player, false);
	        if (player.vast.VPAID) {
	        	player.trigger('vpaid.adEnd');
	        }
	      }, settings.adCancelTimeout);

	      playerUtils.once(player, ['vast.adStart', 'vast.adsCancel', 'clearAdCancelTimeout'], clearAdCancelTimeout);
	      playerUtils.once(player, ['vast.adError', 'vpaid.adEnd', 'vpaid.adError'], function() {
	    	  clearAdCancelTimeout();
	      });

	      /*** local functions ***/
	      function clearAdCancelTimeout() {
	        if (adCancelTimeoutId) {
	          clearTimeout(adCancelTimeoutId);
	          adCancelTimeoutId = null;
	        }
	      }

	      next(null);
	    }

	    function addSpinnerIcon() {
	      dom.addClass(player.el(), 'vjs-vast-ad-loading');
	      playerUtils.once(player, ['vast.adStart', 'vast.adsCancel'], removeSpinnerIcon);
	    }

	    function removeSpinnerIcon() {
	      //IMPORTANT NOTE: We remove the spinnerIcon asynchronously to give time to the browser to start the video.
	      // If we remove it synchronously we see a flash of the content video before the ad starts playing.
	      setTimeout(function () {
	        dom.removeClass(player.el(), 'vjs-vast-ad-loading');
	        // VIDLA-2268 (Safari 11 on Mac - Spinner keeps going on first frame of ad)
			player.loadingSpinner.el_.style.display = 'none';
	      }, 100);
	    }

	  }

	  function cancelAds() {
	    player.trigger('vast.adsCancel');
	    adsCanceled = true;
	  }

	  function playPrerollAd(callback) {
	    async.waterfall([
	      getVastResponse,
	      playAd
	    ], callback);
	  }

	  function getVastResponse(callback) {
	    vast.getVASTResponse(settings.adTagUrl ? settings.adTagUrl() : settings.adTagXML, callback);
	  }

	  function playAd(vastResponse, callback) {
	    //TODO: Find a better way to stop the play. The 'playPrerollWaterfall' ends in an inconsistent situation
	    //If the state is not 'preroll?' it means the ads were canceled therefore, we break the waterfall
	    if (adsCanceled) {
	      return;
	    }

	    /*Copyright (c) 2011-2016 Moat Inc. All Rights Reserved.*/
	    function initMoatTracking(a,c,d,h,k){var f=document.createElement("script"),b=[];c={adData:{ids:c,duration:d,url:k},dispatchEvent:function(a){this.sendEvent?(b&&(b.push(a),a=b,b=!1),this.sendEvent(a)):b.push(a)}};d="_moatApi"+Math.floor(1E8*Math.random());var e,g;try{e=a.ownerDocument,g=e.defaultView||e.parentWindow}catch(l){e=document,g=window}g[d]=c;f.type="text/javascript";a&&a.insertBefore(f,a.childNodes[0]||null);f.src="https://z.moatads.com/"+h+"/moatvideo.js#"+d;return c};
	    window.MoatApiReference = null;
	    if (vastResponse.ads && vastResponse.ads.length > 0 && vastResponse.ads[0].inLine && vastResponse.ads[0].inLine.moat) {
	  	  var ids = {level1: vastResponse.ads[0].inLine.moat.advid,
	  			     level2: vastResponse.ads[0].inLine.moat.cpgid,
	  			     level3: vastResponse.ads[0].inLine.moat.cpid,
	  			     level4: vastResponse.ads[0].inLine.moat.crid};
	  	  if (vastResponse.ads[0].inLine.moat.site_id) {
	  		  ids.slicer1 = vastResponse.ads[0].inLine.moat.site_id;
	  	  }
	  	  //window.MoatApiReference = initMoatTracking(player.el_, ids, player.duration(), vastResponse.ads[0].inLine.moat.partnercode, player.currentSource().src);
	  	  window.MoatApiReference = initMoatTracking(player.el_, ids, player.duration(), 'ninemediavpaid78961164', player.currentSource().src);
	    }
	    if (window._molSettings.viewabilityTracking) {
	  	  window._molSettings.viewabilityTracking.init(window._molSettings.viewability.contextId, 
	  			  player.duration(), player.el_.offsetWidth, player.el_.offsetHeight);
	    }

	    var isAdVPAID  = isVPAID(vastResponse);
	    var adIntegrator = isAdVPAID ? new VPAIDIntegrator(player, settings) : new VASTIntegrator(player);
	    var adFinished = false;
	    if (isAdVPAID) {
	    	player.trigger('clearAdCancelTimeout');
	    }

	    playerUtils.once(player, ['vast.adStart', 'vast.adsCancel'], function (evt) {
	      if (evt.type === 'vast.adStart') {
	        addAdsLabel();
	      }
	    });

	    playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], removeAdsLabel);

	    if (utilities.isIDevice()) {
	      preventManualProgress();
	    }

	    player.vast.vastResponse = vastResponse;
	    logger.debug ("calling adIntegrator.playAd() with vastResponse:", vastResponse);
	    player.vast.adUnit = adIntegrator.playAd(vastResponse, callback);
	    player.vast.VPAID = isAdVPAID;

	    var adIconIntegrator;

	    /*** Local functions ****/
	    function addAdsLabel() {
	    	if (window._molSettings.playsInBreak) {
	    		player.on('timeupdate', updateTimeControls);
	    	}
	      if (adFinished || player.controlBar.getChild('AdsLabel')) {
	        return;
	      }

	      player.controlBar.addChild('AdsLabel');
	      if (vastResponse.icons && vastResponse.icons.length > 0) {
	        adIconIntegrator = new IconIntegrator(player);
	        adIconIntegrator.renderIcons(vastResponse.icons, callback);
	      }

	      var elems = document.getElementsByClassName('vjs-next-button');
	      if (elems && elems.length > 0) {
	        playlistNextButton = elems[0];
	        playlistNextButton.style.display = 'none';
	      }
	    }

	    function removeAdsLabel() {
	    	if (window._molSettings.playsInBreak) {
	    		player.off('timeupdate', updateTimeControls);
	    		if (window._molSettings.timeOffset) {
	        showOriginalTimeDisplay(true);
					var bcTimeDisplay = document.getElementById('bc_time_display');
					if (bcTimeDisplay) {
						bcTimeDisplay.style.display = 'none';
					}
	    		}
	    	}
	      player.controlBar.removeChild('AdsLabel');
	      if (playlistNextButton) {
	        playlistNextButton.style.display = '';
	        playlistNextButton = null;
	      }
	      adFinished = true;
	    }

	    function showOriginalTimeDisplay(show) {
	      var children = player.controlBar.getChild('currentTimeDisplay').el_.children;
	      for (var i = 0; i < children.length; i++) {
	        if (children[i].id != 'bc_time_display') {
	          children[i].style.display = show ? '' : 'none';
	        }
	      }
	    }

	    function updateTimeControls() {
	    	var convertTimeToStr = function(time) {
	    		var secs = parseInt(time + 0.5);
	    		var mins = parseInt(secs / 60);
	    		secs -= (mins * 60);
	    		var str = mins.toString() + ':' + (secs > 9 ? ''  : '0') + secs.toString();
	    		return str;
	    	};
	    	
	      if (window._molSettings.breakDuration) {
	        if (player.duration() != window._molSettings.breakDuration) {
	          if (player.duration()) {
	            window._molSettings.realVideoDuration = player.duration();
	          }
	          player.duration(window._molSettings.breakDuration);
	        }
	      }
	      if (window._molSettings.timeOffset) {
	        var bcTimeDisplay = document.getElementById('bc_time_display');
	        if (!bcTimeDisplay) {
	          bcTimeDisplay = document.createElement('div');
	          player.controlBar.getChild('currentTimeDisplay').el_.appendChild(bcTimeDisplay);
	          bcTimeDisplay.id = 'bc_time_display';
	          bcTimeDisplay.class = 'vjs-current-time-display';
	          bcTimeDisplay['aria-live'] = 'off';
	          bcTimeDisplay.innerHTML = '<span class="vjs-control-text"></span>0:00';
	          showOriginalTimeDisplay(false);
	        }
	        else {
	          showOriginalTimeDisplay(false);
	          bcTimeDisplay.style.display = 'block';
	        }
	        var time = player.currentTime() + window._molSettings.timeOffset;
	        bcTimeDisplay.childNodes[1].nodeValue = convertTimeToStr(time);
	      }
	    }

	    function preventManualProgress() {
	      //IOS video clock is very unreliable and we need a 3 seconds threshold to ensure that the user forwarded/rewound the ad
	      var PROGRESS_THRESHOLD = 3;
	      var previousTime = 0;
	      var skipad_attempts = 0;

	      player.on('timeupdate', preventAdSeek);
	      player.on('ended', preventAdSkip);

	      playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel', 'vast.adError'], stopPreventManualProgress);

	      /*** Local functions ***/
	      function preventAdSkip() {
	        // Ignore ended event if the Ad time was not 'near' the end
	        // and revert time to the previous 'valid' time
	        if ((player.duration() - previousTime) > PROGRESS_THRESHOLD) {
	          player.pause(true); // this reduce the video jitter if the IOS skip button is pressed
	          player.play(true); // we need to trigger the play to put the video element back in a valid state
	          player.currentTime(previousTime);
	        }
	      }

	      function preventAdSeek() {
	        var currentTime = player.currentTime();
	        var progressDelta = Math.abs(currentTime - previousTime);
	        if (progressDelta > PROGRESS_THRESHOLD) {
	          skipad_attempts += 1;
	          if (skipad_attempts >= 2) {
	            player.pause(true);
	          }
	          player.currentTime(previousTime);
	        } else {
	          previousTime = currentTime;
	        }
	      }

	      function stopPreventManualProgress() {
	        player.off('timeupdate', preventAdSeek);
	        player.off('ended', preventAdSkip);
	      }
	    }
	  }

	  function trackAdError(error, vastResponse) {
	    player.trigger({type: 'vast.adError', error: error});
	    cancelAds();
	    logger.error ('AD ERROR:', error.message, error, vastResponse);
	  }

	  function isVPAID(vastResponse) {
	    var i, len;
	    var mediaFiles = vastResponse.mediaFiles;
	    for (i = 0, len = mediaFiles.length; i < len; i++) {
	      if (vastUtil.isVPAID(mediaFiles[i])) {
	        return true;
	      }
	    }
	    return false;
	  }
	};

	},{"../ads/icon/IconIntegrator":6,"../ads/vast/VASTClient":18,"../ads/vast/VASTError":19,"../ads/vast/VASTIntegrator":20,"../ads/vast/vastUtil":28,"../ads/vpaid/VPAIDIntegrator":31,"../utils/anVideoViewability":37,"../utils/async":38,"../utils/consoleLogger":39,"../utils/dom":40,"../utils/playerUtils":43,"../utils/utilityFunctions":45}],37:[function(require,module,exports){
	/**
	 * Viewability Wrapper
	 */

	//var ANVideoViewabilityTracker = require("an-video-viewability");//viewability library
	var ANVideoViewabilityTracker = null;
	var logger = require("./consoleLogger");
	var debug = function (message) {
	    logger.debug(message);
	};
	var info = function (message) {
	    logger.info(message);
	};

	var html5VideoViewability = function (player_) {

		var player = player_;
	    var tracker = null;
	    var mappedActions = {
	        "start": "start",
	        "expand": "expand",
	        "collapse": "collapse",
	        "unmute": "sound_on",
	        "mute": "sound_off",
	        "pause": "pause",
	        "resume": "resume",
	        "ad-click": "click",
	        "skip": "stop",
	        "complete": "stop",
	        "fullscreen": "fullscreen",
	        "exitFullscreen": "exitFullscreen"
	    };

	    var fireOnceEvents = {
	        "start": false,
	        "skip": false,
	        "complete": false
	    };

	    var getConfig = function () {
	        return window._molSettings.viewability && window._molSettings.viewability.config;
	    };

	    var getPlayerDOMElement = function () {
	        return player.el_;
	    };

	    var getVideoInfo = function (duration, width, height) {
	        return {duration: duration, w: width, h: height};
	    };

		// Using callback for logs helps getting a right logger in each app
		var loggerCallback = function (_level, _message) {
			if (_level && _level === "debug") {
				debug(_message);
			} else {
				info(_message);
			}
	    };

	    this.init = function (contextId, duration, width, height) {
	        if (!ANVideoViewabilityTracker) {
	            return;
	        }   
	        info("initialize with duration: " + duration + ", width: " + width + ", height: " + height);
	        try {
	            tracker = new ANVideoViewabilityTracker(
					getConfig(),
	                getPlayerDOMElement(),
	                getVideoInfo(duration, width, height), // The duration of the video ad
	                contextId,
					loggerCallback
	            );
	            this.isReady = true;
	        } catch (ex) {
	            debug("error on viewability library: ");
	            debug(ex);
	        }

	    };

	    this.invokeEvent = function (event_) {
	        if (!ANVideoViewabilityTracker) {
	            return;
	        }
	        if (this.isReady && event_ && mappedActions[event_]) {
	            try {
	                if(fireOnceEvents.hasOwnProperty(event_)){
	                    if(fireOnceEvents[event_]){
	                        info("supressing fireOnceEvents event as it is already fired once by viewability library: " + mappedActions[event_]);
	                        return;
	                    } else{
	                        fireOnceEvents[event_] = true; // mark that the event has been fired.
	                    }
	                }
	                info("event invoked by viewability library: " + mappedActions[event_]);
	                tracker.notifyEvent(mappedActions[event_]);
	            } catch (ex) {
	                debug("error on viewability library: ");
	                debug(ex);
	            }
	        }
	    };

	    this.isReady = false;


	};


	module.exports = html5VideoViewability;
	},{"./consoleLogger":39}],38:[function(require,module,exports){
	//Small subset of async

	var utilities = require('./utilityFunctions');

	var async = {};

	async.setImmediate = function (fn) {
	  setTimeout(fn, 0);
	};

	async.iterator = function (tasks) {
	  var makeCallback = function (index) {
	    var fn = function () {
	      if (tasks.length) {
	        tasks[index].apply(null, arguments);
	      }
	      return fn.next();
	    };
	    fn.next = function () {
	      return (index < tasks.length - 1) ? makeCallback(index + 1) : null;
	    };
	    return fn;
	  };
	  return makeCallback(0);
	};


	async.waterfall = function (tasks, callback) {
	  callback = callback || function () { };
	  if (!utilities.isArray(tasks)) {
	    var err = new Error('First argument to waterfall must be an array of functions');
	    return callback(err);
	  }
	  if (!tasks.length) {
	    return callback();
	  }
	  var wrapIterator = function (iterator) {
	    return function (err) {
	      if (err) {
	        callback.apply(null, arguments);
	        callback = function () {
	        };
	      }
	      else {
	        var args = Array.prototype.slice.call(arguments, 1);
	        var next = iterator.next();
	        if (next) {
	          args.push(wrapIterator(next));
	        }
	        else {
	          args.push(callback);
	        }
	        async.setImmediate(function () {
	          iterator.apply(null, args);
	        });
	      }
	    };
	  };
	  wrapIterator(async.iterator(tasks))();
	};

	async.when = function (condition, callback) {
	  if (!utilities.isFunction(callback)) {
	    throw new Error("async.when error: missing callback argument");
	  }

	  var isAllowed = utilities.isFunction(condition) ? condition : function () {
	    return !!condition;
	  };

	  return function () {
	    var args = utilities.arrayLikeObjToArray(arguments);
	    var next = args.pop();

	    if (isAllowed.apply(null, args)) {
	      return callback.apply(this, arguments);
	    }

	    args.unshift(null);
	    return next.apply(null, args);
	  };
	};

	module.exports = async;


	},{"./utilityFunctions":45}],39:[function(require,module,exports){
	/*jshint unused:false */
	"use strict";

	var _verbosity = 0;
	var _prefix = "[videojs-vast-vpaid] ";

	function setVerbosity (v)
	{
	    _verbosity = v;
	}

	function handleMsg (method, args)
	{
	    if ((args.length) > 0 && (typeof args[0] === 'string'))
	    {
	        args[0] = _prefix + args[0];
	    }

	    if (method.apply)
	    {
	        method.apply (console, Array.prototype.slice.call(args));
	    }
	    else
	    {
	        method (Array.prototype.slice.call(args));
	    }
	}

	function debug ()
	{
	    if (_verbosity < 4)
	    {
	        return;
	    }

	    if (typeof console.debug === 'undefined')
	    {
	        // IE 10 doesn't have a console.debug() function
	        handleMsg (console.log, arguments);
	    }
	    else
	    {
	        handleMsg (console.debug, arguments);
	    }
	}

	function log ()
	{
	    if (_verbosity < 3)
	    {
	        return;
	    }

	    handleMsg (console.log, arguments);
	}

	function info ()
	{
	    if (_verbosity < 2)
	    {
	        return;
	    }

	    handleMsg (console.info, arguments);
	}


	function warn ()
	{
	    if (_verbosity < 1)
	    {
	        return;
	    }

	    handleMsg (console.warn, arguments);
	}

	function error ()
	{
	    handleMsg (console.error, arguments);
	}

	var consoleLogger = {
	    setVerbosity: setVerbosity,
	    debug: debug,
	    log: log,
	    info: info,
	    warn: warn,
	    error: error
	};

	if ((typeof (console) === 'undefined') || !console.log)
	{
	    // no console available; make functions no-op
	    consoleLogger.debug = function () {};
	    consoleLogger.log = function () {};
	    consoleLogger.info = function () {};
	    consoleLogger.warn = function () {};
	    consoleLogger.error = function () {};
	}

	module.exports = consoleLogger;
	},{}],40:[function(require,module,exports){
	'use strict';

	var utilities = require('./utilityFunctions');

	var dom = {};

	dom.isVisible = function isVisible(el) {
	  var style = window.getComputedStyle(el);
	  return style.visibility !== 'hidden';
	};

	dom.isHidden = function isHidden(el) {
	  var style = window.getComputedStyle(el);
	  return style.display === 'none';
	};

	dom.isShown = function isShown(el) {
	  return !dom.isHidden(el);
	};

	dom.hide = function hide(el) {
	  el.__prev_style_display_ = el.style.display;
	  el.style.display = 'none';
	};

	dom.show = function show(el) {
	  if (dom.isHidden(el)) {
	    el.style.display = el.__prev_style_display_;
	  }
	  el.__prev_style_display_ = undefined;
	};

	dom.hasClass = function hasClass(el, cssClass) {
	  var classes, i, len;

	  if (utilities.isNotEmptyString(cssClass)) {
	    if (el.classList) {
	      return el.classList.contains(cssClass);
	    }

	    classes = utilities.isString(el.getAttribute('class')) ? el.getAttribute('class').split(/\s+/) : [];
	    cssClass = (cssClass || '');

	    for (i = 0, len = classes.length; i < len; i += 1) {
	      if (classes[i] === cssClass) {
	        return true;
	      }
	    }
	  }
	  return false;
	};

	dom.addClass = function (el, cssClass) {
	  var classes;

	  if (utilities.isNotEmptyString(cssClass)) {
	    if (el.classList) {
	      return el.classList.add(cssClass);
	    }

	    classes = utilities.isString(el.getAttribute('class')) ? el.getAttribute('class').split(/\s+/) : [];
	    if (utilities.isString(cssClass) && utilities.isNotEmptyString(cssClass.replace(/\s+/, ''))) {
	      classes.push(cssClass);
	      el.setAttribute('class', classes.join(' '));
	    }
	  }
	};

	dom.removeClass = function (el, cssClass) {
	  var classes;

	  if (utilities.isNotEmptyString(cssClass)) {
	    if (el.classList) {
	      return el.classList.remove(cssClass);
	    }

	    classes = utilities.isString(el.getAttribute('class')) ? el.getAttribute('class').split(/\s+/) : [];
	    var newClasses = [];
	    var i, len;
	    if (utilities.isString(cssClass) && utilities.isNotEmptyString(cssClass.replace(/\s+/, ''))) {

	      for (i = 0, len = classes.length; i < len; i += 1) {
	        if (cssClass !== classes[i]) {
	          newClasses.push(classes[i]);
	        }
	      }
	      el.setAttribute('class', newClasses.join(' '));
	    }
	  }
	};

	dom.addEventListener = function addEventListener(el, type, handler) {
	  if(utilities.isArray(el)){
	    utilities.forEach(el, function(e) {
	      dom.addEventListener(e, type, handler);
	    });
	    return;
	  }

	  if(utilities.isArray(type)){
	    utilities.forEach(type, function(t) {
	      dom.addEventListener(el, t, handler);
	    });
	    return;
	  }

	  if (el.addEventListener) {
	    el.addEventListener(type, handler, false);
	  } else if (el.attachEvent) {
	    // WARNING!!! this is a very naive implementation !
	    // the event object that should be passed to the handler
	    // would not be there for IE8
	    // we should use "window.event" and then "event.srcElement"
	    // instead of "event.target"
	    el.attachEvent("on" + type, handler);
	  }
	};

	dom.removeEventListener = function removeEventListener(el, type, handler) {
	  if(utilities.isArray(el)){
	    utilities.forEach(el, function(e) {
	      dom.removeEventListener(e, type, handler);
	    });
	    return;
	  }

	  if(utilities.isArray(type)){
	    utilities.forEach(type, function(t) {
	      dom.removeEventListener(el, t, handler);
	    });
	    return;
	  }

	  if (el.removeEventListener) {
	    el.removeEventListener(type, handler, false);
	  } else if (el.detachEvent) {
	    el.detachEvent("on" + type, handler);
	  } else {
	    el["on" + type] = null;
	  }
	};

	dom.dispatchEvent = function dispatchEvent(el, event) {
	  if (el.dispatchEvent) {
	    el.dispatchEvent(event);
	  } else {
	    el.fireEvent("on" + event.eventType, event);
	  }
	};

	dom.isDescendant = function isDescendant(parent, child) {
	  var node = child.parentNode;
	  while (node !== null) {
	    if (node === parent) {
	      return true;
	    }
	    node = node.parentNode;
	  }
	  return false;
	};

	dom.getTextContent = function getTextContent(el){
	  return el.textContent || el.text;
	};

	dom.prependChild = function prependChild(parent, child) {
	  if(child.parentNode){
	    child.parentNode.removeChild(child);
	  }
	  return parent.insertBefore(child, parent.firstChild);
	};

	dom.remove = function removeNode(node){
	  if(node && node.parentNode){
	    node.parentNode.removeChild(node);
	  }
	};

	dom.isDomElement = function isDomElement(o) {
	  return o instanceof Element;
	};

	dom.click = function(el, handler) {
	  dom.addEventListener(el, 'click', handler);
	};

	dom.once = function(el, type, handler) {
	  function handlerWrap() {
	    handler.apply(null, arguments);
	    dom.removeEventListener(el, type, handlerWrap);
	  }

	  dom.addEventListener(el, type, handlerWrap);
	};

	//Note: there is no getBoundingClientRect on iPad so we need a fallback
	dom.getDimension = function getDimension(element) {
	  var rect;

	  //On IE9 and below getBoundingClientRect does not work consistently
	  if(!utilities.isOldIE() && element.getBoundingClientRect) {
	    rect = element.getBoundingClientRect();
	    return {
	      width: rect.width,
	      height: rect.height
	    };
	  }

	  return {
	    width: element.offsetWidth,
	    height: element.offsetHeight
	  };
	};

	module.exports = dom;
	},{"./utilityFunctions":45}],41:[function(require,module,exports){
	'use strict';

	var urlUtils = require('./urlUtils');
	var utilities = require('./utilityFunctions');

	function HttpRequestError(message) {
	  this.message = 'HttpRequest Error: ' + (message || '');
	}
	HttpRequestError.prototype = new Error();
	HttpRequestError.prototype.name = "HttpRequest Error";

	function HttpRequest(createXhr) {
	  if (!utilities.isFunction(createXhr)) {
	    throw new HttpRequestError('Missing XMLHttpRequest factory method');
	  }

	  this.createXhr = createXhr;
	}

	HttpRequest.prototype.run = function (method, url, callback, options) {
	  sanityCheck(url, callback, options);
	  var timeout, timeoutId;
	  var xhr = this.createXhr();
	  options = options || {};
	  timeout = utilities.isNumber(options.timeout) ? options.timeout : 0;

	  xhr.open(method, urlUtils.urlParts(url).href, true);

	  if (options.headers) {
	    setHeaders(xhr, options.headers);
	  }

	  if (options.withCredentials) {
	    xhr.withCredentials = true;
	  }

	  xhr.onload = function () {
	    var statusText, response, status;

	    /**
	     * The only way to do a secure request on IE8 and IE9 is with the XDomainRequest object. Unfortunately, microsoft is
	     * so nice that decided that the status property and the 'getAllResponseHeaders' method where not needed so we have to
	     * fake them. If the request gets done with an XDomainRequest instance, we will assume that there are no headers and
	     * the status will always be 200. If you don't like it, DO NOT USE ANCIENT BROWSERS!!!
	     *
	     * For mor info go to: https://msdn.microsoft.com/en-us/library/cc288060(v=vs.85).aspx
	     */
	    if (!xhr.getAllResponseHeaders) {
	      xhr.getAllResponseHeaders = function () {
	        return null;
	      };
	    }

	    if (!xhr.status) {
	      xhr.status = 200;
	    }

	    if (utilities.isDefined(timeoutId)) {
	      clearTimeout(timeoutId);
	      timeoutId = undefined;
	    }

	    statusText = xhr.statusText || '';

	    // responseText is the old-school way of retrieving response (supported by IE8 & 9)
	    // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)
	    response = ('response' in xhr) ? xhr.response : xhr.responseText;

	    // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
	    status = xhr.status === 1223 ? 204 : xhr.status;

	    callback(
	      status,
	      response,
	      xhr.getAllResponseHeaders(),
	      statusText);
	  };

	  xhr.onerror = requestError;
	  xhr.onabort = requestError;

	  xhr.send();

	  if (timeout > 0) {
	    timeoutId = setTimeout(function () {
	      xhr && xhr.abort();
	    }, timeout);
	  }

	  function sanityCheck(url, callback, options) {
	    if (!utilities.isString(url) || utilities.isEmptyString(url)) {
	      throw new HttpRequestError("Invalid url '" + url + "'");
	    }

	    if (!utilities.isFunction(callback)) {
	      throw new HttpRequestError("Invalid handler '" + callback + "' for the http request");
	    }

	    if (utilities.isDefined(options) && !utilities.isObject(options)) {
	      throw new HttpRequestError("Invalid options map '" + options + "'");
	    }
	  }

	  function setHeaders(xhr, headers) {
	    utilities.forEach(headers, function (value, key) {
	      if (utilities.isDefined(value)) {
	        xhr.setRequestHeader(key, value);
	      }
	    });
	  }

	  function requestError() {
	    callback(-1, null, null, '');
	  }
	};

	HttpRequest.prototype.get = function (url, callback, options) {
	  this.run('GET', url, processResponse, options);

	  function processResponse(status, response, headersString, statusText) {
	    if (isSuccess(status)) {
	      callback(null, response, status, headersString, statusText);
	    } else {
	      callback(new HttpRequestError(statusText), response, status, headersString, statusText);
	    }
	  }

	  function isSuccess(status) {
	    return 200 <= status && status < 300;
	  }
	};

	function createXhr() {
	  var xhr = new XMLHttpRequest();
	  if (!("withCredentials" in xhr)) {
	    // XDomainRequest for IE.
	    xhr = new XDomainRequest();
	  }
	  return xhr;
	}

	var http = new HttpRequest(createXhr);

	module.exports = {
	  http: http,
	  HttpRequest: HttpRequest,
	  HttpRequestError: HttpRequestError,
	  createXhr: createXhr
	};

	},{"./urlUtils":44,"./utilityFunctions":45}],42:[function(require,module,exports){
	'use strict';

	module.exports = {
	  html5: [
	    'text/javascript',
	    'text/javascript1.0',
	    'text/javascript1.2',
	    'text/javascript1.4',
	    'text/jscript',
	    'application/javascript',
	    'application/x-javascript',
	    'text/ecmascript',
	    'text/ecmascript1.0',
	    'text/ecmascript1.2',
	    'text/ecmascript1.4',
	    'text/livescript',
	    'application/ecmascript',
	    'application/x-ecmascript',
	  ],

	  flash: [
	    'application/x-shockwave-flash'
	  ],
	};

	},{}],43:[function(require,module,exports){
	'use strict';

	var dom = require('./dom');
	var utilities = require('./utilityFunctions');

	var playerUtils = {};

	/**
	 * Returns an object that captures the portions of player state relevant to
	 * video playback. The result of this function can be passed to
	 * restorePlayerSnapshot with a player to return the player to the state it
	 * was in when this function was invoked.
	 * @param {object} player The videojs player object
	 */
	playerUtils.getPlayerSnapshot = function getPlayerSnapshot(player) {
	  var tech = player.el().querySelector('.vjs-tech');

	  var snapshot = {
	    ended: player.ended(),
	    src: player.currentSrc(),
	    currentTime: player.currentTime(),
	    type: player.currentType(),
	    playing: !player.paused(),
	    suppressedTracks: getSuppressedTracks(player)
	  };

	  if (tech) {
	    snapshot.nativePoster = tech.poster;
	    snapshot.style = tech.getAttribute('style');
	  }

		var els = document.getElementsByClassName('vjs-dock-text');
		if (els && els.length > 0) {
			snapshot.dockText = els[0];
			snapshot.dockText.style.display = 'none';
		}
	  return snapshot;

	  /**** Local Functions ****/
	  function getSuppressedTracks(player) {
	    var tracks = player.remoteTextTracks ? player.remoteTextTracks() : [];

	    if (tracks && utilities.isArray(tracks.tracks_)) {
	      tracks = tracks.tracks_;
	    }

	    if (!utilities.isArray(tracks)) {
	      tracks = [];
	    }

	    var suppressedTracks = [];
	    tracks.forEach(function (track) {
	      suppressedTracks.push({
	        track: track,
	        mode: track.mode
	      });
	      track.mode = 'disabled';
	    });

	    return suppressedTracks;
	  }
	};

	/**
	 * Attempts to modify the specified player so that its state is equivalent to
	 * the state of the snapshot.
	 * @param {object} snapshot - the player state to apply
	 */
	playerUtils.restorePlayerSnapshot = function restorePlayerSnapshot(player, snapshot) {
	  var tech = player.el().querySelector('.vjs-tech');
	  var attempts = 20; // the number of remaining attempts to restore the snapshot

	  if (snapshot.nativePoster) {
	    tech.poster = snapshot.nativePoster;
	  }

	  if ('style' in snapshot) {
	    // overwrite all css style properties to restore state precisely
	    tech.setAttribute('style', snapshot.style || '');
	  }

		if (snapshot.dockText) {
			snapshot.dockText.style.display = 'block';
		}

	  //if (hasSrcChanged(player, snapshot)) {

	    // on ios7, fiddling with textTracks too early will cause safari to crash
	    player.one('contentloadedmetadata', restoreTracks);

	    player.one('canplay', tryToResume);
	    ensureCanplayEvtGetsFired();

	    // if the src changed for ad playback, reset it
	    player.src({src: snapshot.src, type: snapshot.type});

	    // safari requires a call to `load` to pick up a changed source
	    // player.load();	// Safari 11 no more requires 'load'. Firefox doesn't like 'load' call for already loaded content (in case of AdLoaded timeout).

	  /*} else {
	    restoreTracks();

	    if (snapshot.playing) {
	      player.play();
	    }
	  }*/

	  /*** Local Functions ***/

	  /**
	   * Sometimes firefox does not trigger the 'canplay' evt.
	   * This code ensure that it always gets triggered triggered.
	   */
	  function ensureCanplayEvtGetsFired() {
	    var timeoutId = setTimeout(function() {
	      player.trigger('canplay');
	    }, 1000);

	    player.one('canplay', function(){
	      clearTimeout(timeoutId);
	    });
	  }

	  /**
	   * Determine whether the player needs to be restored to its state
	   * before ad playback began. With a custom ad display or burned-in
	   * ads, the content player state hasn't been modified and so no
	   * restoration is required
	   */
	  /*function hasSrcChanged(player, snapshot) {
	    if (player.src()) {
	      return player.src() !== snapshot.src;
	    }
	    // the player was configured through source element children
	    return player.currentSrc() !== snapshot.src;
	  }*/

	  function restoreTracks() {
	    var suppressedTracks = snapshot.suppressedTracks;
	    suppressedTracks.forEach(function (trackSnapshot) {
	      trackSnapshot.track.mode = trackSnapshot.mode;
	    });
	  }

	  /**
	   * Determine if the video element has loaded enough of the snapshot source
	   * to be ready to apply the rest of the state
	   */
	  function tryToResume() {

	    // if some period of the video is seekable, resume playback
	    // otherwise delay a bit and then check again unless we're out of attempts

		  // safari 11 requires call `play` to make seek available
	      player.play();

	    if (!playerUtils.isReadyToResume(player) && attempts--) {
	      setTimeout(tryToResume, 50);
	    } else {
	      try {
	        //console.log('****** MOL try navigate after attempts (' + attempts + ')');
	        if(player.currentTime() !== snapshot.currentTime) {
	          if (snapshot.playing) { // if needed restore playing status after seek completes
	            player.one('seeked', function() {
	              //console.log('****** MOL play main content (' + player.currentTime() + ') by seek');
	              player.play();
	            });
	          }
	          //console.log('****** MOL navigate main content to ' + snapshot.currentTime);
	          player.currentTime(snapshot.currentTime);

	        } else if (snapshot.playing) {
	          //console.log('****** MOL play main content (' + player.currentTime() + ')');
	          // if needed and no seek has been performed, restore playing status immediately
	          player.play();
	        }

	      } catch (e) {
	        videojs.log.warn('Failed to resume the content after an advertisement', e);
	      }
	    }
	  }
	};

	playerUtils.isReadyToResume = function (player) {

	  if (player.readyState() > 1) {
	    // some browsers and media aren't "seekable".
	    // readyState greater than 1 allows for seeking without exceptions
	    //console.log('****** MOL ready to resume player state ' + player.readyState());
	    return true;
	  }
	  if (utilities.isIE11()) {
	    return false;
	  }

	  if (player.seekable() === undefined) {
	    // if the player doesn't expose the seekable time ranges, try to
	    // resume playback immediately
	    //console.log('****** MOL ready to resume player.seekable() === undefined');
	    return true;
	  }

	  if (player.seekable().length > 0) {
	    // if some period of the video is seekable, resume playback
	    //console.log('****** MOL ready to resume player.seekable().length = ' + player.seekable().length);
	    return true;
	  }

	  return false;
	};

	/**
	 * This function prepares the player to display ads.
	 * Adding convenience events like the 'vast.firsPlay' that gets fired when the video is first played
	 * and ads the blackPoster to the player to prevent content from being displayed before the preroll ad.
	 *
	 * @param player
	 */
	playerUtils.prepareForAds = function (player) {
	  var blackPoster = player.addChild('blackPoster');
	  //var _firstPlay = true;
	  var volumeSnapshot;


	  monkeyPatchPlayerApi();

	  player.on('play', tryToTriggerFirstPlay);
	  player.on('vast.reset', resetFirstPlay);//Every time we change the sources we reset the first play.
	  player.on('vast.firstPlay', restoreContentVolume);
	  player.on('error', hideBlackPoster);//If there is an error in the player we remove the blackposter to show the err msg
	  player.on('vast.adStart', hideBlackPoster);
	  player.on('vast.adsCancel', hideBlackPoster);
	  player.on('vast.adError', hideBlackPoster);
	  player.on('vast.adStart', addStyles);
	  player.on('vast.adEnd', removeStyles);
	  player.on('vast.adsCancel', removeStyles);

	  // VIDLA-2465 - hide vjs error dialog when ad running
	  var errorDialog;
	  var dlgs = document.getElementsByClassName('vjs-error-display');
	  if (dlgs && dlgs.length > 0) {
		  errorDialog = dlgs[0];
		  errorDialog.style.setProperty('display', 'none', 'important');
	  }
	  
	  /*** Local Functions ***/

	  /**
	   What this function does is ugly and horrible and I should think twice before calling myself a good developer. With that said,
	   it is the best solution I could find to mute the video until the 'play' event happens (on mobile devices) and the plugin can decide whether
	   to play the ad or not.

	   We also need this monkeypatch to be able to pause and resume an ad using the player's API

	   If you have a better solution please do tell me.
	   */
	  function monkeyPatchPlayerApi() {

	    /**
	     * Monkey patch needed to handle firstPlay and resume of playing ad.
	     *
	     * @param callOrigPlay necessary flag to prevent infinite loop when you are restoring a VAST ad.
	     * @returns {player}
	     */
	    var origPlay = player.play;
	    player.play = function (callOrigPlay) {
	      var that = this;

	      if (isFirstPlay()) {
	        firstPlay();
	      } else {
	        resume(callOrigPlay);
	      }

	      return this;

	      /*** local functions ***/
	      function firstPlay() {
	        if (!utilities.isIPhone()) {
	          if (!volumeSnapshot) {
	              volumeSnapshot = saveVolumeSnapshot();
	          }
	          player.muted(true);
	        }

	        origPlay.apply(that, arguments);
	      }

	      function resume(callOrigPlay) {
	        if (isAdPlaying() && !callOrigPlay) {
	          player.vast.adUnit.resumeAd();
	        } else {
	        	if (!isVpaidPlaying()) {
	                origPlay.apply(that, arguments);
	        	}
	        }
	      }
	    };


	    /**
	     * Needed monkey patch to handle pause of playing ad.
	     *
	     * @param callOrigPlay necessary flag to prevent infinite loop when you are pausing a VAST ad.
	     * @returns {player}
	     */
	    var origPause = player.pause;
	    player.pause = function (callOrigPause) {
	      if (isAdPlaying() && !callOrigPause) {
	        player.vast.adUnit.pauseAd();
	      } else {
	      	if (!isVpaidPlaying()) {
	      		origPause.apply(this, arguments);
	      	}
	      }
	      return this;
	    };


	    /**
	     * Needed monkey patch to handle paused state of the player when ads are playing.
	     *
	     * @param callOrigPlay necessary flag to prevent infinite loop when you are pausing a VAST ad.
	     * @returns {player}
	     */
	    var origPaused = player.paused;
	    player.paused = function (callOrigPaused) {
	      if (isAdPlaying() && !callOrigPaused) {
	        return player.vast.adUnit.isPaused();
	      }
	      return origPaused.apply(this, arguments);
	    };
	  }
	  
	  function isVpaidPlaying() {
		  return player.vast && player.vast.VPAID;
	  }

	  function isAdPlaying() {
	    return player.vast && player.vast.adUnit;
	  }

	  function tryToTriggerFirstPlay() {
	    if (isFirstPlay()) {
	  	  window._molSettings.firstPlay = false;
	      //_firstPlay = false;
	      player.trigger('vast.firstPlay');
	    }
	  }

	  function resetFirstPlay() {
		  window._molSettings.firstPlay = true;
		    //_firstPlay = true;
	    blackPoster.show();
	    restoreContentVolume();
	  }

	  function isFirstPlay() {
		  return window._molSettings.firstPlay;
		    //return _firstPlay;
	  }

	  function saveVolumeSnapshot() {
	    return {
	      muted: player.muted(),
	      volume: player.volume()
	    };
	  }

	  function restoreContentVolume() {
	    if (volumeSnapshot) {
	      //player.currentTime(0);
	      restoreVolumeSnapshot(volumeSnapshot);
	      volumeSnapshot = null;
	    }
	  }

	  function restoreVolumeSnapshot(snapshot) {
	    if (utilities.isObject(snapshot)) {
	      player.volume(snapshot.volume);
	      player.muted(snapshot.muted);
	    }
	  }

	  function hideBlackPoster() {
	    if (!dom.hasClass(blackPoster.el(), 'vjs-hidden')) {
	      blackPoster.hide();
	    }
	  }

	  function addStyles() {
	    dom.addClass(player.el(), 'vjs-ad-playing');
	  }

	  function removeStyles() {
		  player.off('play', tryToTriggerFirstPlay);
		  player.off('vast.reset', resetFirstPlay);//Every time we change the sources we reset the first play.
		  player.off('vast.firstPlay', restoreContentVolume);
		  player.off('error', hideBlackPoster);//If there is an error in the player we remove the blackposter to show the err msg
		  player.off('vast.adStart', hideBlackPoster);
		  player.off('vast.adsCancel', hideBlackPoster);
		  player.off('vast.adError', hideBlackPoster);
		  player.off('vast.adStart', addStyles);
		  player.off('vast.adEnd', removeStyles);
		  player.off('vast.adsCancel', removeStyles);
		  
	      dom.removeClass(player.el(), 'vjs-ad-playing');
		  dom.removeClass(player.controlBar.playToggle.el(), 'vjs-ended');
		  
		  if (errorDialog) {
			  setTimeout(function() {
				  errorDialog.style.removeProperty('display');
			  }, 500);
		  }
	  }
	};

	/**
	 * Remove the poster attribute from the video element tech, if present. When
	 * reusing a video element for multiple videos, the poster image will briefly
	 * reappear while the new source loads. Removing the attribute ahead of time
	 * prevents the poster from showing up between videos.
	 * @param {object} player The videojs player object
	 */
	playerUtils.removeNativePoster = function (player) {
	  var tech = player.el().querySelector('.vjs-tech');
	  if (tech) {
	    tech.removeAttribute('poster');
	  }
	};

	/**
	 * Helper function to listen to many events until one of them gets fired, then we
	 * execute the handler and unsubscribe all the event listeners;
	 *
	 * @param player specific player from where to listen for the events
	 * @param events array of events
	 * @param handler function to execute once one of the events fires
	 */
	playerUtils.once = function once(player, events, handler) {
	  function listener() {
	    handler.apply(null, arguments);

	    events.forEach(function (event) {
	      player.off(event, listener);
	    });
	  }

	  events.forEach(function (event) {
	    player.on(event, listener);
	  });
	};

	//plugin utils
	playerUtils.showBigPlayButton = function(player, show) {
		var button = player.bigPlayButton.el_;
		if (button) {
			if (show) {
				button.style.display = 'block';
				button.style.zIndex = 99999;
			}
			else {
				button.style.display = 'none';
				button.style.zIndex = '';
			}
		}
	};

	module.exports = playerUtils;
	},{"./dom":40,"./utilityFunctions":45}],44:[function(require,module,exports){
	'use strict';

	var utilities = require('./utilityFunctions');

	/**
	 *
	 * IMPORTANT NOTE: This function comes from angularJs and was originally called urlResolve
	 *                 you can take a look at the original code here https://github.com/angular/angular.js/blob/master/src/ng/urlUtils.js
	 *
	 * Implementation Notes for non-IE browsers
	 * ----------------------------------------
	 * Assigning a URL to the href property of an anchor DOM node, even one attached to the DOM,
	 * results both in the normalizing and parsing of the URL.  Normalizing means that a relative
	 * URL will be resolved into an absolute URL in the context of the application document.
	 * Parsing means that the anchor node's host, hostname, protocol, port, pathname and related
	 * properties are all populated to reflect the normalized URL.  This approach has wide
	 * compatibility - Safari 1+, Mozilla 1+, Opera 7+,e etc.  See
	 * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
	 *
	 * Implementation Notes for IE
	 * ---------------------------
	 * IE >= 8 and <= 10 normalizes the URL when assigned to the anchor node similar to the other
	 * browsers.  However, the parsed components will not be set if the URL assigned did not specify
	 * them.  (e.g. if you assign a.href = "foo", then a.protocol, a.host, etc. will be empty.)  We
	 * work around that by performing the parsing in a 2nd step by taking a previously normalized
	 * URL (e.g. by assigning to a.href) and assigning it a.href again.  This correctly populates the
	 * properties such as protocol, hostname, port, etc.
	 *
	 * IE7 does not normalize the URL when assigned to an anchor node.  (Apparently, it does, if one
	 * uses the inner HTML approach to assign the URL as part of an HTML snippet -
	 * http://stackoverflow.com/a/472729)  However, setting img[src] does normalize the URL.
	 * Unfortunately, setting img[src] to something like "javascript:foo" on IE throws an exception.
	 * Since the primary usage for normalizing URLs is to sanitize such URLs, we can't use that
	 * method and IE < 8 is unsupported.
	 *
	 * References:
	 *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement
	 *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
	 *   http://url.spec.whatwg.org/#urlutils
	 *   https://github.com/angular/angular.js/pull/2902
	 *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/
	 *
	 * @kind function
	 * @param {string} url The URL to be parsed.
	 * @description Normalizes and parses a URL.
	 * @returns {object} Returns the normalized URL as a dictionary.
	 *
	 *   | member name   | Description    |
	 *   |---------------|----------------|
	 *   | href          | A normalized version of the provided URL if it was not an absolute URL |
	 *   | protocol      | The protocol including the trailing colon                              |
	 *   | host          | The host and port (if the port is non-default) of the normalizedUrl    |
	 *   | search        | The search params, minus the question mark                             |
	 *   | hash          | The hash string, minus the hash symbol
	 *   | hostname      | The hostname
	 *   | port          | The port, without ":"
	 *   | pathname      | The pathname, beginning with "/"
	 *
	 */

	var urlParsingNode = document.createElement("a");
	/**
	 * documentMode is an IE-only property
	 * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx
	 */
	var msie = document.documentMode;

	function urlParts(url) {
	  var href = url;

	  if (msie) {
	    // Normalize before parse.  Refer Implementation Notes on why this is
	    // done in two steps on IE.
	    urlParsingNode.setAttribute("href", href);
	    href = urlParsingNode.href;
	  }

	  urlParsingNode.setAttribute('href', href);

	  // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	  return {
	    href: urlParsingNode.href,
	    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	    host: urlParsingNode.host,
	    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	    hostname: urlParsingNode.hostname,
	    port: utilities.isNotEmptyString(urlParsingNode.port)? urlParsingNode.port: 80,
	    pathname: (urlParsingNode.pathname.charAt(0) === '/')
	      ? urlParsingNode.pathname
	      : '/' + urlParsingNode.pathname
	  };
	}


	/**
	 * This function accepts a query string (search part of a url) and returns a dictionary with
	 * the different key value pairs
	 * @param {string} qs queryString
	 */
	function queryStringToObj(qs, cond) {
	  var pairs, qsObj;

	  cond = utilities.isFunction(cond)? cond : function() {
	    return true;
	  };

	  qs = qs.trim().replace(/^\?/, '');
	  pairs = qs.split('&');
	  qsObj = {};

	  utilities.forEach(pairs, function (pair) {
	    var keyValue, key, value;
	    if (pair !== '') {
	      keyValue = pair.split('=');
	      key = keyValue[0];
	      value = keyValue[1];
	      if(cond(key, value)){
	        qsObj[key] = value;
	      }
	    }
	  });

	  return qsObj;
	}

	/**
	 * This function accepts an object and serializes it into a query string without the leading '?'
	 * @param obj
	 * @returns {string}
	 */
	function objToQueryString(obj) {
	  var pairs = [];
	  utilities.forEach(obj, function (value, key) {
	    pairs.push(key + '=' + value);
	  });
	  return pairs.join('&');
	}

	module.exports = {
	  urlParts: urlParts,
	  queryStringToObj: queryStringToObj,
	  objToQueryString: objToQueryString
	};

	},{"./utilityFunctions":45}],45:[function(require,module,exports){
	/*jshint unused:false */
	"use strict";

	var NODE_TYPE_ELEMENT = 1;
	var SNAKE_CASE_REGEXP = /[A-Z]/g;
	var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)+$/i;
	/*jslint maxlen: 500 */
	var ISO8086_REGEXP = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;


	function noop(){ }

	function isNull(o) {
	  return o === null;
	}

	function isDefined(o){
	  return o !== undefined;
	}

	function isUndefined(o){
	  return o === undefined;
	}

	function isObject(obj) {
	  return typeof obj === 'object';
	}

	function isFunction(str){
	  return typeof str === 'function';
	}

	function isNumber(num){
	  return typeof num === 'number';
	}

	function isWindow(obj) {
	  return utilities.isObject(obj) && obj.window === obj;
	}

	function isArray(array){
	  return Object.prototype.toString.call( array ) === '[object Array]';
	}

	function isArrayLike(obj) {
	  if (obj === null || utilities.isWindow(obj) || utilities.isFunction(obj) || utilities.isUndefined(obj)) {
	    return false;
	  }

	  var length = obj.length;

	  if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
	    return true;
	  }

	  return utilities.isString(obj) || utilities.isArray(obj) || length === 0 ||
	    typeof length === 'number' && length > 0 && (length - 1) in obj;
	}

	function isString(str) {
	  return typeof str === 'string';
	}

	function isEmptyString(str) {
	  return utilities.isString(str) && str.length === 0;
	}

	function isNotEmptyString(str) {
	  return utilities.isString(str) && str.length !== 0;
	}

	function arrayLikeObjToArray(args) {
	  return Array.prototype.slice.call(args);
	}

	function forEach(obj, iterator, context) {
	  var key, length;
	  if (obj) {
	    if (isFunction(obj)) {
	      for (key in obj) {
	        // Need to check if hasOwnProperty exists,
	        // as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function
	        if (key !== 'prototype' && key !== 'length' && key !== 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
	          iterator.call(context, obj[key], key, obj);
	        }
	      }
	    } else if (isArray(obj)) {
	      var isPrimitive = typeof obj !== 'object';
	      for (key = 0, length = obj.length; key < length; key++) {
	        if (isPrimitive || key in obj) {
	          iterator.call(context, obj[key], key, obj);
	        }
	      }
	    } else if (obj.forEach && obj.forEach !== forEach) {
	      obj.forEach(iterator, context, obj);
	    } else {
	      for (key in obj) {
	        if (obj.hasOwnProperty(key)) {
	          iterator.call(context, obj[key], key, obj);
	        }
	      }
	    }
	  }
	  return obj;
	}

	function snake_case(name, separator) {
	  separator = separator || '_';
	  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
	    return (pos ? separator : '') + letter.toLowerCase();
	  });
	}

	function isValidEmail(email){
	  if(!utilities.isString(email)){
	    return false;
	  }

	  return EMAIL_REGEXP.test(email.trim());
	}

	function extend (obj) {
	  var arg, i, k;
	  for (i = 1; i < arguments.length; i++) {
	    arg = arguments[i];
	    for (k in arg) {
	      if (arg.hasOwnProperty(k)) {
	        if(isObject(obj[k]) && !isNull(obj[k]) && isObject(arg[k])){
	          obj[k] = extend({}, obj[k], arg[k]);
	        }else {
	          obj[k] = arg[k];
	        }
	      }
	    }
	  }
	  return obj;
	}

	function capitalize(s){
	  return s.charAt(0).toUpperCase() + s.slice(1);
	}

	function decapitalize(s) {
	  return s.charAt(0).toLowerCase() + s.slice(1);
	}

	/**
	 * This method works the same way array.prototype.map works but if the transformer returns undefine, then
	 * it won't be added to the transformed Array.
	 */
	function transformArray(array, transformer) {
	  var transformedArray = [];

	  array.forEach(function(item, index){
	    var transformedItem = transformer(item, index);
	    if(utilities.isDefined(transformedItem)) {
	      transformedArray.push(transformedItem);
	    }
	  });

	  return transformedArray;
	}

	function toFixedDigits(num, digits) {
	  var formattedNum = num + '';
	  digits = utilities.isNumber(digits) ? digits : 0;
	  num = utilities.isNumber(num) ? num : parseInt(num, 10);
	  if(utilities.isNumber(num) && !isNaN(num)){
	    formattedNum = num + '';
	    while(formattedNum.length < digits) {
	      formattedNum = '0' + formattedNum;
	    }
	    return formattedNum;
	  }
	  return NaN + '';
	}

	function throttle(callback, delay) {
	  var previousCall = new Date().getTime() - (delay + 1);
	  return function() {
	    var time = new Date().getTime();
	    if ((time - previousCall) >= delay) {
	      previousCall = time;
	      callback.apply(this, arguments);
	    }
	  };
	}

	function debounce (callback, wait) {
	  var timeoutId;

	  return function (){
	    if(timeoutId) {
	      clearTimeout(timeoutId);
	    }
	    timeoutId = setTimeout(function(){
	      callback.apply(this, arguments);
	      timeoutId = undefined;
	    }, wait);
	  };
	}

	// a function designed to blow up the stack in a naive way
	// but it is ok for videoJs children components
	function treeSearch(root, getChildren, found){
	  var children = getChildren(root);
	  for (var i = 0; i < children.length; i++){
	    if (found(children[i])) {
	      return children[i];
	    }
	    else {
	      var el = treeSearch(children[i], getChildren, found);
	      if (el){
	        return el;
	      }
	    }
	  }
	}

	function echoFn(val) {
	  return function () {
	    return val;
	  };
	}

	//Note: Supported formats come from http://www.w3.org/TR/NOTE-datetime
	// and the iso8601 regex comes from http://www.pelagodesign.com/blog/2009/05/20/iso-8601-date-validation-that-doesnt-suck/
	function isISO8601(value) {
	  if(utilities.isNumber(value)){
	    value = value + '';  //we make sure that we are working with strings
	  }

	  if(!utilities.isString(value)){
	    return false;
	  }

	  return ISO8086_REGEXP.test(value.trim());
	}

	/**
	 * Checks if the Browser is IE9 and below
	 * @returns {boolean}
	 */
	function isOldIE() {
	  var version = utilities.getInternetExplorerVersion(navigator);
	  if (version === -1) {
	    return false;
	  }

	  return version < 10;
	}

	/**
	 * Returns the version of Internet Explorer or a -1 (indicating the use of another browser).
	 * Source: https://msdn.microsoft.com/en-us/library/ms537509(v=vs.85).aspx
	 * @returns {number} the version of Internet Explorer or a -1 (indicating the use of another browser).
	 */
	function getInternetExplorerVersion(navigator) {
	  var rv = -1;

	  if (navigator.appName == 'Microsoft Internet Explorer') {
	    var ua = navigator.userAgent;
	    var re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
	    var res = re.exec(ua);
	    if (res !== null) {
	      rv = parseFloat(res[1]);
	    }
	  }

	  return rv;
	}

	function isIE11() {
	  var res = navigator.userAgent.search(/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i);
	  return res >= 0;
	}

	/*** Mobile Utility functions ***/
	function isIDevice() {
	  return /iP(hone|ad)/.test(utilities._UA);
	}

	function isMobile() {
	  return /iP(hone|ad|od)|Android|Windows Phone/.test(utilities._UA);
	}

	function isIPhone() {
	  return /iP(hone|od)/.test(utilities._UA);
	}

	function isAndroid() {
	  return /Android/.test(utilities._UA);
	}

	var utilities = {
	  _UA: navigator.userAgent,
	  noop: noop,
	  isNull: isNull,
	  isDefined: isDefined,
	  isUndefined: isUndefined,
	  isObject: isObject,
	  isFunction: isFunction,
	  isNumber: isNumber,
	  isWindow: isWindow,
	  isArray: isArray,
	  isArrayLike: isArrayLike,
	  isString: isString,
	  isEmptyString: isEmptyString,
	  isNotEmptyString: isNotEmptyString,
	  arrayLikeObjToArray: arrayLikeObjToArray,
	  forEach: forEach,
	  snake_case: snake_case,
	  isValidEmail: isValidEmail,
	  extend: extend,
	  capitalize: capitalize,
	  decapitalize: decapitalize,
	  transformArray: transformArray,
	  toFixedDigits: toFixedDigits,
	  throttle: throttle,
	  debounce: debounce,
	  treeSearch: treeSearch,
	  echoFn: echoFn,
	  isISO8601: isISO8601,
	  isOldIE: isOldIE,
	  getInternetExplorerVersion: getInternetExplorerVersion,
	  isIE11: isIE11,
	  isIDevice: isIDevice,
	  isMobile: isMobile,
	  isIPhone: isIPhone,
	  isAndroid: isAndroid
	};

	module.exports = utilities;

	},{}],46:[function(require,module,exports){
	'use strict';

	var utilities = require('./utilityFunctions');

	var xml = {};

	xml.strToXMLDoc = function strToXMLDoc(stringContainingXMLSource){
	  //IE 8
	  if(typeof window.DOMParser === 'undefined'){
	    var xmlDocument = new ActiveXObject('Microsoft.XMLDOM');
	    xmlDocument.async = false;
	    xmlDocument.loadXML(stringContainingXMLSource);
	    return xmlDocument;
	  }

	  return parseString(stringContainingXMLSource);

	  function parseString(stringContainingXMLSource){
	    var parser = new DOMParser();
	    var parsedDocument;

	    //Note: This try catch is to deal with the fact that on IE parser.parseFromString does throw an error but the rest of the browsers don't.
	    try {
	      parsedDocument = parser.parseFromString(stringContainingXMLSource, "application/xml");

	      if(isParseError(parsedDocument) || utilities.isEmptyString(stringContainingXMLSource)){
	        throw new Error();
	      }
	    }catch(e){
	      throw new Error("xml.strToXMLDOC: Error parsing the string: '" + stringContainingXMLSource + "'");
	    }

	    return parsedDocument;
	  }

	  function isParseError(parsedDocument) {
	    try { // parser and parsererrorNS could be cached on startup for efficiency
	      var parser = new DOMParser(),
	        erroneousParse = parser.parseFromString('INVALID', 'text/xml'),
	        parsererrorNS = erroneousParse.getElementsByTagName("parsererror")[0].namespaceURI;

	      if (parsererrorNS === 'http://www.w3.org/1999/xhtml') {
	        // In PhantomJS the parseerror element doesn't seem to have a special namespace, so we are just guessing here :(
	        return parsedDocument.getElementsByTagName("parsererror").length > 0;
	      }

	      return parsedDocument.getElementsByTagNameNS(parsererrorNS, 'parsererror').length > 0;
	    } catch (e) {
	      //Note on IE parseString throws an error by itself and it will never reach this code. Because it will have failed before
	    }
	  }
	};

	xml.parseText = function parseText (sValue) {
	  if (/^\s*$/.test(sValue)) { return null; }
	  if (/^(?:true|false)$/i.test(sValue)) { return sValue.toLowerCase() === "true"; }
	  if (isFinite(sValue)) { return parseFloat(sValue); }
	  if (utilities.isISO8601(sValue)) { return new Date(sValue); }
	  return sValue.trim();
	};

	xml.JXONTree = function JXONTree (oXMLParent) {
	  var parseText = xml.parseText;

	  //The document object is an especial object that it may miss some functions or attrs depending on the browser.
	  //To prevent this problem with create the JXONTree using the root childNode which is a fully fleshed node on all supported
	  //browsers.
	  if(oXMLParent.documentElement){
	    return new xml.JXONTree(oXMLParent.documentElement);
	  }

	  if (oXMLParent.hasChildNodes()) {
	    var sCollectedTxt = "";
	    for (var oNode, sProp, vContent, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {
	      oNode = oXMLParent.childNodes.item(nItem);
	      /*jshint bitwise: false*/
	      if ((oNode.nodeType - 1 | 1) === 3) { sCollectedTxt += oNode.nodeType === 3 ? oNode.nodeValue.trim() : oNode.nodeValue; }
	      else if (oNode.nodeType === 1 && !oNode.prefix) {
	        sProp = utilities.decapitalize(oNode.nodeName);
	        vContent = new xml.JXONTree(oNode);
	        if (this.hasOwnProperty(sProp)) {
	          if (this[sProp].constructor !== Array) { this[sProp] = [this[sProp]]; }
	          this[sProp].push(vContent);
	        } else { this[sProp] = vContent; }
	      }
	    }
	    if (sCollectedTxt) { this.keyValue = parseText(sCollectedTxt); }
	  }

	  //IE8 Stupid fix
	  var hasAttr = typeof oXMLParent.hasAttributes === 'undefined'? oXMLParent.attributes.length > 0: oXMLParent.hasAttributes();
	  if (hasAttr) {
	    var oAttrib;
	    for (var nAttrib = 0; nAttrib < oXMLParent.attributes.length; nAttrib++) {
	      oAttrib = oXMLParent.attributes.item(nAttrib);
	      this["@" + utilities.decapitalize(oAttrib.name)] = parseText(oAttrib.value.trim());
	    }
	  }
	};

	xml.JXONTree.prototype.attr = function(attr) {
	  return this['@' + utilities.decapitalize(attr)];
	};

	xml.toJXONTree = function toJXONTree(xmlString){
	  var xmlDoc = xml.strToXMLDoc(xmlString);
	  return new xml.JXONTree(xmlDoc);
	};

	/**
	 * Helper function to extract the keyvalue of a JXONTree obj
	 *
	 * @param xmlObj {JXONTree}
	 * return the key value or undefined;
	 */
	xml.keyValue = function getKeyValue(xmlObj) {
	  if(xmlObj){
	    return xmlObj.keyValue;
	  }
	  return undefined;
	};

	xml.attr = function getAttrValue(xmlObj, attr) {
	  if(xmlObj) {
	    return xmlObj['@' + utilities.decapitalize(attr)];
	  }
	  return undefined;
	};

	xml.encode = function encodeXML(str) {
	  if (!utilities.isString(str)) return undefined;

	  return str.replace(/&/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/"/g, '&quot;')
	    .replace(/'/g, '&apos;');
	};

	xml.decode = function decodeXML(str) {
	  if (!utilities.isString(str)) return undefined;

	  return str.replace(/&apos;/g, "'")
	    .replace(/&quot;/g, '"')
	    .replace(/&gt;/g, '>')
	    .replace(/&lt;/g, '<')
	    .replace(/&amp;/g, '&');
	};

	module.exports = xml;

	},{"./utilityFunctions":45}],47:[function(require,module,exports){
	'use strict';


	window._molSettings = null;

	require('./plugin/components/ads-label_5');
	require('./plugin/components/black-poster_5');

	console.log('Custom MailOnline plugin version 1.2.6');

	var videoJsVAST = require('./plugin/videojs.vast.vpaid');

	if (videojs.registerPlugin) {
		videojs.registerPlugin('vastClient', videoJsVAST);
	}
	else {
		videojs.plugin('vastClient', videoJsVAST);
	}

	},{"./plugin/components/ads-label_5":33,"./plugin/components/black-poster_5":35,"./plugin/videojs.vast.vpaid":36}]},{},[47])
	//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJib3dlcl9jb21wb25lbnRzL1ZQQUlESFRNTDVDbGllbnQvanMvSVZQQUlEQWRVbml0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9WUEFJREhUTUw1Q2xpZW50L2pzL1ZQQUlEQWRVbml0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9WUEFJREhUTUw1Q2xpZW50L2pzL1ZQQUlESFRNTDVDbGllbnQuanMiLCJib3dlcl9jb21wb25lbnRzL1ZQQUlESFRNTDVDbGllbnQvanMvc3Vic2NyaWJlci5qcyIsImJvd2VyX2NvbXBvbmVudHMvVlBBSURIVE1MNUNsaWVudC9qcy91dGlscy5qcyIsInNyYy9zY3JpcHRzL2Fkcy9pY29uL0ljb25JbnRlZ3JhdG9yLmpzIiwic3JjL3NjcmlwdHMvYWRzL3Zhc3QvQWQuanMiLCJzcmMvc2NyaXB0cy9hZHMvdmFzdC9DYXRlZ29yeS5qcyIsInNyYy9zY3JpcHRzL2Fkcy92YXN0L0NvbXBhbmlvbi5qcyIsInNyYy9zY3JpcHRzL2Fkcy92YXN0L0NyZWF0aXZlLmpzIiwic3JjL3NjcmlwdHMvYWRzL3Zhc3QvSWNvbi5qcyIsInNyYy9zY3JpcHRzL2Fkcy92YXN0L0luTGluZS5qcyIsInNyYy9zY3JpcHRzL2Fkcy92YXN0L0ludGVyYWN0aXZlQ3JlYXRpdmVGaWxlLmpzIiwic3JjL3NjcmlwdHMvYWRzL3Zhc3QvTGluZWFyLmpzIiwic3JjL3NjcmlwdHMvYWRzL3Zhc3QvTWVkaWFGaWxlLmpzIiwic3JjL3NjcmlwdHMvYWRzL3Zhc3QvVHJhY2tpbmdFdmVudC5qcyIsInNyYy9zY3JpcHRzL2Fkcy92YXN0L1VuaXZlcnNhbEFkSWQuanMiLCJzcmMvc2NyaXB0cy9hZHMvdmFzdC9WQVNUQ2xpZW50LmpzIiwic3JjL3NjcmlwdHMvYWRzL3Zhc3QvVkFTVEVycm9yLmpzIiwic3JjL3NjcmlwdHMvYWRzL3Zhc3QvVkFTVEludGVncmF0b3IuanMiLCJzcmMvc2NyaXB0cy9hZHMvdmFzdC9WQVNUUmVzcG9uc2UuanMiLCJzcmMvc2NyaXB0cy9hZHMvdmFzdC9WQVNUVHJhY2tlci5qcyIsInNyYy9zY3JpcHRzL2Fkcy92YXN0L1ZlcmlmaWNhdGlvbi5qcyIsInNyYy9zY3JpcHRzL2Fkcy92YXN0L1ZpZGVvQ2xpY2tzLmpzIiwic3JjL3NjcmlwdHMvYWRzL3Zhc3QvVmlld2FibGVJbXByZXNzaW9uLmpzIiwic3JjL3NjcmlwdHMvYWRzL3Zhc3QvV3JhcHBlci5qcyIsInNyYy9zY3JpcHRzL2Fkcy92YXN0L3BhcnNlcnMuanMiLCJzcmMvc2NyaXB0cy9hZHMvdmFzdC92YXN0VXRpbC5qcyIsInNyYy9zY3JpcHRzL2Fkcy92cGFpZC9WUEFJREFkVW5pdFdyYXBwZXIuanMiLCJzcmMvc2NyaXB0cy9hZHMvdnBhaWQvVlBBSURIVE1MNVRlY2guanMiLCJzcmMvc2NyaXB0cy9hZHMvdnBhaWQvVlBBSURJbnRlZ3JhdG9yLmpzIiwic3JjL3NjcmlwdHMvcGx1Z2luL2NvbXBvbmVudHMvYWRzLWxhYmVsLmpzIiwic3JjL3NjcmlwdHMvcGx1Z2luL2NvbXBvbmVudHMvYWRzLWxhYmVsXzUuanMiLCJzcmMvc2NyaXB0cy9wbHVnaW4vY29tcG9uZW50cy9ibGFjay1wb3N0ZXIuanMiLCJzcmMvc2NyaXB0cy9wbHVnaW4vY29tcG9uZW50cy9ibGFjay1wb3N0ZXJfNS5qcyIsInNyYy9zY3JpcHRzL3BsdWdpbi92aWRlb2pzLnZhc3QudnBhaWQuanMiLCJzcmMvc2NyaXB0cy91dGlscy9hblZpZGVvVmlld2FiaWxpdHkuanMiLCJzcmMvc2NyaXB0cy91dGlscy9hc3luYy5qcyIsInNyYy9zY3JpcHRzL3V0aWxzL2NvbnNvbGVMb2dnZXIuanMiLCJzcmMvc2NyaXB0cy91dGlscy9kb20uanMiLCJzcmMvc2NyaXB0cy91dGlscy9odHRwLmpzIiwic3JjL3NjcmlwdHMvdXRpbHMvbWltZXR5cGVzLmpzIiwic3JjL3NjcmlwdHMvdXRpbHMvcGxheWVyVXRpbHMuanMiLCJzcmMvc2NyaXB0cy91dGlscy91cmxVdGlscy5qcyIsInNyYy9zY3JpcHRzL3V0aWxzL3V0aWxpdHlGdW5jdGlvbnMuanMiLCJzcmMvc2NyaXB0cy91dGlscy94bWwuanMiLCJzcmMvc2NyaXB0cy92aWRlb2pzXzUudmFzdC52cGFpZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0JztcblxudmFyIE1FVEhPRFMgPSBbXG4gICAgJ2hhbmRzaGFrZVZlcnNpb24nLFxuICAgICdpbml0QWQnLFxuICAgICdzdGFydEFkJyxcbiAgICAnc3RvcEFkJyxcbiAgICAnc2tpcEFkJywgLy8gVlBBSUQgMi4wIG5ldyBtZXRob2RcbiAgICAncmVzaXplQWQnLFxuICAgICdwYXVzZUFkJyxcbiAgICAncmVzdW1lQWQnLFxuICAgICdleHBhbmRBZCcsXG4gICAgJ2NvbGxhcHNlQWQnLFxuICAgICdzdWJzY3JpYmUnLFxuICAgICd1bnN1YnNjcmliZSdcbl07XG5cbnZhciBFVkVOVFMgPSBbXG4gICAgJ0FkTG9hZGVkJyxcbiAgICAnQWRTdGFydGVkJyxcbiAgICAnQWRTdG9wcGVkJyxcbiAgICAnQWRTa2lwcGVkJyxcbiAgICAnQWRTa2lwcGFibGVTdGF0ZUNoYW5nZScsIC8vIFZQQUlEIDIuMCBuZXcgZXZlbnRcbiAgICAnQWRTaXplQ2hhbmdlJywgLy8gVlBBSUQgMi4wIG5ldyBldmVudFxuICAgICdBZExpbmVhckNoYW5nZScsXG4gICAgJ0FkRHVyYXRpb25DaGFuZ2UnLCAvLyBWUEFJRCAyLjAgbmV3IGV2ZW50XG4gICAgJ0FkRXhwYW5kZWRDaGFuZ2UnLFxuICAgICdBZFJlbWFpbmluZ1RpbWVDaGFuZ2UnLCAvLyBbRGVwcmVjYXRlZCBpbiAyLjBdIGJ1dCB3aWxsIGJlIHN0aWxsIGZpcmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICdBZFZvbHVtZUNoYW5nZScsXG4gICAgJ0FkSW1wcmVzc2lvbicsXG4gICAgJ0FkVmlkZW9TdGFydCcsXG4gICAgJ0FkVmlkZW9GaXJzdFF1YXJ0aWxlJyxcbiAgICAnQWRWaWRlb01pZHBvaW50JyxcbiAgICAnQWRWaWRlb1RoaXJkUXVhcnRpbGUnLFxuICAgICdBZFZpZGVvQ29tcGxldGUnLFxuICAgICdBZENsaWNrVGhydScsXG4gICAgJ0FkSW50ZXJhY3Rpb24nLCAvLyBWUEFJRCAyLjAgbmV3IGV2ZW50XG4gICAgJ0FkVXNlckFjY2VwdEludml0YXRpb24nLFxuICAgICdBZFVzZXJNaW5pbWl6ZScsXG4gICAgJ0FkVXNlckNsb3NlJyxcbiAgICAnQWRQYXVzZWQnLFxuICAgICdBZFBsYXlpbmcnLFxuICAgICdBZExvZycsXG4gICAgJ0FkRXJyb3InXG5dO1xuXG52YXIgR0VUVEVSUyA9IFtcbiAgICAnZ2V0QWRMaW5lYXInLFxuICAgICdnZXRBZFdpZHRoJywgLy8gVlBBSUQgMi4wIG5ldyBnZXR0ZXJcbiAgICAnZ2V0QWRIZWlnaHQnLCAvLyBWUEFJRCAyLjAgbmV3IGdldHRlclxuICAgICdnZXRBZEV4cGFuZGVkJyxcbiAgICAnZ2V0QWRTa2lwcGFibGVTdGF0ZScsIC8vIFZQQUlEIDIuMCBuZXcgZ2V0dGVyXG4gICAgJ2dldEFkUmVtYWluaW5nVGltZScsXG4gICAgJ2dldEFkRHVyYXRpb24nLCAvLyBWUEFJRCAyLjAgbmV3IGdldHRlclxuICAgICdnZXRBZFZvbHVtZScsXG4gICAgJ2dldEFkQ29tcGFuaW9ucycsIC8vIFZQQUlEIDIuMCBuZXcgZ2V0dGVyXG4gICAgJ2dldEFkSWNvbnMnIC8vIFZQQUlEIDIuMCBuZXcgZ2V0dGVyXG5dO1xuXG52YXIgU0VUVEVSUyA9IFtcbiAgICAnc2V0QWRWb2x1bWUnXG5dO1xuXG5cbi8qKlxuICogVGhpcyBjYWxsYmFjayBpcyBkaXNwbGF5ZWQgYXMgZ2xvYmFsIG1lbWJlci4gVGhlIGNhbGxiYWNrIHVzZSBub2RlanMgZXJyb3ItZmlyc3QgY2FsbGJhY2sgc3R5bGVcbiAqIEBjYWxsYmFjayBOb2RlU3R5bGVDYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd8bnVsbH1cbiAqIEBwYXJhbSB7dW5kZWZpbmVkfG9iamVjdH1cbiAqL1xuXG5cbi8qKlxuICogSVZQQUlEQWRVbml0XG4gKlxuICogQGNsYXNzXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNyZWF0aXZlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fSB2aWRlb1xuICovXG5mdW5jdGlvbiBJVlBBSURBZFVuaXQoY3JlYXRpdmUsIGVsLCB2aWRlbykge31cblxuXG4vKipcbiAqIGhhbmRzaGFrZVZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gVlBBSURWZXJzaW9uXG4gKiBAcGFyYW0ge25vZGVTdHlsZUNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5JVlBBSURBZFVuaXQucHJvdG90eXBlLmhhbmRzaGFrZVZlcnNpb24gPSBmdW5jdGlvbiAoVlBBSURWZXJzaW9uLCBjYWxsYmFjaykge307XG5cbi8qKlxuICogaW5pdEFkXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge3N0cmluZ30gdmlld01vZGUgY2FuIGJlICdub3JtYWwnLCAndGh1bWJuYWlsJyBvciAnZnVsbHNjcmVlbidcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXNpcmVkQml0cmF0ZSBpbmRpY2F0ZXMgdGhlIGRlc2lyZWQgYml0cmF0ZSBpbiBrYnBzXG4gKiBAcGFyYW0ge29iamVjdH0gW2NyZWF0aXZlRGF0YV0gdXNlZCBmb3IgYWRkaXRpb25hbCBpbml0aWFsaXphdGlvbiBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gW2Vudmlyb25tZW50VmFyc10gdXNlZCBmb3IgcGFzc2luZyBpbXBsZW1lbnRhdGlvbi1zcGVjaWZpYyBvZiBqcyB2ZXJzaW9uXG4gKiBAcGFyYW0ge05vZGVTdHlsZUNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5JVlBBSURBZFVuaXQucHJvdG90eXBlLmluaXRBZCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHZpZXdNb2RlLCBkZXNpcmVkQml0cmF0ZSwgY3JlYXRpdmVEYXRhLCBlbnZpcm9ubWVudFZhcnMsIGNhbGxiYWNrKSB7fTtcblxuLyoqXG4gKiBzdGFydEFkXG4gKlxuICogQHBhcmFtIHtub2RlU3R5bGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuSVZQQUlEQWRVbml0LnByb3RvdHlwZS5zdGFydEFkID0gZnVuY3Rpb24oY2FsbGJhY2spIHt9O1xuXG4vKipcbiAqIHN0b3BBZFxuICpcbiAqIEBwYXJhbSB7bm9kZVN0eWxlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbklWUEFJREFkVW5pdC5wcm90b3R5cGUuc3RvcEFkID0gZnVuY3Rpb24oY2FsbGJhY2spIHt9O1xuXG4vKipcbiAqIHNraXBBZFxuICpcbiAqIEBwYXJhbSB7bm9kZVN0eWxlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbklWUEFJREFkVW5pdC5wcm90b3R5cGUuc2tpcEFkID0gZnVuY3Rpb24oY2FsbGJhY2spIHt9O1xuXG4vKipcbiAqIHJlc2l6ZUFkXG4gKlxuICogQHBhcmFtIHtub2RlU3R5bGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuSVZQQUlEQWRVbml0LnByb3RvdHlwZS5yZXNpemVBZCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHZpZXdNb2RlLCBjYWxsYmFjaykge307XG5cbi8qKlxuICogcGF1c2VBZFxuICpcbiAqIEBwYXJhbSB7bm9kZVN0eWxlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbklWUEFJREFkVW5pdC5wcm90b3R5cGUucGF1c2VBZCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7fTtcblxuLyoqXG4gKiByZXN1bWVBZFxuICpcbiAqIEBwYXJhbSB7bm9kZVN0eWxlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbklWUEFJREFkVW5pdC5wcm90b3R5cGUucmVzdW1lQWQgPSBmdW5jdGlvbihjYWxsYmFjaykge307XG5cbi8qKlxuICogZXhwYW5kQWRcbiAqXG4gKiBAcGFyYW0ge25vZGVTdHlsZUNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5JVlBBSURBZFVuaXQucHJvdG90eXBlLmV4cGFuZEFkID0gZnVuY3Rpb24oY2FsbGJhY2spIHt9O1xuXG4vKipcbiAqIGNvbGxhcHNlQWRcbiAqXG4gKiBAcGFyYW0ge25vZGVTdHlsZUNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5JVlBBSURBZFVuaXQucHJvdG90eXBlLmNvbGxhcHNlQWQgPSBmdW5jdGlvbihjYWxsYmFjaykge307XG5cbi8qKlxuICogc3Vic2NyaWJlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge25vZGVTdHlsZUNhbGxiYWNrfSBoYW5kbGVyXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICovXG5JVlBBSURBZFVuaXQucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7fTtcblxuLyoqXG4gKiBzdGFydEFkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbklWUEFJREFkVW5pdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbihldmVudCwgaGFuZGxlcikge307XG5cblxuXG4vKipcbiAqIGdldEFkTGluZWFyXG4gKlxuICogQHBhcmFtIHtub2RlU3R5bGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuSVZQQUlEQWRVbml0LnByb3RvdHlwZS5nZXRBZExpbmVhciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7fTtcblxuLyoqXG4gKiBnZXRBZFdpZHRoXG4gKlxuICogQHBhcmFtIHtub2RlU3R5bGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuSVZQQUlEQWRVbml0LnByb3RvdHlwZS5nZXRBZFdpZHRoID0gZnVuY3Rpb24oY2FsbGJhY2spIHt9O1xuXG4vKipcbiAqIGdldEFkSGVpZ2h0XG4gKlxuICogQHBhcmFtIHtub2RlU3R5bGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuSVZQQUlEQWRVbml0LnByb3RvdHlwZS5nZXRBZEhlaWdodCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7fTtcblxuLyoqXG4gKiBnZXRBZEV4cGFuZGVkXG4gKlxuICogQHBhcmFtIHtub2RlU3R5bGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuSVZQQUlEQWRVbml0LnByb3RvdHlwZS5nZXRBZEV4cGFuZGVkID0gZnVuY3Rpb24oY2FsbGJhY2spIHt9O1xuXG4vKipcbiAqIGdldEFkU2tpcHBhYmxlU3RhdGVcbiAqXG4gKiBAcGFyYW0ge25vZGVTdHlsZUNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5JVlBBSURBZFVuaXQucHJvdG90eXBlLmdldEFkU2tpcHBhYmxlU3RhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge307XG5cbi8qKlxuICogZ2V0QWRSZW1haW5pbmdUaW1lXG4gKlxuICogQHBhcmFtIHtub2RlU3R5bGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuSVZQQUlEQWRVbml0LnByb3RvdHlwZS5nZXRBZFJlbWFpbmluZ1RpbWUgPSBmdW5jdGlvbihjYWxsYmFjaykge307XG5cbi8qKlxuICogZ2V0QWREdXJhdGlvblxuICpcbiAqIEBwYXJhbSB7bm9kZVN0eWxlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbklWUEFJREFkVW5pdC5wcm90b3R5cGUuZ2V0QWREdXJhdGlvbiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7fTtcblxuLyoqXG4gKiBnZXRBZFZvbHVtZVxuICpcbiAqIEBwYXJhbSB7bm9kZVN0eWxlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbklWUEFJREFkVW5pdC5wcm90b3R5cGUuZ2V0QWRWb2x1bWUgPSBmdW5jdGlvbihjYWxsYmFjaykge307XG5cbi8qKlxuICogZ2V0QWRDb21wYW5pb25zXG4gKlxuICogQHBhcmFtIHtub2RlU3R5bGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuSVZQQUlEQWRVbml0LnByb3RvdHlwZS5nZXRBZENvbXBhbmlvbnMgPSBmdW5jdGlvbihjYWxsYmFjaykge307XG5cbi8qKlxuICogZ2V0QWRJY29uc1xuICpcbiAqIEBwYXJhbSB7bm9kZVN0eWxlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbklWUEFJREFkVW5pdC5wcm90b3R5cGUuZ2V0QWRJY29ucyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7fTtcblxuLyoqXG4gKiBzZXRBZFZvbHVtZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWVcbiAqIEBwYXJhbSB7bm9kZVN0eWxlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbklWUEFJREFkVW5pdC5wcm90b3R5cGUuc2V0QWRWb2x1bWUgPSBmdW5jdGlvbih2b2x1bWUsIGNhbGxiYWNrKSB7fTtcblxuYWRkU3RhdGljVG9JbnRlcmZhY2UoSVZQQUlEQWRVbml0LCAnTUVUSE9EUycsIE1FVEhPRFMpO1xuYWRkU3RhdGljVG9JbnRlcmZhY2UoSVZQQUlEQWRVbml0LCAnR0VUVEVSUycsIEdFVFRFUlMpO1xuYWRkU3RhdGljVG9JbnRlcmZhY2UoSVZQQUlEQWRVbml0LCAnU0VUVEVSUycsIFNFVFRFUlMpO1xuYWRkU3RhdGljVG9JbnRlcmZhY2UoSVZQQUlEQWRVbml0LCAnRVZFTlRTJywgIEVWRU5UUyk7XG5cblxudmFyIFZQQUlEMV9NRVRIT0RTID0gTUVUSE9EUy5maWx0ZXIoZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgcmV0dXJuIFsnc2tpcEFkJ10uaW5kZXhPZihtZXRob2QpID09PSAtMTtcbn0pO1xuXG5hZGRTdGF0aWNUb0ludGVyZmFjZShJVlBBSURBZFVuaXQsICdjaGVja1ZQQUlESW50ZXJmYWNlJywgZnVuY3Rpb24gY2hlY2tWUEFJREludGVyZmFjZSAoY3JlYXRpdmUpIHtcbiAgICB2YXIgcmVzdWx0ID0gVlBBSUQxX01FVEhPRFMuZXZlcnkoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgY3JlYXRpdmVba2V5XSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSVZQQUlEQWRVbml0O1xuXG5mdW5jdGlvbiBhZGRTdGF0aWNUb0ludGVyZmFjZShJbnRlcmZhY2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEludGVyZmFjZSwgbmFtZSwge1xuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBJVlBBSURBZFVuaXQgPSByZXF1aXJlKCcuL0lWUEFJREFkVW5pdCcpO1xudmFyIFN1YnNjcmliZXIgPSByZXF1aXJlKCcuL3N1YnNjcmliZXInKTtcbnZhciBjaGVja1ZQQUlESW50ZXJmYWNlID0gSVZQQUlEQWRVbml0LmNoZWNrVlBBSURJbnRlcmZhY2U7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgTUVUSE9EUyA9IElWUEFJREFkVW5pdC5NRVRIT0RTO1xudmFyIEVSUk9SID0gJ0FkRXJyb3InO1xudmFyIEFEX0NMSUNLID0gJ0FkQ2xpY2tUaHJ1JztcbnZhciBGSUxURVJFRF9FVkVOVFMgPSBJVlBBSURBZFVuaXQuRVZFTlRTLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQgIT0gQURfQ0xJQ0s7XG59KTtcblxuLyoqXG4gKiBUaGlzIGNhbGxiYWNrIGlzIGRpc3BsYXllZCBhcyBnbG9iYWwgbWVtYmVyLiBUaGUgY2FsbGJhY2sgdXNlIG5vZGVqcyBlcnJvci1maXJzdCBjYWxsYmFjayBzdHlsZVxuICogQGNhbGxiYWNrIE5vZGVTdHlsZUNhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ3xudWxsfVxuICogQHBhcmFtIHt1bmRlZmluZWR8b2JqZWN0fVxuICovXG5cblxuLyoqXG4gKiBWUEFJREFkVW5pdFxuICogQGNsYXNzXG4gKlxuICogQHBhcmFtIFZQQUlEQ3JlYXRpdmVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtlbF0gdGhpcyB3aWxsIGJlIHVzZWQgaW4gaW5pdEFkIGVudmlyb25tZW50VmFycy5zbG90IGlmIGRlZmluZWRcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudH0gW3ZpZGVvXSB0aGlzIHdpbGwgYmUgdXNlZCBpbiBpbml0QWQgZW52aXJvbm1lbnRWYXJzLnZpZGVvU2xvdCBpZiBkZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIFZQQUlEQWRVbml0KFZQQUlEQ3JlYXRpdmUsIGVsLCB2aWRlbywgaWZyYW1lKSB7XG4gICAgdGhpcy5faXNWYWxpZCA9IGNoZWNrVlBBSURJbnRlcmZhY2UoVlBBSURDcmVhdGl2ZSk7XG4gICAgaWYgKHRoaXMuX2lzVmFsaWQpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRpdmUgPSBWUEFJRENyZWF0aXZlO1xuICAgICAgICB0aGlzLl9lbCA9IGVsO1xuICAgICAgICB0aGlzLl92aWRlb0VsID0gdmlkZW87XG4gICAgICAgIHRoaXMuX2lmcmFtZSA9IGlmcmFtZTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBuZXcgU3Vic2NyaWJlcigpO1xuICAgICAgICB1dGlscy5zZXRGdWxsU2l6ZVN0eWxlKGVsKTtcbiAgICAgICAgJGFkZEV2ZW50c1N1YnNjcmliZXJzLmNhbGwodGhpcyk7XG4gICAgfVxufVxuXG5WUEFJREFkVW5pdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKElWUEFJREFkVW5pdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIGlzVmFsaWRWUEFJREFkIHdpbGwgcmV0dXJuIGlmIHRoZSBWUEFJRENyZWF0aXZlIHBhc3NlZCBpbiBjb25zdHJ1Y3RvciBpcyB2YWxpZCBvciBub3RcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5WUEFJREFkVW5pdC5wcm90b3R5cGUuaXNWYWxpZFZQQUlEQWQgPSBmdW5jdGlvbiBpc1ZhbGlkVlBBSURBZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbn07XG5cbklWUEFJREFkVW5pdC5NRVRIT0RTLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgLy9OT1RFOiB0aGlzIG1ldGhvZHMgYXJndW1lbnRzIG9yZGVyIGFyZSBpbXBsZW1lbnRlZCBkaWZmZXJlbnRseSBmcm9tIHRoZSBzcGVjXG4gICAgdmFyIGlnbm9yZXMgPSBbXG4gICAgICAgICdzdWJzY3JpYmUnLFxuICAgICAgICAndW5zdWJzY3JpYmUnLFxuICAgICAgICAnaW5pdEFkJ1xuICAgIF07XG5cbiAgICBpZiAoaWdub3Jlcy5pbmRleE9mKG1ldGhvZCkgIT09IC0xKSByZXR1cm47XG5cbiAgICBWUEFJREFkVW5pdC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyaWF0eSA9IElWUEFJREFkVW5pdC5wcm90b3R5cGVbbWV0aG9kXS5sZW5ndGg7XG4gICAgICAgIC8vIFRPRE8gYXZvaWQgbGVha2luZyBhcmd1bWVudHNcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzIzMyLWxlYWtpbmctYXJndW1lbnRzXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gKGFyaWF0eSA9PT0gYXJncy5sZW5ndGgpID8gYXJncy5wb3AoKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fY3JlYXRpdmVbbWV0aG9kXS5hcHBseSh0aGlzLl9jcmVhdGl2ZSwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbGxPclRyaWdnZXJFdmVudChjYWxsYmFjaywgdGhpcy5fc3Vic2NyaWJlcnMsIGVycm9yLCByZXN1bHQpO1xuICAgICAgICB9LmJpbmQodGhpcyksIDApO1xuICAgIH07XG59KTtcblxuXG4vKipcbiAqIGluaXRBZCBjb25jcmVhdGUgaW1wbGVtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3TW9kZSBjYW4gYmUgJ25vcm1hbCcsICd0aHVtYm5haWwnIG9yICdmdWxsc2NyZWVuJ1xuICogQHBhcmFtIHtudW1iZXJ9IGRlc2lyZWRCaXRyYXRlIGluZGljYXRlcyB0aGUgZGVzaXJlZCBiaXRyYXRlIGluIGticHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbY3JlYXRpdmVEYXRhXSB1c2VkIGZvciBhZGRpdGlvbmFsIGluaXRpYWxpemF0aW9uIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBbZW52aXJvbm1lbnRWYXJzXSB1c2VkIGZvciBwYXNzaW5nIGltcGxlbWVudGF0aW9uLXNwZWNpZmljIG9mIGpzIHZlcnNpb24sIGlmIGVsICYgdmlkZW8gd2FzIHVzZWQgaW4gY29uc3RydWN0b3Igc2xvdCAmIHZpZGVvU2xvdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBvYmplY3RcbiAqIEBwYXJhbSB7Tm9kZVN0eWxlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cblZQQUlEQWRVbml0LnByb3RvdHlwZS5pbml0QWQgPSBmdW5jdGlvbiBpbml0QWQod2lkdGgsIGhlaWdodCwgdmlld01vZGUsIGRlc2lyZWRCaXRyYXRlLCBjcmVhdGl2ZURhdGEsIGVudmlyb25tZW50VmFycywgY2FsbGJhY2spIHtcbiAgICBjcmVhdGl2ZURhdGEgPSBjcmVhdGl2ZURhdGEgfHwge307XG4gICAgZW52aXJvbm1lbnRWYXJzID0gdXRpbHMuZXh0ZW5kKHtcbiAgICAgICAgc2xvdDogdGhpcy5fZWwsXG4gICAgICAgIHZpZGVvU2xvdDogdGhpcy5fdmlkZW9FbFxuICAgIH0sIGVudmlyb25tZW50VmFycyB8fCB7fSk7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRpdmUuaW5pdEFkKHdpZHRoLCBoZWlnaHQsIHZpZXdNb2RlLCBkZXNpcmVkQml0cmF0ZSwgY3JlYXRpdmVEYXRhLCBlbnZpcm9ubWVudFZhcnMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsT3JUcmlnZ2VyRXZlbnQoY2FsbGJhY2ssIHRoaXMuX3N1YnNjcmliZXJzLCBlcnJvcik7XG4gICAgfS5iaW5kKHRoaXMpLCAwKTtcbn07XG5cbi8qKlxuICogc3Vic2NyaWJlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge25vZGVTdHlsZUNhbGxiYWNrfSBoYW5kbGVyXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICovXG5WUEFJREFkVW5pdC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMuc3Vic2NyaWJlKGhhbmRsZXIsIGV2ZW50LCBjb250ZXh0KTtcbn07XG5cblxuLyoqXG4gKiB1bnN1YnNjcmliZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtub2RlU3R5bGVDYWxsYmFja30gaGFuZGxlclxuICovXG5WUEFJREFkVW5pdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZShldmVudCwgaGFuZGxlcikge1xuICAgIHRoaXMuX3N1YnNjcmliZXJzLnVuc3Vic2NyaWJlKGhhbmRsZXIsIGV2ZW50KTtcbn07XG5cbi8vYWxpYXNcblZQQUlEQWRVbml0LnByb3RvdHlwZS5vbiA9IFZQQUlEQWRVbml0LnByb3RvdHlwZS5zdWJzY3JpYmU7XG5WUEFJREFkVW5pdC5wcm90b3R5cGUub2ZmID0gVlBBSURBZFVuaXQucHJvdG90eXBlLnVuc3Vic2NyaWJlO1xuXG5JVlBBSURBZFVuaXQuR0VUVEVSUy5mb3JFYWNoKGZ1bmN0aW9uKGdldHRlcikge1xuICAgIFZQQUlEQWRVbml0LnByb3RvdHlwZVtnZXR0ZXJdID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2NyZWF0aXZlW2dldHRlcl0oKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbE9yVHJpZ2dlckV2ZW50KGNhbGxiYWNrLCB0aGlzLl9zdWJzY3JpYmVycywgZXJyb3IsIHJlc3VsdCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgMCk7XG4gICAgfTtcbn0pO1xuXG4vKipcbiAqIHNldEFkVm9sdW1lXG4gKlxuICogQHBhcmFtIHZvbHVtZVxuICogQHBhcmFtIHtub2RlU3R5bGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuVlBBSURBZFVuaXQucHJvdG90eXBlLnNldEFkVm9sdW1lID0gZnVuY3Rpb24gc2V0QWRWb2x1bWUodm9sdW1lLCBjYWxsYmFjaykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciByZXN1bHQsIGVycm9yID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0aXZlLnNldEFkVm9sdW1lKHZvbHVtZSk7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9jcmVhdGl2ZS5nZXRBZFZvbHVtZSgpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yID0gdXRpbHMudmFsaWRhdGUocmVzdWx0ID09PSB2b2x1bWUsICdmYWlsZWQgdG8gYXBwbHkgdm9sdW1lOiAnICsgdm9sdW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsT3JUcmlnZ2VyRXZlbnQoY2FsbGJhY2ssIHRoaXMuX3N1YnNjcmliZXJzLCBlcnJvciwgcmVzdWx0KTtcbiAgICB9LmJpbmQodGhpcyksIDApO1xufTtcblxuVlBBSURBZFVuaXQucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3BBZCgpO1xuICAgIHRoaXMuX3N1YnNjcmliZXJzLnVuc3Vic2NyaWJlQWxsKCk7XG59O1xuXG5mdW5jdGlvbiAkYWRkRXZlbnRzU3Vic2NyaWJlcnMoKSB7XG4gICAgLy8gc29tZSBhZHMgaW1wbGVtZW50XG4gICAgLy8gc28gdGhleSBvbmx5IGhhbmRsZSBvbmUgc3Vic2NyaWJlclxuICAgIC8vIHRvIGhhbmRsZSB0aGlzIHdlIGNyZWF0ZSBvdXIgb25lXG4gICAgRklMVEVSRURfRVZFTlRTLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2NyZWF0aXZlLnN1YnNjcmliZSgkdHJpZ2dlci5iaW5kKHRoaXMsIGV2ZW50KSwgZXZlbnQpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAvLyBtYXAgdGhlIGNsaWNrIGV2ZW50IHRvIGJlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGRlcGVuZGluZyBvZiB0aGUgb3JkZXIgb2YgdGhlIGFyZ3VtZW50c1xuICAgIC8vIGFuZCB0byBiZSBjb25zaXN0ZW50IHdpdGggdGhlIGZsYXNoXG4gICAgdGhpcy5fY3JlYXRpdmUuc3Vic2NyaWJlKCRjbGlja1RocnVIb29rLmJpbmQodGhpcyksIEFEX0NMSUNLKTtcblxuICAgIC8vIGJlY2F1c2Ugd2UgYXJlIGFkZGluZyB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZVxuICAgIC8vIHRoZSB1c2VyIGlzIG5vdCBhYmxlIHRvIGNsaWNrIGluIHRoZSB2aWRlb1xuICAgIGlmICh0aGlzLl92aWRlb0VsKSB7XG4gICAgICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSB0aGlzLl9pZnJhbWUuY29udGVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgdmFyIHZpZGVvRWwgPSB0aGlzLl92aWRlb0VsO1xuICAgICAgICBkb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZpZGVvRWwuY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiAkY2xpY2tUaHJ1SG9vayh1cmwsIGlkLCBwbGF5ZXJIYW5kbGVzKSB7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMudHJpZ2dlclN5bmMoQURfQ0xJQ0ssIHt1cmw6IHVybCwgaWQ6IGlkLCBwbGF5ZXJIYW5kbGVzOiBwbGF5ZXJIYW5kbGVzfSk7XG59XG5cbmZ1bmN0aW9uICR0cmlnZ2VyKGV2ZW50KSB7XG4gICAgLy8gVE9ETyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50c1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzMi1sZWFraW5nLWFyZ3VtZW50c1xuICAgIHRoaXMuX3N1YnNjcmliZXJzLnRyaWdnZXIoZXZlbnQsIEFycmF5LnByb3RvdHlwZS5zbGljZShhcmd1bWVudHMsIDEpKTtcbn1cblxuZnVuY3Rpb24gY2FsbE9yVHJpZ2dlckV2ZW50KGNhbGxiYWNrLCBzdWJzY3JpYmVycywgZXJyb3IsIHJlc3VsdCkge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhlcnJvciwgcmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKGVycm9yKSB7XG4gICAgICAgIHN1YnNjcmliZXJzLnRyaWdnZXIoRVJST1IsIGVycm9yKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVlBBSURBZFVuaXQ7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHVuaXF1ZSA9IHV0aWxzLnVuaXF1ZSgndnBhaWRJZnJhbWUnKTtcbnZhciBWUEFJREFkVW5pdCA9IHJlcXVpcmUoJy4vVlBBSURBZFVuaXQnKTtcblxudmFyIGRlZmF1bHRUZW1wbGF0ZSA9ICc8IURPQ1RZUEUgaHRtbD4nICtcbiAgICAnPGh0bWwgbGFuZz1cImVuXCI+JyArXG4gICAgJzxoZWFkPjxtZXRhIGNoYXJzZXQ9XCJVVEYtOFwiPjwvaGVhZD4nICtcbiAgICAnPGJvZHkgc3R5bGU9XCJtYXJnaW46MDtwYWRkaW5nOjBcIj48ZGl2IGNsYXNzPVwiYWQtZWxlbWVudFwiPjwvZGl2PicgK1xuICAgICc8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJ7e2lmcmFtZVVSTF9KU319XCI+PC9zY3JpcHQ+JyArXG4gICAgJzxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiPicgK1xuICAgICd3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKFxcJ3tcImV2ZW50XCI6IFwicmVhZHlcIiwgXCJpZFwiOiBcInt7aWZyYW1lSUR9fVwifVxcJywgXFwne3tvcmlnaW59fVxcJyk7JyArXG4gICAgJzwvc2NyaXB0PicgK1xuICAgICc8L2JvZHk+JyArXG4gICAgJzwvaHRtbD4nO1xuXG52YXIgQURfU1RPUFBFRCA9ICdBZFN0b3BwZWQnO1xuXG4vKipcbiAqIFRoaXMgY2FsbGJhY2sgaXMgZGlzcGxheWVkIGFzIGdsb2JhbCBtZW1iZXIuIFRoZSBjYWxsYmFjayB1c2Ugbm9kZWpzIGVycm9yLWZpcnN0IGNhbGxiYWNrIHN0eWxlXG4gKiBAY2FsbGJhY2sgTm9kZVN0eWxlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfG51bGx9XG4gKiBAcGFyYW0ge3VuZGVmaW5lZHxvYmplY3R9XG4gKi9cblxuLyoqXG4gKiBWUEFJREhUTUw1Q2xpZW50XG4gKiBAY2xhc3NcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGF0IHdpbGwgY29udGFpbiB0aGUgaWZyYW1lIHRvIGxvYWQgYWRVbml0IGFuZCBhIGVsIHRvIGFkZCB0byBhZFVuaXQgc2xvdFxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fSB2aWRlbyBkZWZhdWx0IHZpZGVvIGVsZW1lbnQgdG8gYmUgdXNlZCBieSBhZFVuaXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBbdGVtcGxhdGVDb25maWddIHRlbXBsYXRlOiBodG1sIHRlbXBsYXRlIHRvIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCwgZXh0cmFPcHRpb25zOiB0byBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIHRoZSB0ZW1wbGF0ZVxuICogQHBhcmFtIHtvYmplY3R9IFt2cGFpZE9wdGlvbnNdIHRpbWVvdXQ6IHdoZW4gbG9hZGluZyBhZFVuaXRcbiAqL1xuZnVuY3Rpb24gVlBBSURIVE1MNUNsaWVudChlbCwgdmlkZW8sIHRlbXBsYXRlQ29uZmlnLCB2cGFpZE9wdGlvbnMpIHtcbiAgICB0ZW1wbGF0ZUNvbmZpZyA9IHRlbXBsYXRlQ29uZmlnIHx8IHt9O1xuXG4gICAgdGhpcy5faWQgPSB1bmlxdWUoKTtcbiAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2ZyYW1lQ29udGFpbmVyID0gdXRpbHMuY3JlYXRlRWxlbWVudEluRWwoZWwsICdkaXYnKTtcbiAgICB0aGlzLl92aWRlb0VsID0gdmlkZW87XG4gICAgdGhpcy5fdnBhaWRPcHRpb25zID0gdnBhaWRPcHRpb25zIHx8IHt0aW1lb3V0OiAxMDAwMH07XG5cbiAgICB0aGlzLl90ZW1wbGF0ZUNvbmZpZyA9IHtcbiAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlQ29uZmlnLnRlbXBsYXRlIHx8IGRlZmF1bHRUZW1wbGF0ZSxcbiAgICAgICAgZXh0cmFPcHRpb25zOiB0ZW1wbGF0ZUNvbmZpZy5leHRyYU9wdGlvbnMgfHwge31cbiAgICB9O1xufVxuXG4vKipcbiAqIGRlc3Ryb3lcbiAqXG4gKi9cblZQQUlESFRNTDVDbGllbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICR1bmxvYWRQcmV2aW91c0FkVW5pdC5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBpc0Rlc3Ryb3llZFxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblZQQUlESFRNTDVDbGllbnQucHJvdG90eXBlLmlzRGVzdHJveWVkID0gZnVuY3Rpb24gaXNEZXN0cm95ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rlc3Ryb3llZDtcbn07XG5cbi8qKlxuICogbG9hZEFkVW5pdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZFVSTCB1cmwgb2YgdGhlIGpzIG9mIHRoZSBhZFVuaXRcbiAqIEBwYXJhbSB7bm9kZVN0eWxlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cblZQQUlESFRNTDVDbGllbnQucHJvdG90eXBlLmxvYWRBZFVuaXQgPSBmdW5jdGlvbiBsb2FkQWRVbml0KGFkVVJMLCBjYWxsYmFjaykge1xuICAgICR0aHJvd0lmRGVzdHJveWVkLmNhbGwodGhpcyk7XG4gICAgJHVubG9hZFByZXZpb3VzQWRVbml0LmNhbGwodGhpcyk7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgdmFyIGZyYW1lID0gdXRpbHMuY3JlYXRlSWZyYW1lV2l0aENvbnRlbnQoXG4gICAgICAgIHRoaXMuX2ZyYW1lQ29udGFpbmVyLFxuICAgICAgICB0aGlzLl90ZW1wbGF0ZUNvbmZpZy50ZW1wbGF0ZSxcbiAgICAgICAgdXRpbHMuZXh0ZW5kKHtcbiAgICAgICAgICAgIGlmcmFtZVVSTF9KUzogYWRVUkwsXG4gICAgICAgICAgICBpZnJhbWVJRDogdGhpcy5nZXRJRCgpLFxuICAgICAgICAgICAgb3JpZ2luOiBnZXRPcmlnaW4oKVxuICAgICAgICB9LCB0aGlzLl90ZW1wbGF0ZUNvbmZpZy5leHRyYU9wdGlvbnMpXG4gICAgKTtcblxuICAgIHRoaXMuX2ZyYW1lID0gZnJhbWU7XG5cbiAgICB0aGlzLl9vbkxvYWQgPSB1dGlscy5jYWxsYmFja1RpbWVvdXQoXG4gICAgICAgIHRoaXMuX3ZwYWlkT3B0aW9ucy50aW1lb3V0LFxuICAgICAgICBvbkxvYWQuYmluZCh0aGlzKSxcbiAgICAgICAgb25UaW1lb3V0LmJpbmQodGhpcylcbiAgICApO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vbkxvYWQpO1xuXG4gICAgZnVuY3Rpb24gb25Mb2FkIChlKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczogZmFsc2UgKi9cbiAgICAgICAgLy9kb24ndCBjbGVhciB0aW1lb3V0XG4gICAgICAgIGlmIChlLm9yaWdpbiAhPT0gZ2V0T3JpZ2luKCkpIHJldHVybjtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04ucGFyc2UoZS5kYXRhKTtcblxuICAgICAgICAvL2Rvbid0IGNsZWFyIHRpbWVvdXRcbiAgICAgICAgaWYgKHJlc3VsdC5pZCAhPT0gdGhhdC5nZXRJRCgpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGFkVW5pdCwgZXJyb3IsIGNyZWF0ZUFkO1xuICAgICAgICBpZiAoIXRoYXQuX2ZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcblxuICAgICAgICAgICAgZXJyb3IgPSAndGhlIGlmcmFtZSBpcyBub3QgYW55bW9yZSBpbiB0aGUgRE9NIHRyZWUnO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjcmVhdGVBZCA9IHRoYXQuX2ZyYW1lLmNvbnRlbnRXaW5kb3cuZ2V0VlBBSURBZDtcbiAgICAgICAgICAgIGVycm9yID0gdXRpbHMudmFsaWRhdGUodHlwZW9mIGNyZWF0ZUFkID09PSAnZnVuY3Rpb24nLCAndGhlIGFkIGRpZG5cXCd0IHJldHVybiBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBhZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgdmFyIGFkRWwgPSB0aGF0Ll9mcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hZC1lbGVtZW50Jyk7XG4gICAgICAgICAgICBhZFVuaXQgPSBuZXcgVlBBSURBZFVuaXQoY3JlYXRlQWQoKSwgYWRFbCwgdGhhdC5fdmlkZW9FbCwgdGhhdC5fZnJhbWUpO1xuICAgICAgICAgICAgYWRVbml0LnN1YnNjcmliZShBRF9TVE9QUEVELCAkYWREZXN0cm95ZWQuYmluZCh0aGF0KSk7XG4gICAgICAgICAgICBlcnJvciA9IHV0aWxzLnZhbGlkYXRlKGFkVW5pdC5pc1ZhbGlkVlBBSURBZCgpLCAndGhlIGFkZCBpcyBub3QgZnVsbHkgY29tcGxhaW50IHdpdGggVlBBSUQgc3BlY2lmaWNhdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5fYWRVbml0ID0gYWRVbml0O1xuICAgICAgICAkZGVzdHJveUxvYWRMaXN0ZW5lci5jYWxsKHRoYXQpO1xuICAgICAgICBjYWxsYmFjayhlcnJvciwgZXJyb3IgPyBudWxsIDogYWRVbml0KTtcblxuICAgICAgICAvL2NsZWFyIHRpbWVvdXRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgICBjYWxsYmFjaygndGltZW91dCcsIG51bGwpO1xuICAgIH1cbn07XG5cbi8qKlxuICogdW5sb2FkQWRVbml0XG4gKlxuICovXG5WUEFJREhUTUw1Q2xpZW50LnByb3RvdHlwZS51bmxvYWRBZFVuaXQgPSBmdW5jdGlvbiB1bmxvYWRBZFVuaXQoKSB7XG4gICAgJHVubG9hZFByZXZpb3VzQWRVbml0LmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIGdldElEIHdpbGwgcmV0dXJuIHRoZSB1bmlxdWUgaWRcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblZQQUlESFRNTDVDbGllbnQucHJvdG90eXBlLmdldElEID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbn07XG5cblxuLyoqXG4gKiAkcmVtb3ZlRWxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cbmZ1bmN0aW9uICRyZW1vdmVFbChrZXkpIHtcbiAgICB2YXIgZWwgPSB0aGlzW2tleV07XG4gICAgaWYgKGVsKSB7XG4gICAgICAgIGVsLnJlbW92ZSgpO1xuICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gJGFkRGVzdHJveWVkKCkge1xuICAgICRyZW1vdmVBZEVsZW1lbnRzLmNhbGwodGhpcyk7XG4gICAgZGVsZXRlIHRoaXMuX2FkVW5pdDtcbn1cblxuZnVuY3Rpb24gJHVubG9hZFByZXZpb3VzQWRVbml0KCkge1xuICAgICRyZW1vdmVBZEVsZW1lbnRzLmNhbGwodGhpcyk7XG4gICAgJGRlc3Ryb3lBZFVuaXQuY2FsbCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gJHJlbW92ZUFkRWxlbWVudHMoKSB7XG4gICAgJHJlbW92ZUVsLmNhbGwodGhpcywgJ19mcmFtZScpO1xuICAgICRkZXN0cm95TG9hZExpc3RlbmVyLmNhbGwodGhpcyk7XG59XG5cbi8qKlxuICogJGRlc3Ryb3lMb2FkTGlzdGVuZXJcbiAqXG4gKi9cbmZ1bmN0aW9uICRkZXN0cm95TG9hZExpc3RlbmVyKCkge1xuICAgIGlmICh0aGlzLl9vbkxvYWQpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vbkxvYWQpO1xuICAgICAgICB1dGlscy5jbGVhckNhbGxiYWNrVGltZW91dCh0aGlzLl9vbkxvYWQpO1xuICAgICAgICBkZWxldGUgdGhpcy5fb25Mb2FkO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiAkZGVzdHJveUFkVW5pdCgpIHtcbiAgICBpZiAodGhpcy5fYWRVbml0KSB7XG4gICAgICAgIHRoaXMuX2FkVW5pdC5zdG9wQWQoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2FkVW5pdDtcbiAgICB9XG59XG5cbi8qKlxuICogJHRocm93SWZEZXN0cm95ZWRcbiAqXG4gKi9cbmZ1bmN0aW9uICR0aHJvd0lmRGVzdHJveWVkKCkge1xuICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yICgnVlBBSURIVE1MNUNsaWVudCBhbHJlYWR5IGRlc3Ryb3llZCEnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldE9yaWdpbigpIHtcbiAgICBpZiggd2luZG93LmxvY2F0aW9uLm9yaWdpbiApIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSArXG4gICAgICAgICAgICAod2luZG93LmxvY2F0aW9uLnBvcnQgPyAnOicgKyB3aW5kb3cubG9jYXRpb24ucG9ydDogJycpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWUEFJREhUTUw1Q2xpZW50O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIFN1YnNjcmliZXIoKSB7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSB7fTtcbn1cblxuU3Vic2NyaWJlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlKGhhbmRsZXIsIGV2ZW50TmFtZSwgY29udGV4dCkge1xuICAgIGlmICghdGhpcy5pc0hhbmRsZXJBdHRhY2hlZChoYW5kbGVyLCBldmVudE5hbWUpKSB7XG4gICAgICAgIHRoaXMuZ2V0KGV2ZW50TmFtZSkucHVzaCh7aGFuZGxlcjogaGFuZGxlciwgY29udGV4dDogY29udGV4dCwgZXZlbnROYW1lOiBldmVudE5hbWV9KTtcbiAgICB9XG59O1xuXG5TdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGhhbmRsZXIsIGV2ZW50TmFtZSkge1xuICAgIHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50TmFtZV0gPSB0aGlzLmdldChldmVudE5hbWUpLmZpbHRlcihmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gaGFuZGxlciAhPT0gc3Vic2NyaWJlci5oYW5kbGVyO1xuICAgIH0pO1xufTtcblxuU3Vic2NyaWJlci5wcm90b3R5cGUudW5zdWJzY3JpYmVBbGwgPSBmdW5jdGlvbiB1bnN1YnNjcmliZUFsbCgpIHtcbiAgICB0aGlzLl9zdWJzY3JpYmVycyA9IHt9O1xufTtcblxuU3Vic2NyaWJlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgc3Vic2NyaWJlcnMgPSB0aGlzLmdldChldmVudE5hbWUpXG4gICAgICAgIC5jb25jYXQodGhpcy5nZXQoJyonKSk7XG5cbiAgICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoYXQuaXNIYW5kbGVyQXR0YWNoZWQoc3Vic2NyaWJlci5oYW5kbGVyLCBzdWJzY3JpYmVyLmV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmhhbmRsZXIuY2FsbChzdWJzY3JpYmVyLmNvbnRleHQsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9KTtcbn07XG5cblN1YnNjcmliZXIucHJvdG90eXBlLnRyaWdnZXJTeW5jID0gZnVuY3Rpb24oZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgdmFyIHN1YnNjcmliZXJzID0gdGhpcy5nZXQoZXZlbnROYW1lKVxuICAgICAgICAuY29uY2F0KHRoaXMuZ2V0KCcqJykpO1xuXG4gICAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBzdWJzY3JpYmVyLmhhbmRsZXIuY2FsbChzdWJzY3JpYmVyLmNvbnRleHQsIGRhdGEpO1xuICAgIH0pO1xufTtcblxuU3Vic2NyaWJlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KGV2ZW50TmFtZSkge1xuICAgIGlmICghdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnROYW1lXSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudE5hbWVdID0gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmVyc1tldmVudE5hbWVdO1xufTtcblxuU3Vic2NyaWJlci5wcm90b3R5cGUuaXNIYW5kbGVyQXR0YWNoZWQgPSBmdW5jdGlvbiBpc0hhbmRsZXJBdHRhY2hlZChoYW5kbGVyLCBldmVudE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoZXZlbnROYW1lKS5zb21lKGZ1bmN0aW9uKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIgPT09IHN1YnNjcmliZXIuaGFuZGxlcjtcbiAgICB9KVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdWJzY3JpYmVyO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogbm9vcCBhIGVtcHR5IGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vKipcbiAqIHZhbGlkYXRlIGlmIGlzIG5vdCB2YWxpZGF0ZSB3aWxsIHJldHVybiBhbiBFcnJvciB3aXRoIHRoZSBtZXNzYWdlXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBpc1ZhbGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZShpc1ZhbGlkLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGlzVmFsaWQgPyBudWxsIDogbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG52YXIgdGltZW91dHMgPSB7fTtcbi8qKlxuICogY2xlYXJDYWxsYmFja1RpbWVvdXRcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIGhhbmRsZXIgdG8gcmVtb3ZlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyQ2FsbGJhY2tUaW1lb3V0KGZ1bmMpIHtcbiAgICB2YXIgdGltZW91dCA9IHRpbWVvdXRzW2Z1bmNdO1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgZGVsZXRlIHRpbWVvdXRzW2Z1bmNdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBjYWxsYmFja1RpbWVvdXQgaWYgdGhlIG9uU3VjY2VzcyBpcyBub3QgY2FsbGVkIGFuZCByZXR1cm5zIHRydWUgaW4gdGhlIHRpbWVsaW1pdCB0aGVuIG9uVGltZW91dCB3aWxsIGJlIGNhbGxlZFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25TdWNjZXNzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvblRpbWVvdXRcbiAqL1xuZnVuY3Rpb24gY2FsbGJhY2tUaW1lb3V0KHRpbWVyLCBvblN1Y2Nlc3MsIG9uVGltZW91dCkge1xuICAgIHZhciBjYWxsYmFjaywgdGltZW91dDtcblxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25TdWNjZXNzID0gbm9vcDtcbiAgICAgICAgZGVsZXRlIHRpbWVvdXRbY2FsbGJhY2tdO1xuICAgICAgICBvblRpbWVvdXQoKTtcbiAgICB9LCB0aW1lcik7XG5cbiAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ETyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50c1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMzItbGVha2luZy1hcmd1bWVudHNcbiAgICAgICAgaWYgKG9uU3VjY2Vzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICBjbGVhckNhbGxiYWNrVGltZW91dChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGltZW91dHNbY2FsbGJhY2tdID0gdGltZW91dDtcblxuICAgIHJldHVybiBjYWxsYmFjaztcbn1cblxuXG4vKipcbiAqIGNyZWF0ZUVsZW1lbnRJbkVsXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRJbkVsKHBhcmVudCwgdGFnTmFtZSwgaWQpIHtcbiAgICB2YXIgbkVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBpZiAoaWQpIG5FbC5pZCA9IGlkO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChuRWwpO1xuICAgIHJldHVybiBuRWw7XG59XG5cbi8qKlxuICogY3JlYXRlSWZyYW1lV2l0aENvbnRlbnRcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSBzaW1wbGUgdGVtcGxhdGUgdXNpbmcge3t2YXJ9fVxuICogQHBhcmFtIHtvYmplY3R9IGRhdGFcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSWZyYW1lV2l0aENvbnRlbnQocGFyZW50LCB0ZW1wbGF0ZSwgZGF0YSkge1xuICAgIHZhciBpZnJhbWUgPSBjcmVhdGVJZnJhbWUocGFyZW50LCBudWxsLCBkYXRhLnpJbmRleCk7XG4gICAgaWYgKCFzZXRJZnJhbWVDb250ZW50KGlmcmFtZSwgc2ltcGxlVGVtcGxhdGUodGVtcGxhdGUsIGRhdGEpKSkgcmV0dXJuO1xuICAgIHJldHVybiBpZnJhbWU7XG59XG5cbi8qKlxuICogY3JlYXRlSWZyYW1lXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlmcmFtZShwYXJlbnQsIHVybCwgekluZGV4KSB7XG4gICAgdmFyIG5FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIG5FbC5zcmMgPSB1cmwgfHwgJ2Fib3V0OmJsYW5rJztcbiAgICBuRWwubWFyZ2luV2lkdGggPSAnMCc7XG4gICAgbkVsLm1hcmdpbkhlaWdodCA9ICcwJztcbiAgICBuRWwuZnJhbWVCb3JkZXIgPSAnMCc7XG4gICAgbkVsLndpZHRoID0gJzEwMCUnO1xuICAgIG5FbC5oZWlnaHQgPSAnMTAwJSc7XG4gICAgc2V0RnVsbFNpemVTdHlsZShuRWwpO1xuXG4gICAgaWYoekluZGV4KXtcbiAgICAgICAgbkVsLnN0eWxlLnpJbmRleCA9IHpJbmRleDtcbiAgICB9XG5cbiAgICBuRWwuc2V0QXR0cmlidXRlKCdTQ1JPTExJTkcnLCdOTycpO1xuICAgIHBhcmVudC5pbm5lckhUTUwgPSAnJztcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobkVsKTtcbiAgICByZXR1cm4gbkVsO1xufVxuXG5mdW5jdGlvbiBzZXRGdWxsU2l6ZVN0eWxlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgZWxlbWVudC5zdHlsZS50b3AgPSAnMCc7XG4gICAgZWxlbWVudC5zdHlsZS5tYXJnaW4gPSAnMHB4JztcbiAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmcgPSAnMHB4JztcbiAgICBlbGVtZW50LnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xufVxuXG4vKipcbiAqIHNpbXBsZVRlbXBsYXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuICovXG5mdW5jdGlvbiBzaW1wbGVUZW1wbGF0ZSh0ZW1wbGF0ZSwgZGF0YSkge1xuICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykgPyBKU09OLnN0cmluZ2lmeShkYXRhW2tleV0pIDogZGF0YVtrZXldO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UobmV3IFJlZ0V4cCgne3snICsga2V5ICsgJ319JywgJ2cnKSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB0ZW1wbGF0ZTtcbn1cblxuLyoqXG4gKiBzZXRJZnJhbWVDb250ZW50XG4gKlxuICogQHBhcmFtIHtIVE1MSWZyYW1lRWxlbWVudH0gaWZyYW1lRWxcbiAqIEBwYXJhbSBjb250ZW50XG4gKi9cbmZ1bmN0aW9uIHNldElmcmFtZUNvbnRlbnQoaWZyYW1lRWwsIGNvbnRlbnQpIHtcbiAgICB2YXIgaWZyYW1lRG9jID0gaWZyYW1lRWwuY29udGVudFdpbmRvdyAmJiBpZnJhbWVFbC5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgIGlmICghaWZyYW1lRG9jKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZnJhbWVEb2Mud3JpdGUoY29udGVudCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3Qgd2l0aCBrZXlzIGZyb20gYW5vdGhlciBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdG9FeHRlbmRcbiAqIEBwYXJhbSB7b2JqZWN0fSBmcm9tU291cmNlXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCh0b0V4dGVuZCwgZnJvbVNvdXJjZSkge1xuICAgIE9iamVjdC5rZXlzKGZyb21Tb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHRvRXh0ZW5kW2tleV0gPSBmcm9tU291cmNlW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvRXh0ZW5kO1xufVxuXG5cbi8qKlxuICogdW5pcXVlIHdpbGwgY3JlYXRlIGEgdW5pcXVlIHN0cmluZyBldmVyeXRpbWUgaXMgY2FsbGVkLCBzZXF1ZW50aWFsbHkgYW5kIHByZWZpeGVkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeFxuICovXG5mdW5jdGlvbiB1bmlxdWUocHJlZml4KSB7XG4gICAgdmFyIGNvdW50ID0gLTE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdfJyArICgrK2NvdW50KTtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBub29wOiBub29wLFxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSxcbiAgICBjbGVhckNhbGxiYWNrVGltZW91dDogY2xlYXJDYWxsYmFja1RpbWVvdXQsXG4gICAgY2FsbGJhY2tUaW1lb3V0OiBjYWxsYmFja1RpbWVvdXQsXG4gICAgY3JlYXRlRWxlbWVudEluRWw6IGNyZWF0ZUVsZW1lbnRJbkVsLFxuICAgIGNyZWF0ZUlmcmFtZVdpdGhDb250ZW50OiBjcmVhdGVJZnJhbWVXaXRoQ29udGVudCxcbiAgICBjcmVhdGVJZnJhbWU6IGNyZWF0ZUlmcmFtZSxcbiAgICBzZXRGdWxsU2l6ZVN0eWxlOiBzZXRGdWxsU2l6ZVN0eWxlLFxuICAgIHNpbXBsZVRlbXBsYXRlOiBzaW1wbGVUZW1wbGF0ZSxcbiAgICBzZXRJZnJhbWVDb250ZW50OiBzZXRJZnJhbWVDb250ZW50LFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIHVuaXF1ZTogdW5pcXVlXG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogSW5uZXIgaGVscGVyIGNsYXNzIHRoYXQgZGVhbHMgd2l0aCB0aGUgbG9naWMgb2YgdGhlIGljb24gcmVuZGVycmluZy5cbiAqXG4gKiBAcGFyYW0gcGxheWVyIHtvYmplY3R9IGluc3RhbmNlIG9mIHRoZSBwbGF5ZXIgdGhhdCB3aWxsIHBsYXkgdGhlIGFkLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBWQVNURXJyb3IgPSByZXF1aXJlKCcuLi92YXN0L1ZBU1RFcnJvcicpO1xuXG52YXIgYXN5bmMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9hc3luYycpO1xudmFyIHBsYXllclV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcGxheWVyVXRpbHMnKTtcbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91dGlsaXR5RnVuY3Rpb25zJyk7XG5cbmZ1bmN0aW9uIEljb25JbnRlZ3JhdG9yKHBsYXllcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSWNvbkludGVncmF0b3IpKSB7XG4gICAgcmV0dXJuIG5ldyBJY29uSW50ZWdyYXRvcihwbGF5ZXIpO1xuICB9XG5cbiAgdGhpcy5wbGF5ZXIgPSBwbGF5ZXI7XG4gIHRoaXMuaWNvbnMgPSBbXTtcbiAgdGhpcy5jb250cm9sQmFyVGltZXIgPSBudWxsO1xuICB0aGlzLmNiSGlkZGVuO1xufVxuXG5JY29uSW50ZWdyYXRvci5wcm90b3R5cGUucmVuZGVySWNvbnMgPSBmdW5jdGlvbiByZW5kZXJJY29ucyhpY29ucywgY2FsbGJhY2spIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IHV0aWxpdGllcy5ub29wO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShpY29ucykgfHwgaWNvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBWQVNURXJyb3IoJ09uIEljb25JbnRlZ3JhdG9yLCBtaXNzaW5nIHJlcXVpcmVkIGljb24gYXJyYXknKSk7XG4gIH1cblxuICBhc3luYy53YXRlcmZhbGwoW1xuICAgIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICBuZXh0KG51bGwsIGljb25zKTtcbiAgICB9LFxuICAgIHRoaXMuX2NyZWF0ZUljb25zLmJpbmQodGhpcyksXG4gICAgdGhpcy5fc2V0dXBFdmVudHMuYmluZCh0aGlzKSxcbiAgICB0aGlzLl9yZW5kZXJJY29ucy5iaW5kKHRoaXMpXG4gIF0sIGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uc2UpIHtcbiAgICBpZiAoZXJyb3IgJiYgcmVzcG9uc2UpIHtcbiAgICAgIHRoYXQuX3RyYWNrRXJyb3IoZXJyb3IsIHJlc3BvbnNlKTtcbiAgICB9XG4gICAgY2FsbGJhY2soZXJyb3IsIHJlc3BvbnNlKTtcbiAgfSk7XG59O1xuXG5JY29uSW50ZWdyYXRvci5wcm90b3R5cGUuX2NyZWF0ZUljb25zID0gZnVuY3Rpb24gY3JlYXRlSWNvbnMoaWNvbnMsIGNhbGxiYWNrKSB7XG4gIC8vdmFyIHBsYXllcldpZHRoID0gZG9tLmdldERpbWVuc2lvbih0aGlzLnBsYXllci5lbCgpKS53aWR0aDtcbiAgLy92YXIgcGxheWVySGVpZ2h0ID0gZG9tLmdldERpbWVuc2lvbih0aGlzLnBsYXllci5lbCgpKS5oZWlnaHQ7XG4gIHZhciB0aGF0ID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGljb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGljb25PYmogPSB7fTtcbiAgICBpY29uT2JqLmljb24gPSBpY29uc1tpXTtcbiAgICAvLyBtYWtlIHN1cmUgd2Ugb25seSBvbmUgaWNvbiBwZXIgcHJvZ3JhbVxuICAgIHZhciBpZHggPSBnZXRJY29uQnlQcm9ncmFtKGljb25PYmouaWNvbi5wcm9ncmFtKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuaWNvbnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuICAgIGljb25PYmouY29udGVudCA9IGdldENvbnRlbnQoaWNvbk9iai5pY29uKTtcbiAgICBpZiAoaWNvbk9iai5jb250ZW50KSB7XG4gICAgICB0aGlzLmljb25zLnB1c2goaWNvbk9iaik7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuaWNvbnMubGVuZ3RoID4gMCkge1xuICAgIGNhbGxiYWNrKG51bGwpO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbGxiYWNrKG5ldyBWQVNURXJyb3IoXCJDb3VsZCBub3QgY3JlYXRlIEFkSWNvbiBjb250ZW50XCIsIDkwMCkpO1xuICB9XG4gIHJldHVybjtcblxuICAvKioqIExvY2FsIEZ1bmN0aW9ucyAqKiovXG4gIGZ1bmN0aW9uIGdldENvbnRlbnQoaWNvbikge1xuICAgIHZhciBjb250ZW50ID0gbnVsbDtcbiAgICBpZiAoaWNvbi5zdGF0aWNSZXNvdXJjZSkge1xuICAgICAgdmFyIGltYWdlVHlwZXMgPSBbXCJpbWFnZS9naWZcIiwgXCJpbWFnZS9qcGVnXCIsIFwiaW1hZ2UvcG5nXCJdO1xuICAgICAgaWYgKGltYWdlVHlwZXMuaW5kZXhPZihpY29uLmNyZWF0aXZlVHlwZSkpIHtcbiAgICAgICAgY29udGVudCA9IFwiPGltZyBzcmM9J1wiICsgaWNvbi5zdGF0aWNSZXNvdXJjZSArIFwiJyB3aWR0aD0nXCIgKyBpY29uLndpZHRoICsgXCInIGhlaWdodD0nXCIgKyBpY29uLmhlaWdodCArIFwiJz5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyplbHNlIGlmIChpY29uLmh0bWxSZXNvdXJjZSkge1xuICAgICAgLy8gdG8gZG8gLi4uXG4gICAgfVxuICAgIGVsc2UgaWYgKGljb24uaWZyYW1lUmVzb3VyY2UpIHtcbiAgICAgIC8vIHRvIGRvIC4uLlxuICAgIH0qL1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SWNvbkJ5UHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0Lmljb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhhdC5pY29uc1tpXS5pY29uLnByb2dyYW0gPT09IHByb2dyYW0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxufTtcblxuSWNvbkludGVncmF0b3IucHJvdG90eXBlLl9zZXR1cEV2ZW50cyA9IGZ1bmN0aW9uIHNldHVwRXZlbnRzKGNhbGxiYWNrKSB7XG4gIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllcjtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gIHBsYXllclV0aWxzLm9uY2UocGxheWVyLCBbJ3Zhc3QuYWRFbmQnLCAndmFzdC5hZHNDYW5jZWwnLCAndmFzdC5hZFNraXAnLCAnYWRTdG9wJ10sIGZ1bmN0aW9uKCl7XG4gICAgaWYgKHRoYXQuaWNvbnMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHRoYXQuY29udHJvbEJhclRpbWVyKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhhdC5jb250cm9sQmFyVGltZXIpO1xuICAgICAgICB0aGF0LmNvbnRyb2xCYXJUaW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXQuaWNvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGljb24gPSB0aGF0Lmljb25zW2ldO1xuICAgICAgICBpZiAoaWNvbi5kaXYpIHtcbiAgICAgICAgICBwbGF5ZXIuZWwoKS5yZW1vdmVDaGlsZChpY29uLmRpdik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoYXQuaWNvbnMgPSBbXTtcbiAgICB9XG4gIH0pO1xuICBcbiAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xufTtcblxuSWNvbkludGVncmF0b3IucHJvdG90eXBlLl9yZW5kZXJJY29ucyA9IGZ1bmN0aW9uIHJlbmRlckljb25zKCkge1xuICB2YXIgcGxheWVyID0gdGhpcy5wbGF5ZXI7XG4gIHZhciB0aGF0ID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaWNvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaWNvbiA9IHRoaXMuaWNvbnNbaV07XG5cbiAgICAvL3Bvc2l0aW9uIGJ5IG9mZnNldFxuICAgIHZhciB4UG9zaXRpb24gPSBcImxlZnRcIjsvL29yIHJpZ2h0XG4gICAgdmFyIHhQb3NpdGlvbk9mZnNldCA9IDA7XG4gICAgdmFyIHlQb3NpdGlvbiA9IFwidG9wXCI7Ly9vciBib3R0b21cbiAgICB2YXIgeVBvc2l0aW9uT2Zmc2V0ID0gMDtcbiAgICB2YXIgdG9wTWFyZ2luID0gMDtcbiAgICB2YXIgYm90dG9tTWFyZ2luID0gMDsgICAvLyBtYXliZSBjb250cm9sIGJhciBoZWlnaHRcblxuICAgIGlmIChpY29uICYmIGljb24uaWNvbi54UG9zaXRpb24gPT09IFwibGVmdFwiKSB7XG4gICAgICAgIHhQb3NpdGlvbiA9IFwibGVmdFwiO1xuICAgICAgICB4UG9zaXRpb25PZmZzZXQgPSAwO1xuICAgIH1cbiAgICBpZiAoaWNvbiAmJiBpY29uLmljb24ueFBvc2l0aW9uID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgeFBvc2l0aW9uID0gXCJyaWdodFwiO1xuICAgICAgICB4UG9zaXRpb25PZmZzZXQgPSAwO1xuICAgIH1cbiAgICBpZiAoaWNvbiAmJiBOdW1iZXIoaWNvbi5pY29uLnhQb3NpdGlvbikgPj0gMCkge1xuICAgICAgICB4UG9zaXRpb24gPSBcImxlZnRcIjtcbiAgICAgICAgeFBvc2l0aW9uT2Zmc2V0ID0gTnVtYmVyKGljb24ueFBvc2l0aW9uKTtcbiAgICB9XG4gICAgaWYgKGljb24gJiYgaWNvbi5pY29uLnlQb3NpdGlvbiA9PT0gXCJib3R0b21cIikge1xuICAgICAgICB5UG9zaXRpb24gPSBcImJvdHRvbVwiO1xuICAgICAgICB5UG9zaXRpb25PZmZzZXQgPSAwO1xuICAgICAgICB5UG9zaXRpb25PZmZzZXQgPSB5UG9zaXRpb25PZmZzZXQgKyBib3R0b21NYXJnaW47XG4gICAgfVxuICAgIGlmIChpY29uICYmIGljb24uaWNvbi55UG9zaXRpb24gPT09IFwidG9wXCIpIHtcbiAgICAgICAgeVBvc2l0aW9uID0gXCJ0b3BcIjtcbiAgICAgICAgeVBvc2l0aW9uT2Zmc2V0ID0gMDtcbiAgICAgICAgeVBvc2l0aW9uT2Zmc2V0ID0geVBvc2l0aW9uT2Zmc2V0ICsgdG9wTWFyZ2luO1xuICAgIH1cbiAgICBpZiAoaWNvbiAmJiBOdW1iZXIoaWNvbi5pY29uLnlQb3NpdGlvbikgPj0gMCkge1xuICAgICAgICB5UG9zaXRpb24gPSBcInRvcFwiO1xuICAgICAgICB5UG9zaXRpb25PZmZzZXQgPSBOdW1iZXIoaWNvbi5pY29uLnlQb3NpdGlvbik7XG4gICAgICAgIHlQb3NpdGlvbk9mZnNldCA9IHlQb3NpdGlvbk9mZnNldCArIHRvcE1hcmdpbjtcbiAgICB9XG5cbiAgICB2YXIgZGlzcGxheUljb24gPSBwbGF5ZXIuZWwoKS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHBsYXllci5lbCgpLmFwcGVuZENoaWxkKGRpc3BsYXlJY29uKTtcblxuICAgIGRpc3BsYXlJY29uLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJhZGljb25cIik7XG4gICAgZGlzcGxheUljb24uaWQgPSBcImFkaWNvbl9cIiArIGljb24uaWNvbi5wcm9ncmFtO1xuICAgIGRpc3BsYXlJY29uLmlubmVySFRNTCA9IGljb24uY29udGVudDtcbiAgICBkaXNwbGF5SWNvbi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXNwbGF5SWNvbi5zdHlsZVt4UG9zaXRpb25dID0geFBvc2l0aW9uT2Zmc2V0ICsgXCJweFwiO1xuICAgIGRpc3BsYXlJY29uLnN0eWxlW3lQb3NpdGlvbl0gPSB5UG9zaXRpb25PZmZzZXQgKyBcInB4XCI7XG4gICAgZGlzcGxheUljb24uc3R5bGUuekluZGV4ID0gMjE0NzQ4MzY0NzsgLy90b3AgbW9zdCBvZiAzMmJpdFxuICAgIGRpc3BsYXlJY29uLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBpY29uLm9yaWdZID0geVBvc2l0aW9uT2Zmc2V0O1xuICBcbiAgICAvL3NldCB3aWR0aCxoZWlnaHQgb2YgZGl2IGVsZW1lbnQgXG4gICAgZGlzcGxheUljb24uc3R5bGUud2lkdGggPSBpY29uLndpZHRoICsgXCJweFwiO1xuICAgIGRpc3BsYXlJY29uLnN0eWxlLmhlaWdodCA9IGljb24uaGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgaWNvbi5kaXYgPSBkaXNwbGF5SWNvbjtcblxuICAgIGlmIChpY29uLmljb24uaWNvbkNsaWNrVGhyb3VnaCkge1xuICAgICAgaWNvbi5kaXYuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gICAgICBpY29uLmRpdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrKGljb24pKTtcbiAgICB9XG5cbiAgICBzdGFydEljb24oaWNvbiwgeVBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmICh0aGlzLmljb25zLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLmNvbnRyb2xCYXJUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbXBTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoYXQucGxheWVyLmNvbnRyb2xCYXIuZWwoKSwgbnVsbCk7XG4gICAgICB2YXIgY2JIaWRkZW5DdXIgPSBjb21wU3R5bGUuYmFja2ZhY2VWaXNpYmlsaXR5ID09PSAnaGlkZGVuJyB8fCBjb21wU3R5bGUudHJhbnNmb3JtICE9ICdub25lJztcbiAgICAgIGlmIChjYkhpZGRlbkN1ciAhPSB0aGF0LmNiSGlkZGVuKSB7XG4gICAgICAgIHRoYXQuY2JIaWRkZW4gPSBjYkhpZGRlbkN1cjtcbiAgICAgICAgdmFyIGNiSGVpZ2h0ID0gY2JIaWRkZW5DdXIgPyAwIDogdGhhdC5wbGF5ZXIuY29udHJvbEJhci5lbCgpLm9mZnNldEhlaWdodDtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGF0Lmljb25zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgdmFyIGljID0gdGhhdC5pY29uc1trXTtcbiAgICAgICAgICBpZiAoaWMuZGl2ICYmIGljLmRpdi5zdHlsZS5kaXNwbGF5ID09PSdibG9jaycpIHtcbiAgICAgICAgICAgIGlmIChjYkhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gY29udHJvbCBiYXIgdmlzaWJsZVxuICAgICAgICAgICAgICBpZiAoZWxlbWVudHNJbnRlcnNlY3RlZChpYy5kaXYsIHRoYXQucGxheWVyLmNvbnRyb2xCYXIuZWwoKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWMuZGl2LnN0eWxlLnRvcCAmJiBpYy5kaXYuc3R5bGUudG9wLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHZhciB5UG9zID0gaWMub3JpZ1kgLSBjYkhlaWdodDtcbiAgICAgICAgICAgICAgICAgIGlmICh5UG9zIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB5UG9zID0gMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGljLmRpdi5zdHlsZS50b3AgPSB5UG9zICsgJ3B4JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpYy5kaXYuc3R5bGUuYm90dG9tID0gKGljLm9yaWdZICsgY2JIZWlnaHQpICsgJ3B4JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRndXN0SWNvbnNQb3NpdGlvbihpYywgY2JIZWlnaHQsIHRoYXQsIDEpOyAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGljLmRpdi5zdHlsZS50b3AgJiYgaWMuZGl2LnN0eWxlLnRvcC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWMuZGl2LnN0eWxlLnRvcCA9IGljLm9yaWdZICsgJ3B4JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpYy5kaXYuc3R5bGUuYm90dG9tID0gKGljLm9yaWdZICsgY2JIZWlnaHQpICsgJ3B4JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHV0aWxpdGllcy5pc0lFMTEoKSA/IDEwMCA6IDUwMCk7XG4gIH1cblxuICAvKioqKiBsb2NhbCBmdW5jdGlvbnMgKioqKioqL1xuICBmdW5jdGlvbiBhZGd1c3RJY29uc1Bvc2l0aW9uKGljLCBjYkhlaWdodCwgdGhhdCwgbGV2ZWwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXQuaWNvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpY29uID0gdGhhdC5pY29uc1tpXTtcbiAgICAgIGlmIChpY29uLmRpdi5zdHlsZS5kaXNwbGF5ID09PSAnYmxvY2snICYmIGljb24uZGl2ICE9IGljLmRpdikge1xuICAgICAgICBpZiAoZWxlbWVudHNJbnRlcnNlY3RlZChpYy5kaXYsIGljb24uZGl2KSkge1xuICAgICAgICAgIGlmIChpY29uLmRpdi5zdHlsZS50b3AgJiYgaWNvbi5kaXYuc3R5bGUudG9wLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciB5UG9zID0gaWNvbi5vcmlnWSAtIGNiSGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHlQb3MgPCAwKSB7XG4gICAgICAgICAgICAgIHlQb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWNvbi5kaXYuc3R5bGUudG9wID0geVBvcyArICdweCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWNvbi5kaXYuc3R5bGUuYm90dG9tID0gKGljb24ub3JpZ1kgKyBjYkhlaWdodCkgKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBwcm90ZWN0aW9uIGFnYWluc3QgaW5maW5pdGUgcmVjdXJzaXZlXG4gICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICBpZiAobGV2ZWwgPCA1KSB7XG4gICAgICAgICAgICBhZGd1c3RJY29uc1Bvc2l0aW9uKGljb24sIGNiSGVpZ2h0LCB0aGF0LCBsZXZlbCk7ICAgIFxuICAgICAgICAgIH0gICAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZWxlbWVudHNJbnRlcnNlY3RlZChkaXYxLCBkaXYyKSB7XG4gICAgdmFyIGNvbGxpZGUgPSBmdW5jdGlvbihlbDEsIGVsMikge1xuICAgICAgdmFyIHJlY3QxID0gZWwxLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHJlY3QyID0gZWwyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBcbiAgICAgIHJldHVybiAhKFxuICAgICAgICByZWN0MS50b3AgPiByZWN0Mi5ib3R0b20gfHxcbiAgICAgICAgcmVjdDEucmlnaHQgPCByZWN0Mi5sZWZ0IHx8XG4gICAgICAgIHJlY3QxLmJvdHRvbSA8IHJlY3QyLnRvcCB8fFxuICAgICAgICByZWN0MS5sZWZ0ID4gcmVjdDIucmlnaHRcbiAgICAgICk7XG4gICAgfTtcbiAgICB2YXIgaW5zaWRlID0gZnVuY3Rpb24oZWwxLCBlbDIpIHtcbiAgICAgIHZhciByZWN0MSA9IGVsMS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciByZWN0MiA9IGVsMi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgXG4gICAgICByZXR1cm4gKFxuICAgICAgICAoKHJlY3QyLnRvcCA8PSByZWN0MS50b3ApICYmIChyZWN0MS50b3AgPD0gcmVjdDIuYm90dG9tKSkgJiZcbiAgICAgICAgKChyZWN0Mi50b3AgPD0gcmVjdDEuYm90dG9tKSAmJiAocmVjdDEuYm90dG9tIDw9IHJlY3QyLmJvdHRvbSkpICYmXG4gICAgICAgICgocmVjdDIubGVmdCA8PSByZWN0MS5sZWZ0KSAmJiAocmVjdDEubGVmdCA8PSByZWN0Mi5yaWdodCkpICYmXG4gICAgICAgICgocmVjdDIubGVmdCA8PSByZWN0MS5yaWdodCkgJiYgKHJlY3QxLnJpZ2h0IDw9IHJlY3QyLnJpZ2h0KSlcbiAgICAgICk7XG4gICAgfTtcbiAgICByZXR1cm4gY29sbGlkZShkaXYxLCBkaXYyKSB8fCBpbnNpZGUoZGl2MSwgZGl2MikgfHwgaW5zaWRlKGRpdjIsIGRpdjEpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhY2tVcmxzKHVybHMpIHtcbiAgICB1cmxzLmZvckVhY2goZnVuY3Rpb24gKHNyYykge1xuICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1nLnNyYyA9IHNyYztcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGljb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpY29uLmRpdi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrKGljb24pKTtcbiAgICAgIHRyYWNrVXJscyhpY29uLmljb24uaWNvbkNsaWNrVHJhY2tpbmdzKTtcbiAgICAgIHBsYXllci5wYXVzZSgpO1xuICAgICAgd2luZG93Lm9wZW4oaWNvbi5pY29uLmljb25DbGlja1Rocm91Z2gsICdfYmxhbmsnKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRJY29uKGljb24sIHlQb3NpdGlvbikge1xuICAgIHZhciBvZmZzZXQgPSBpY29uLmljb24ub2Zmc2V0ICYmIGljb24uaWNvbi5vZmZzZXQgPiAwID8gaWNvbi5pY29uLm9mZnNldCA6IDA7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGljb24uZGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgdHJhY2tVcmxzKGljb24uaWNvbi5pY29uVmlld1RyYWNraW5ncyk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5pY29ucy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAodGhhdC5pY29uc1tqXS5kaXYgJiYgdGhhdC5pY29uc1tqXS5kaXYgIT0gaWNvbi5kaXYpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudHNJbnRlcnNlY3RlZCh0aGF0Lmljb25zW2pdLmRpdiwgaWNvbi5kaXYpKSB7XG4gICAgICAgICAgICB2YXIgcmVjdDEgPSB0aGF0Lmljb25zW2pdLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGlmICh5UG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgIGljb24uZGl2LnN0eWxlLnRvcCA9ICh0aGF0Lmljb25zW2pdLmRpdi5vZmZzZXRUb3AgKyB0aGF0Lmljb25zW2pdLmRpdi5vZmZzZXRIZWlnaHQgKyAxKSArIFwicHhcIjtcbiAgICAgICAgICAgICAgaWNvbi5vcmlnWSA9IHRoYXQuaWNvbnNbal0uZGl2Lm9mZnNldFRvcCArIHRoYXQuaWNvbnNbal0uZGl2Lm9mZnNldEhlaWdodCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJlY3QyID0gdGhhdC5wbGF5ZXIuZWwoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgaWNvbi5kaXYuc3R5bGUuYm90dG9tID0gKHJlY3QyLmhlaWdodCArIHJlY3QyLnRvcCAtIHJlY3QxLnRvcCArIDEpICsgXCJweFwiO1xuICAgICAgICAgICAgICBpY29uLm9yaWdZID0gcmVjdDIuaGVpZ2h0ICsgcmVjdDIudG9wIC0gcmVjdDEudG9wICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgXG4gICAgICBpZiAoaWNvbi5pY29uLmR1cmF0aW9uICYmIGljb24uaWNvbi5kdXJhdGlvbiA+IDApIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaWNvbi5pY29uLmR1cmF0aW9uO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpZHggPSB0aGF0Lmljb25zLmluZGV4T2YoaWNvbik7XG4gICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICBwbGF5ZXIuZWwoKS5yZW1vdmVDaGlsZChpY29uLmRpdik7XG4gICAgICAgICAgICB0aGF0Lmljb25zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH0sIG9mZnNldCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSWNvbkludGVncmF0b3I7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgSW5MaW5lID0gcmVxdWlyZSgnLi9JbkxpbmUnKTtcbnZhciBXcmFwcGVyID0gcmVxdWlyZSgnLi9XcmFwcGVyJyk7XG5cbmZ1bmN0aW9uIEFkKGFkSlRyZWUpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFkKSkge1xuICAgIHJldHVybiBuZXcgQWQoYWRKVHJlZSk7XG4gIH1cbiAgdGhpcy5pbml0aWFsaXplKGFkSlRyZWUpO1xufVxuXG5BZC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGFkSlRyZWUpIHtcbiAgdGhpcy5pZCA9IGFkSlRyZWUuYXR0cignaWQnKTtcbiAgdGhpcy5zZXF1ZW5jZSA9IGFkSlRyZWUuYXR0cignc2VxdWVuY2UnKTtcbiAgaWYgKHdpbmRvdy5tb2xfdmFzdFZlcnNpb24gPT09IDQpIHtcblx0ICB0aGlzLmNvbmRpdGlvbmFsQWQgPSBhZEpUcmVlLmF0dHIoJ2NvbmRpdGlvbmFsQWQnKTtcbiAgfVxuXG4gIGlmKGFkSlRyZWUuaW5MaW5lKSB7XG4gICAgdGhpcy5pbkxpbmUgPSBuZXcgSW5MaW5lKGFkSlRyZWUuaW5MaW5lKTtcbiAgfVxuXG4gIGlmKGFkSlRyZWUud3JhcHBlcil7XG4gICAgdGhpcy53cmFwcGVyID0gbmV3IFdyYXBwZXIoYWRKVHJlZS53cmFwcGVyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZDsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB4bWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy94bWwnKTtcbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91dGlsaXR5RnVuY3Rpb25zJyk7XG5cbmZ1bmN0aW9uIENhdGVnb3J5KGNhdGVnb3J5SlRyZWUpIHtcblx0ICBpZighKHRoaXMgaW5zdGFuY2VvZiBDYXRlZ29yeSkpIHtcblx0ICAgIHJldHVybiBuZXcgQ2F0ZWdvcnkoY2F0ZWdvcnlKVHJlZSk7XG5cdCAgfVxuXG5cdCAgdGhpcy5hdXRob3JpdHkgPSBjYXRlZ29yeUpUcmVlLmF0dHIoJ2F1dGhvcml0eScpO1xuXHQgIHRoaXMuY2F0ZWdvcnkgPSB4bWwua2V5VmFsdWUoY2F0ZWdvcnlKVHJlZSk7XG59XG5cbkNhdGVnb3J5LnBhcnNlQ2F0ZWdvcmllcyA9IGZ1bmN0aW9uIHBhcnNlQ2F0ZWdvdGllcyhjYXRlZ29yaWVzSlRyZWUpIHtcblx0ICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuXHQgIHZhciBjYXRlZ29yaWVzRGF0YTtcblx0ICBpZiAoY2F0ZWdvcmllcykge1xuXHRcdCAgY2F0ZWdvcmllc0RhdGEgPSB1dGlsaXRpZXMuaXNBcnJheShjYXRlZ29yaWVzSlRyZWUpID8gY2F0ZWdvcmllc0pUcmVlIDogW2NhdGVnb3JpZXNKVHJlZV07XG5cdFx0ICBjYXRlZ29yaWVzRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuXHRcdFx0ICB2YXIgY2F0ID0gbmV3IENhdGVnb3J5KGNhdGVnb3J5KTtcblx0XHRcdCAgaWYgKGNhdC5jYXRlZ29yeSAmJiBjYXQuY2F0ZWdvcnkubGVuZ3RoID4gMCAmJiBjYXQuYXV0aG9yaXR5ICYmIGNhdC5hdXRob3JpdHkubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQgIGNhdGVnb3JpZXMucHVzaChuZXcgQ2F0ZWdvcnkoY2F0ZWdvcnkpKTtcblx0XHRcdCAgfVxuXHRcdCAgfSk7XG5cdCAgfVxuXHQgIHJldHVybiBjYXRlZ29yaWVzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYXRlZ29yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRyYWNraW5nRXZlbnQgPSByZXF1aXJlKCcuL1RyYWNraW5nRXZlbnQnKTtcblxudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3V0aWxpdHlGdW5jdGlvbnMnKTtcblxudmFyIHhtbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3htbCcpO1xuXG52YXIgbG9nZ2VyID0gcmVxdWlyZSAoJy4uLy4uL3V0aWxzL2NvbnNvbGVMb2dnZXInKTtcblxuXG5mdW5jdGlvbiBDb21wYW5pb24oY29tcGFuaW9uSlRyZWUpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbXBhbmlvbikpIHtcbiAgICByZXR1cm4gbmV3IENvbXBhbmlvbihjb21wYW5pb25KVHJlZSk7XG4gIH1cblxuICBsb2dnZXIuaW5mbyAoXCI8Q29tcGFuaW9uPiBmb3VuZCBjb21wYW5pb24gYWRcIik7XG4gIGxvZ2dlci5kZWJ1ZyAoXCI8Q29tcGFuaW9uPiAgY29tcGFuaW9uSlRyZWU6XCIsIGNvbXBhbmlvbkpUcmVlKTtcblxuICAvL1JlcXVpcmVkIEVsZW1lbnRzXG4gIHRoaXMuY3JlYXRpdmVUeXBlID0geG1sLmF0dHIoY29tcGFuaW9uSlRyZWUuc3RhdGljUmVzb3VyY2UsICdjcmVhdGl2ZVR5cGUnKTtcbiAgdGhpcy5zdGF0aWNSZXNvdXJjZSA9IHhtbC5rZXlWYWx1ZShjb21wYW5pb25KVHJlZS5zdGF0aWNSZXNvdXJjZSk7XG5cbiAgbG9nZ2VyLmluZm8gKFwiPENvbXBhbmlvbj4gIGNyZWF0aXZlVHlwZTogXCIgKyB0aGlzLmNyZWF0aXZlVHlwZSk7XG4gIGxvZ2dlci5pbmZvIChcIjxDb21wYW5pb24+ICBzdGF0aWNSZXNvdXJjZTogXCIgKyB0aGlzLnN0YXRpY1Jlc291cmNlKTtcblxuICAvLyBXZWlyZCBidWcgd2hlbiB0aGUgSlhPTiB0cmVlIGlzIGJ1aWx0IGl0IGRvZXNuJ3QgaGFuZGxlIGNhc2luZyBwcm9wZXJseSBpbiB0aGlzIHNpdHVhdGlvbi4uLlxuICB2YXIgaHRtbFJlc291cmNlID0gbnVsbDtcbiAgaWYgKHhtbC5rZXlWYWx1ZShjb21wYW5pb25KVHJlZS5IVE1MUmVzb3VyY2UpKSB7XG4gICAgaHRtbFJlc291cmNlID0geG1sLmtleVZhbHVlKGNvbXBhbmlvbkpUcmVlLkhUTUxSZXNvdXJjZSk7XG4gIH0gZWxzZSBpZiAoeG1sLmtleVZhbHVlKGNvbXBhbmlvbkpUcmVlLmhUTUxSZXNvdXJjZSkpIHtcbiAgICBodG1sUmVzb3VyY2UgPSB4bWwua2V5VmFsdWUoY29tcGFuaW9uSlRyZWUuaFRNTFJlc291cmNlKTtcbiAgfVxuXG4gIGlmIChodG1sUmVzb3VyY2UgIT09IG51bGwpXG4gIHtcbiAgICBsb2dnZXIuaW5mbyAoXCI8Q29tcGFuaW9uPiBmb3VuZCBodG1sIHJlc291cmNlXCIsIGh0bWxSZXNvdXJjZSk7XG4gIH1cblxuICB0aGlzLmh0bWxSZXNvdXJjZSA9IGh0bWxSZXNvdXJjZTtcblxuICB2YXIgaWZyYW1lUmVzb3VyY2UgPSBudWxsO1xuICBpZiAoeG1sLmtleVZhbHVlKGNvbXBhbmlvbkpUcmVlLklGcmFtZVJlc291cmNlKSkge1xuICAgIGlmcmFtZVJlc291cmNlID0geG1sLmtleVZhbHVlKGNvbXBhbmlvbkpUcmVlLklGcmFtZVJlc291cmNlKTtcbiAgfSBlbHNlIGlmICh4bWwua2V5VmFsdWUoY29tcGFuaW9uSlRyZWUuaUZyYW1lcmVzb3VyY2UpKSB7XG4gICAgaWZyYW1lUmVzb3VyY2UgPSB4bWwua2V5VmFsdWUoY29tcGFuaW9uSlRyZWUuaUZyYW1lcmVzb3VyY2UpO1xuICB9XG5cbiAgaWYgKGlmcmFtZVJlc291cmNlICE9PSBudWxsKVxuICB7XG4gICAgbG9nZ2VyLmluZm8gKFwiPENvbXBhbmlvbj4gZm91bmQgaWZyYW1lIHJlc291cmNlXCIsIGlmcmFtZVJlc291cmNlKTtcbiAgfVxuXG4gIHRoaXMuaWZyYW1lUmVzb3VyY2UgPSBpZnJhbWVSZXNvdXJjZTtcblxuICAvL09wdGlvbmFsIGZpZWxkc1xuICB0aGlzLmlkID0geG1sLmF0dHIoY29tcGFuaW9uSlRyZWUsICdpZCcpO1xuICB0aGlzLndpZHRoID0geG1sLmF0dHIoY29tcGFuaW9uSlRyZWUsICd3aWR0aCcpO1xuICB0aGlzLmhlaWdodCA9IHhtbC5hdHRyKGNvbXBhbmlvbkpUcmVlLCAnaGVpZ2h0Jyk7XG4gIHRoaXMuYXNzZXRXaWR0aCA9IHhtbC5hdHRyKGNvbXBhbmlvbkpUcmVlLCAnYXNzZXRXaWR0aCcpO1xuICB0aGlzLmFzc2V0SGVpZ2h0ID0geG1sLmF0dHIoY29tcGFuaW9uSlRyZWUsICdhc3NldEhlaWdodCcpO1xuICB0aGlzLmV4cGFuZGVkV2lkdGggPSB4bWwuYXR0cihjb21wYW5pb25KVHJlZSwgJ2V4cGFuZGVkV2lkdGgnKTtcbiAgdGhpcy5leHBhbmRlZEhlaWdodCA9IHhtbC5hdHRyKGNvbXBhbmlvbkpUcmVlLCAnZXhwYW5kZWRIZWlnaHQnKTtcbiAgdGhpcy5hcGlGcmFtZXdvcmsgPSB4bWwuYXR0cihjb21wYW5pb25KVHJlZSwgJ2FwaUZyYW1ld29yaycpO1xuICB0aGlzLmFkU2xvdElEID0geG1sLmF0dHIoY29tcGFuaW9uSlRyZWUsICdhZFNsb3RJRCcpO1xuICB0aGlzLmNvbXBhbmlvbkNsaWNrVGhyb3VnaCA9IHhtbC5rZXlWYWx1ZShjb21wYW5pb25KVHJlZS5jb21wYW5pb25DbGlja1Rocm91Z2gpO1xuICB0aGlzLnRyYWNraW5nRXZlbnRzID0gcGFyc2VUcmFja2luZ0V2ZW50cyhjb21wYW5pb25KVHJlZS50cmFja2luZ0V2ZW50cyAmJiBjb21wYW5pb25KVHJlZS50cmFja2luZ0V2ZW50cy50cmFja2luZyk7XG4gIFxuICBpZiAod2luZG93Lm1vbF92YXN0VmVyc2lvbiA9PT0gNCkge1xuXHQgIHRoaXMucHhyYXRpbyA9IHhtbC5hdHRyKGNvbXBhbmlvbkpUcmVlLCAncHhyYXRpbycpO1xuICB9XG5cbiAgbG9nZ2VyLmluZm8gKFwiPENvbXBhbmlvbj4gIGNvbXBhbmlvbkNsaWNrVGhyb3VnaDogXCIgKyB0aGlzLmNvbXBhbmlvbkNsaWNrVGhyb3VnaCk7XG5cblxuICAvKioqIExvY2FsIGZ1bmN0aW9ucyAqKiovXG4gIGZ1bmN0aW9uIHBhcnNlVHJhY2tpbmdFdmVudHModHJhY2tpbmdFdmVudHMpIHtcbiAgICB2YXIgdHJhY2tpbmdzID0gW107XG4gICAgaWYgKHV0aWxpdGllcy5pc0RlZmluZWQodHJhY2tpbmdFdmVudHMpKSB7XG4gICAgICB0cmFja2luZ0V2ZW50cyA9IHV0aWxpdGllcy5pc0FycmF5KHRyYWNraW5nRXZlbnRzKSA/IHRyYWNraW5nRXZlbnRzIDogW3RyYWNraW5nRXZlbnRzXTtcbiAgICAgIHRyYWNraW5nRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNraW5nRGF0YSkge1xuICAgICAgICB0cmFja2luZ3MucHVzaChuZXcgVHJhY2tpbmdFdmVudCh0cmFja2luZ0RhdGEpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJhY2tpbmdzO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcGFuaW9uOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIExpbmVhciA9IHJlcXVpcmUoJy4vTGluZWFyJyk7XG52YXIgQ29tcGFuaW9uID0gcmVxdWlyZSgnLi9Db21wYW5pb24nKTtcbnZhciBVbml2ZXJzYWxBZElkID0gcmVxdWlyZSgnLi9Vbml2ZXJzYWxBZElkJyk7XG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXRpbGl0eUZ1bmN0aW9ucycpO1xuXG5mdW5jdGlvbiBDcmVhdGl2ZShjcmVhdGl2ZUpUcmVlKSB7XG4gIGlmKCEodGhpcyBpbnN0YW5jZW9mIENyZWF0aXZlKSkge1xuICAgIHJldHVybiBuZXcgQ3JlYXRpdmUoY3JlYXRpdmVKVHJlZSk7XG4gIH1cblxuICB0aGlzLmlkID0gY3JlYXRpdmVKVHJlZS5hdHRyKCdpZCcpO1xuICB0aGlzLnNlcXVlbmNlID0gY3JlYXRpdmVKVHJlZS5hdHRyKCdzZXF1ZW5jZScpO1xuICB0aGlzLmFkSWQgPSBjcmVhdGl2ZUpUcmVlLmF0dHIoJ2FkSWQnKTtcbiAgdGhpcy5hcGlGcmFtZXdvcmsgPSBjcmVhdGl2ZUpUcmVlLmF0dHIoJ2FwaUZyYW1ld29yaycpO1xuXG4gIGlmKGNyZWF0aXZlSlRyZWUubGluZWFyKSB7XG4gICAgdGhpcy5saW5lYXIgPSBuZXcgTGluZWFyKGNyZWF0aXZlSlRyZWUubGluZWFyKTtcbiAgfVxuXG4gIGlmIChjcmVhdGl2ZUpUcmVlLmNvbXBhbmlvbkFkcykge1xuICAgIHZhciBjb21wYW5pb25zID0gW107XG4gICAgdmFyIGNvbXBhbmlvbkFkcyA9IGNyZWF0aXZlSlRyZWUuY29tcGFuaW9uQWRzICYmIGNyZWF0aXZlSlRyZWUuY29tcGFuaW9uQWRzLmNvbXBhbmlvbjtcbiAgICBpZiAodXRpbGl0aWVzLmlzRGVmaW5lZChjb21wYW5pb25BZHMpKSB7XG4gICAgICBjb21wYW5pb25BZHMgPSB1dGlsaXRpZXMuaXNBcnJheShjb21wYW5pb25BZHMpID8gY29tcGFuaW9uQWRzIDogW2NvbXBhbmlvbkFkc107XG4gICAgICBjb21wYW5pb25BZHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcGFuaW9uRGF0YSkge1xuICAgICAgICBjb21wYW5pb25zLnB1c2gobmV3IENvbXBhbmlvbihjb21wYW5pb25EYXRhKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5jb21wYW5pb25BZHMgPSBjb21wYW5pb25zO1xuICB9XG5cbiAgaWYgKHdpbmRvdy5tb2xfdmFzdFZlcnNpb24gPT09IDQpIHtcblx0ICB0aGlzLnVuaXZlcnNhbEFkSWQgPSBuZXcgVW5pdmVyc2FsQWRJZChjcmVhdGl2ZUpUcmVlLnVuaXZlcnNhbEFkSWQpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIGF0IHRoZSBjcmVhdGl2ZS5cbiAqL1xuQ3JlYXRpdmUucHJvdG90eXBlLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24oKXtcbiAgaWYodGhpcy5saW5lYXIpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lYXIuaXNTdXBwb3J0ZWQoKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuQ3JlYXRpdmUucGFyc2VDcmVhdGl2ZXMgPSBmdW5jdGlvbiBwYXJzZUNyZWF0aXZlcyhjcmVhdGl2ZXNKVHJlZSkge1xuICB2YXIgY3JlYXRpdmVzID0gW107XG4gIHZhciBjcmVhdGl2ZXNEYXRhO1xuICBpZiAodXRpbGl0aWVzLmlzRGVmaW5lZChjcmVhdGl2ZXNKVHJlZSkgJiYgdXRpbGl0aWVzLmlzRGVmaW5lZChjcmVhdGl2ZXNKVHJlZS5jcmVhdGl2ZSkpIHtcbiAgICBjcmVhdGl2ZXNEYXRhID0gdXRpbGl0aWVzLmlzQXJyYXkoY3JlYXRpdmVzSlRyZWUuY3JlYXRpdmUpID8gY3JlYXRpdmVzSlRyZWUuY3JlYXRpdmUgOiBbY3JlYXRpdmVzSlRyZWUuY3JlYXRpdmVdO1xuICAgIGNyZWF0aXZlc0RhdGEuZm9yRWFjaChmdW5jdGlvbiAoY3JlYXRpdmUpIHtcbiAgICAgIGNyZWF0aXZlcy5wdXNoKG5ldyBDcmVhdGl2ZShjcmVhdGl2ZSkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGl2ZXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0aXZlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXRpbGl0eUZ1bmN0aW9ucycpO1xudmFyIHhtbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3htbCcpO1xudmFyIHBhcnNlcnMgPSByZXF1aXJlKCcuL3BhcnNlcnMnKTtcblxuLy92YXIgdmFzdFV0aWwgPSByZXF1aXJlKCcuL3Zhc3RVdGlsJyk7XG5cbnZhciBhdHRyaWJ1dGVzTGlzdCA9IFtcbiAgJ3Byb2dyYW0nLFxuICAnd2lkdGgnLFxuICAnaGVpZ2h0JyxcbiAgJ3hQb3NpdGlvbicsXG4gICd5UG9zaXRpb24nLFxuICAnZHVyYXRpb24nLFxuICAnb2Zmc2V0JyxcbiAgJ2FwaUZyYW1ld29yaycsXG4gICdweHJhdGlvJ1xuXTtcblxuZnVuY3Rpb24gSWNvbihpY29uSlRyZWUpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEljb24pKSB7XG4gICAgcmV0dXJuIG5ldyBJY29uKGljb25KVHJlZSk7XG4gIH1cblxuICAvL0F0dHJpYnV0ZXNcbiAgZm9yKHZhciB4PTA7IHg8YXR0cmlidXRlc0xpc3QubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc0xpc3RbeF07XG4gICAgdGhpc1thdHRyaWJ1dGVdID0gaWNvbkpUcmVlLmF0dHIoYXR0cmlidXRlKTtcbiAgfVxuICBpZiAodGhpcy5kdXJhdGlvbikge1xuICAgIHRoaXMuZHVyYXRpb24gPSBwYXJzZXJzLmR1cmF0aW9uKHRoaXMuZHVyYXRpb24pO1xuICB9XG4gIGlmICh0aGlzLm9mZnNldCkge1xuICAgIHRoaXMub2Zmc2V0ID0gcGFyc2Vycy5kdXJhdGlvbih0aGlzLm9mZnNldCk7XG4gIH1cblxuICAvL1JlcXVpcmVkIEVsZW1lbnRzXG4gIHRoaXMuY3JlYXRpdmVUeXBlID0geG1sLmF0dHIoaWNvbkpUcmVlLnN0YXRpY1Jlc291cmNlLCAnY3JlYXRpdmVUeXBlJyk7XG4gIHRoaXMuc3RhdGljUmVzb3VyY2UgPSB4bWwua2V5VmFsdWUoaWNvbkpUcmVlLnN0YXRpY1Jlc291cmNlKTtcblxuICB2YXIgaHRtbFJlc291cmNlID0gbnVsbDtcbiAgaWYgKHhtbC5rZXlWYWx1ZShpY29uSlRyZWUuSFRNTFJlc291cmNlKSkge1xuICAgIGh0bWxSZXNvdXJjZSA9IHhtbC5rZXlWYWx1ZShpY29uSlRyZWUuSFRNTFJlc291cmNlKTtcbiAgfSBlbHNlIGlmICh4bWwua2V5VmFsdWUoaWNvbkpUcmVlLmhUTUxSZXNvdXJjZSkpIHtcbiAgICBodG1sUmVzb3VyY2UgPSB4bWwua2V5VmFsdWUoaWNvbkpUcmVlLmhUTUxSZXNvdXJjZSk7XG4gIH1cblxuICB0aGlzLmh0bWxSZXNvdXJjZSA9IGh0bWxSZXNvdXJjZTtcblxuICB2YXIgaWZyYW1lUmVzb3VyY2UgPSBudWxsO1xuICBpZiAoeG1sLmtleVZhbHVlKGljb25KVHJlZS5JRnJhbWVSZXNvdXJjZSkpIHtcbiAgICBpZnJhbWVSZXNvdXJjZSA9IHhtbC5rZXlWYWx1ZShpY29uSlRyZWUuSUZyYW1lUmVzb3VyY2UpO1xuICB9IGVsc2UgaWYgKHhtbC5rZXlWYWx1ZShpY29uSlRyZWUuaUZyYW1lcmVzb3VyY2UpKSB7XG4gICAgaWZyYW1lUmVzb3VyY2UgPSB4bWwua2V5VmFsdWUoaWNvbkpUcmVlLmlGcmFtZXJlc291cmNlKTtcbiAgfVxuXG4gIHRoaXMuaWZyYW1lUmVzb3VyY2UgPSBpZnJhbWVSZXNvdXJjZTtcblxuICB0aGlzLmljb25WaWV3VHJhY2tpbmdzID0gcGFyc2VUcmFja2luZ3MoaWNvbkpUcmVlLmljb25WaWV3VHJhY2tpbmcpO1xuXG4gIGlmIChpY29uSlRyZWUuaWNvbkNsaWNrcykge1xuICAgIHRoaXMuaWNvbkNsaWNrVGhyb3VnaCA9IHhtbC5rZXlWYWx1ZShpY29uSlRyZWUuaWNvbkNsaWNrcy5pY29uQ2xpY2tUaHJvdWdoKTtcbiAgICB0aGlzLmljb25DbGlja1RyYWNraW5ncyA9IHBhcnNlVHJhY2tpbmdzKGljb25KVHJlZS5pY29uQ2xpY2tzLmljb25DbGlja1RyYWNraW5nKTtcbiAgfVxuXG4gIC8vIExvY2FsIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBwYXJzZVRyYWNraW5ncyh0cmFja2luZ3MpIHtcbiAgICBpZiAodHJhY2tpbmdzKSB7XG4gICAgICB0cmFja2luZ3MgPSB1dGlsaXRpZXMuaXNBcnJheSh0cmFja2luZ3MpID8gdHJhY2tpbmdzIDogW3RyYWNraW5nc107XG4gICAgICByZXR1cm4gdXRpbGl0aWVzLnRyYW5zZm9ybUFycmF5KHRyYWNraW5ncywgZnVuY3Rpb24gKHRyYWNraW5ncykge1xuICAgICAgICBpZiAodXRpbGl0aWVzLmlzTm90RW1wdHlTdHJpbmcodHJhY2tpbmdzLmtleVZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cmFja2luZ3Mua2V5VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJY29uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmFzdFV0aWwgPSByZXF1aXJlKCcuL3Zhc3RVdGlsJyk7XG52YXIgQ3JlYXRpdmUgPSByZXF1aXJlKCcuL0NyZWF0aXZlJyk7XG52YXIgQ2F0ZWdvcnkgPSByZXF1aXJlKCcuL0NhdGVnb3J5Jyk7XG52YXIgVmlld2FibGVJbXByZXNzaW9uID0gcmVxdWlyZSgnLi9WaWV3YWJsZUltcHJlc3Npb24nKTtcbnZhciBWZXJpZmljYXRpb24gPSByZXF1aXJlKCcuL1ZlcmlmaWNhdGlvbicpO1xuXG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXRpbGl0eUZ1bmN0aW9ucycpO1xudmFyIHhtbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3htbCcpO1xuXG5mdW5jdGlvbiBJbkxpbmUoaW5saW5lSlRyZWUpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluTGluZSkpIHtcbiAgICByZXR1cm4gbmV3IEluTGluZShpbmxpbmVKVHJlZSk7XG4gIH1cblxuICAvL1JlcXVpcmVkIEZpZWxkc1xuICB0aGlzLmFkVGl0bGUgPSB4bWwua2V5VmFsdWUoaW5saW5lSlRyZWUuYWRUaXRsZSk7XG4gIHRoaXMuYWRTeXN0ZW0gPSB4bWwua2V5VmFsdWUoaW5saW5lSlRyZWUuYWRTeXN0ZW0pO1xuICB0aGlzLmltcHJlc3Npb25zID0gdmFzdFV0aWwucGFyc2VJbXByZXNzaW9ucyhpbmxpbmVKVHJlZS5pbXByZXNzaW9uKTtcbiAgdGhpcy5jcmVhdGl2ZXMgPSBDcmVhdGl2ZS5wYXJzZUNyZWF0aXZlcyhpbmxpbmVKVHJlZS5jcmVhdGl2ZXMpO1xuXG4gIC8vT3B0aW9uYWwgRmllbGRzXG4gIHRoaXMuZGVzY3JpcHRpb24gPSB4bWwua2V5VmFsdWUoaW5saW5lSlRyZWUuZGVzY3JpcHRpb24pO1xuICB0aGlzLmFkdmVydGlzZXIgPSB4bWwua2V5VmFsdWUoaW5saW5lSlRyZWUuYWR2ZXJ0aXNlcik7XG4gIHRoaXMuc3VydmV5cyA9IHBhcnNlU3VydmV5cyhpbmxpbmVKVHJlZS5zdXJ2ZXkpO1xuICAvL3RoaXMuZXJyb3IgPSB4bWwua2V5VmFsdWUoaW5saW5lSlRyZWUuZXJyb3IpO1xuICB0aGlzLmVycm9ycyA9IHZhc3RVdGlsLnBhcnNlRXJyb3JzKGlubGluZUpUcmVlLmVycm9yKTtcbiAgdGhpcy5wcmljaW5nID0geG1sLmtleVZhbHVlKGlubGluZUpUcmVlLnByaWNpbmcpO1xuICB0aGlzLmV4dGVuc2lvbnMgPSBpbmxpbmVKVHJlZS5leHRlbnNpb25zO1xuICBpZiAodGhpcy5leHRlbnNpb25zKSB7XG5cdCAgdGhpcy5tb2F0ID0gcGFyc2VNb2F0KHRoaXMuZXh0ZW5zaW9ucyk7XG4gIH1cbiAgaWYgKHdpbmRvdy5tb2xfdmFzdFZlcnNpb24gPT09IDQpIHtcblx0ICBpZiAoaW5saW5lSlRyZWUuY2F0ZWdvcnkpIHtcblx0XHQgIHRoaXMuY2F0ZWdvcmllcyA9IENhdGVnb3J5LnBhcnNlQ2F0ZWdvcmllcyhpbmxpbmVKVHJlZS5jYXRlZ29yeSk7XG5cdCAgfVxuXHQgIGlmIChpbmxpbmVKVHJlZS52aWV3YWJsZUltcHJlc3Npb24pIHtcblx0XHQgIHRoaXMudmlld2FibGVJbXByZXNzaW9uID0gbmV3IFZpZXdhYmxlSW1wcmVzc2lvbihpbmxpbmVKVHJlZS52aWV3YWJsZUltcHJlc3Npb24pO1xuXHQgIH1cblx0ICBpZiAoaW5saW5lSlRyZWUuYWRWZXJpZmljYXRpb25zKSB7XG5cdFx0ICB0aGlzLmFkVmVyaWZpY2F0aW9ucyA9IFZlcmlmaWNhdGlvbi5wYXJzZUFkVmVyaWZpY2F0aW9ucyhpbmxpbmVKVHJlZS5hZFZlcmlmaWNhdGlvbnMpO1xuXHQgIH1cbiAgfVxuXG4gIC8qKiogTG9jYWwgRnVuY3Rpb25zICoqKi9cbiAgZnVuY3Rpb24gcGFyc2VTdXJ2ZXlzKGlubGluZVN1cnZleXMpIHtcbiAgICBpZiAoaW5saW5lU3VydmV5cykge1xuICAgICAgcmV0dXJuIHV0aWxpdGllcy50cmFuc2Zvcm1BcnJheSh1dGlsaXRpZXMuaXNBcnJheShpbmxpbmVTdXJ2ZXlzKSA/IGlubGluZVN1cnZleXMgOiBbaW5saW5lU3VydmV5c10sIGZ1bmN0aW9uIChzdXJ2ZXkpIHtcbiAgICAgICAgaWYodXRpbGl0aWVzLmlzTm90RW1wdHlTdHJpbmcoc3VydmV5LmtleVZhbHVlKSl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVyaTogc3VydmV5LmtleVZhbHVlLFxuICAgICAgICAgICAgdHlwZTogc3VydmV5LmF0dHIoJ3R5cGUnKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9hdChleHRlbnNpb25zKSB7XG5cdCAgdmFyIGdldE1vYXRDb25maWdEYXRhID0gZnVuY3Rpb24oYXJyRXh0ZW50aW9ucykge1xuXHRcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJFeHRlbnRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQgIHZhciBleHRlbnNpb24gPSBhcnJFeHRlbnRpb25zW2ldLmV4dGVuc2lvbjtcblx0XHRcdCAgaWYgKGV4dGVuc2lvbiAmJiBleHRlbnNpb24ubW9hdCkge1xuXHRcdFx0XHQgIHZhciBtb2F0ID0ge307XG5cdFx0XHRcdCAgdmFyIHZhbHVlID0geG1sLmtleVZhbHVlKGV4dGVuc2lvbi5tb2F0KTtcblx0XHRcdFx0ICB2YXIgYXJyID0gdmFsdWUuc3BsaXQoJzsnKTtcblx0XHRcdFx0ICBmb3IgKHZhciBqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdCAgdmFyIHBhcmFtcyA9IGFycltqXS5zcGxpdCgnPScpO1xuXHRcdFx0XHRcdCAgaWYgKHBhcmFtcyAmJiBwYXJhbXMubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRcdFx0XHQgIG1vYXRbcGFyYW1zWzBdXSA9IHBhcmFtc1sxXTtcblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0ICB9XG5cdFx0XHRcdCAgcmV0dXJuIG1vYXQ7XG5cdFx0XHQgIH1cblx0XHQgIH1cblx0XHQgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgfTtcblx0ICBpZiAoZXh0ZW5zaW9ucykge1xuXHRcdCAgcmV0dXJuIGdldE1vYXRDb25maWdEYXRhKHV0aWxpdGllcy5pc0FycmF5KGV4dGVuc2lvbnMpID8gZXh0ZW5zaW9ucyA6IFtleHRlbnNpb25zXSk7XG5cdCAgfVxuXHQgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBhbGwgdGhlIGNyZWF0aXZlcy5cbiAqL1xuSW5MaW5lLnByb3RvdHlwZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpLGxlbjtcblxuICBpZih0aGlzLmNyZWF0aXZlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IoaSA9IDAsIGxlbiA9IHRoaXMuY3JlYXRpdmVzLmxlbmd0aDsgaTwgbGVuOyBpKz0xKXtcbiAgICBpZighdGhpcy5jcmVhdGl2ZXNbaV0uaXNTdXBwb3J0ZWQoKSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbkxpbmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB4bWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy94bWwnKTtcbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91dGlsaXR5RnVuY3Rpb25zJyk7XG5cbmZ1bmN0aW9uIEludGVyYWN0aXZlQ3JlYXRpdmVGaWxlKGludGVyYWN0aXZlQ3JlYXRpdmVGaWxlSlRyZWUpIHtcbiAgaWYoISh0aGlzIGluc3RhbmNlb2YgSW50ZXJhY3RpdmVDcmVhdGl2ZUZpbGUpKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRlcmFjdGl2ZUNyZWF0aXZlRmlsZShpbnRlcmFjdGl2ZUNyZWF0aXZlRmlsZUpUcmVlKTtcbiAgfVxuXG4gIHRoaXMudHlwZSA9IGludGVyYWN0aXZlQ3JlYXRpdmVGaWxlSlRyZWUuYXR0cigndHlwZScpO1xuICB0aGlzLmFwaUZyYW1ld29yayA9IGludGVyYWN0aXZlQ3JlYXRpdmVGaWxlSlRyZWUuYXR0cignYXBpRnJhbWV3b3JrJyk7XG4gIHRoaXMuc3JjID0geG1sLmtleVZhbHVlKGludGVyYWN0aXZlQ3JlYXRpdmVGaWxlSlRyZWUpO1xufVxuXG5JbnRlcmFjdGl2ZUNyZWF0aXZlRmlsZS5wYXJzZUludGVyYWN0aXZlQ3JlYXRpdmVGaWxlcyA9IGZ1bmN0aW9uIHBhcnNlSW50ZXJhY3RpdmVDcmVhdGl2ZUZpbGVzKGljZnNKVHJlZSkge1xuICB2YXIgaW50ZXJhY3RpdmVDcmVhdGl2ZUZpbGVzID0gW107XG4gIHZhciBpbnRlcmFjdGl2ZUNyZWF0aXZlRmlsZXNEYXRhO1xuICBpZiAodXRpbGl0aWVzLmlzRGVmaW5lZChpY2ZzSlRyZWUpKSB7XG5cdCAgaW50ZXJhY3RpdmVDcmVhdGl2ZUZpbGVzRGF0YSA9IHV0aWxpdGllcy5pc0FycmF5KGljZnNKVHJlZSkgPyBpY2ZzSlRyZWUgOiBbaWNmc0pUcmVlXTtcblx0ICBpbnRlcmFjdGl2ZUNyZWF0aXZlRmlsZXNEYXRhLmZvckVhY2goZnVuY3Rpb24gKGZpbGVKVHJlZSkge1xuXHRcdCAgaW50ZXJhY3RpdmVDcmVhdGl2ZUZpbGVzLnB1c2gobmV3IEludGVyYWN0aXZlQ3JlYXRpdmVGaWxlKGZpbGVKVHJlZSkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBpbnRlcmFjdGl2ZUNyZWF0aXZlRmlsZXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyYWN0aXZlQ3JlYXRpdmVGaWxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHJhY2tpbmdFdmVudCA9IHJlcXVpcmUoJy4vVHJhY2tpbmdFdmVudCcpO1xudmFyIE1lZGlhRmlsZSA9IHJlcXVpcmUoJy4vTWVkaWFGaWxlJyk7XG52YXIgVmlkZW9DbGlja3MgPSByZXF1aXJlKCcuL1ZpZGVvQ2xpY2tzJyk7XG52YXIgSW50ZXJhY3RpdmVDcmVhdGl2ZUZpbGUgPSByZXF1aXJlKCcuL0ludGVyYWN0aXZlQ3JlYXRpdmVGaWxlJyk7XG52YXIgSWNvbiA9IHJlcXVpcmUoJy4vSWNvbicpO1xuXG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXRpbGl0eUZ1bmN0aW9ucycpO1xudmFyIHBhcnNlcnMgPSByZXF1aXJlKCcuL3BhcnNlcnMnKTtcblxudmFyIHhtbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3htbCcpO1xuXG5cbmZ1bmN0aW9uIExpbmVhcihsaW5lYXJKVHJlZSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGluZWFyKSkge1xuICAgIHJldHVybiBuZXcgTGluZWFyKGxpbmVhckpUcmVlKTtcbiAgfVxuXG4gIC8vUmVxdWlyZWQgRWxlbWVudHNcbiAgdGhpcy5kdXJhdGlvbiA9IHBhcnNlcnMuZHVyYXRpb24oeG1sLmtleVZhbHVlKGxpbmVhckpUcmVlLmR1cmF0aW9uKSk7XG4gIHRoaXMubWVkaWFGaWxlcyA9IHBhcnNlTWVkaWFGaWxlcyhsaW5lYXJKVHJlZS5tZWRpYUZpbGVzICYmIGxpbmVhckpUcmVlLm1lZGlhRmlsZXMubWVkaWFGaWxlKTtcblxuICAvL09wdGlvbmFsIGZpZWxkc1xuICB0aGlzLnRyYWNraW5nRXZlbnRzID0gcGFyc2VUcmFja2luZ0V2ZW50cyhsaW5lYXJKVHJlZS50cmFja2luZ0V2ZW50cyAmJiBsaW5lYXJKVHJlZS50cmFja2luZ0V2ZW50cy50cmFja2luZywgdGhpcy5kdXJhdGlvbik7XG4gIHRoaXMuc2tpcG9mZnNldCA9IHBhcnNlcnMub2Zmc2V0KHhtbC5hdHRyKGxpbmVhckpUcmVlLCAnc2tpcG9mZnNldCcpLCB0aGlzLmR1cmF0aW9uKTtcbiAgXG4gIC8vIGFkanVzdCBza2lwb2Zmc2V0IHRvIHB1Ymxpc2hlciBzZXR0aW5nc1xuICBpZiAodGhpcy5kdXJhdGlvbiAmJiB3aW5kb3cuX21vbFNldHRpbmdzICYmIHdpbmRvdy5fbW9sU2V0dGluZ3Muc2tpcHBhYmxlKSB7XG5cdCAgaWYgKHdpbmRvdy5fbW9sU2V0dGluZ3Muc2tpcHBhYmxlLmVuYWJsZWQpIHtcblx0XHQgaWYgKHRoaXMuZHVyYXRpb24gPj0gd2luZG93Ll9tb2xTZXR0aW5ncy5za2lwcGFibGUudmlkZW9UaHJlc2hvbGQpIHtcblx0XHRcdCB0aGlzLnNraXBvZmZzZXQgPSB3aW5kb3cuX21vbFNldHRpbmdzLnNraXBwYWJsZS52aWRlb09mZnNldDtcblx0XHQgfVxuXHRcdCBlbHNlIHtcblx0XHRcdCB0aGlzLnNraXBvZmZzZXQgPSBudWxsOyBcblx0XHQgfVxuXHQgIH1cblx0ICBlbHNlIHtcblx0XHQgIHRoaXMuc2tpcG9mZnNldCA9IG51bGw7IFxuXHQgIH1cbiAgfVxuXG4gIGlmIChsaW5lYXJKVHJlZS52aWRlb0NsaWNrcykge1xuICAgIHRoaXMudmlkZW9DbGlja3MgPSBuZXcgVmlkZW9DbGlja3MobGluZWFySlRyZWUudmlkZW9DbGlja3MpO1xuICB9XG5cbiAgaWYobGluZWFySlRyZWUuYWRQYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5hZFBhcmFtZXRlcnMgPSB4bWwua2V5VmFsdWUobGluZWFySlRyZWUuYWRQYXJhbWV0ZXJzKTtcblxuICAgIGlmKHhtbC5hdHRyKGxpbmVhckpUcmVlLmFkUGFyYW1ldGVycywgJ3htbEVuY29kZWQnKSkge1xuICAgICAgdGhpcy5hZFBhcmFtZXRlcnMgPSB4bWwuZGVjb2RlKHRoaXMuYWRQYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cbiAgXG4gIGlmICh3aW5kb3cubW9sX3Zhc3RWZXJzaW9uID09PSA0KSB7XG5cdCAgaWYgKGxpbmVhckpUcmVlLm1lZGlhRmlsZXMgJiYgbGluZWFySlRyZWUubWVkaWFGaWxlcy5tZXp6YW5pbmUpIHtcblx0XHQgIHRoaXMubWV6emFuaW5lID0geG1sLmtleVZhbHVlKGxpbmVhckpUcmVlLm1lZGlhRmlsZXMubWV6emFuaW5lKTtcblx0ICB9XG5cdCAgaWYgKGxpbmVhckpUcmVlLm1lZGlhRmlsZXMgJiYgbGluZWFySlRyZWUubWVkaWFGaWxlcy5pbnRlcmFjdGl2ZUNyZWF0aXZlRmlsZSkge1xuXHRcdCAgdGhpcy5pbnRlcmFjdGl2ZUNyZWF0aXZlRmlsZXMgPSBJbnRlcmFjdGl2ZUNyZWF0aXZlRmlsZS5wYXJzZUludGVyYWN0aXZlQ3JlYXRpdmVGaWxlcyhsaW5lYXJKVHJlZS5tZWRpYUZpbGVzLmludGVyYWN0aXZlQ3JlYXRpdmVGaWxlKTtcblx0ICB9XG4gIH1cblxuICBpZiAobGluZWFySlRyZWUuaWNvbnMpIHtcbiAgICB0aGlzLmljb25zID0gcGFyc2VJY29ucyhsaW5lYXJKVHJlZS5pY29ucyAmJiBsaW5lYXJKVHJlZS5pY29ucy5pY29uKTtcbiAgfVxuXG4gIC8qKiogTG9jYWwgZnVuY3Rpb25zICoqKi9cbiAgZnVuY3Rpb24gcGFyc2VUcmFja2luZ0V2ZW50cyh0cmFja2luZ0V2ZW50cywgZHVyYXRpb24pIHtcbiAgICB2YXIgdHJhY2tpbmdzID0gW107XG4gICAgaWYgKHV0aWxpdGllcy5pc0RlZmluZWQodHJhY2tpbmdFdmVudHMpKSB7XG4gICAgICB0cmFja2luZ0V2ZW50cyA9IHV0aWxpdGllcy5pc0FycmF5KHRyYWNraW5nRXZlbnRzKSA/IHRyYWNraW5nRXZlbnRzIDogW3RyYWNraW5nRXZlbnRzXTtcbiAgICAgIHRyYWNraW5nRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNraW5nRGF0YSkge1xuICAgICAgICB0cmFja2luZ3MucHVzaChuZXcgVHJhY2tpbmdFdmVudCh0cmFja2luZ0RhdGEsIGR1cmF0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYWNraW5ncztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTWVkaWFGaWxlcyhtZWRpYUZpbGVzSnhvblRyZWUpIHtcbiAgICB2YXIgbWVkaWFGaWxlcyA9IFtdO1xuICAgIGlmICh1dGlsaXRpZXMuaXNEZWZpbmVkKG1lZGlhRmlsZXNKeG9uVHJlZSkpIHtcbiAgICAgIG1lZGlhRmlsZXNKeG9uVHJlZSA9IHV0aWxpdGllcy5pc0FycmF5KG1lZGlhRmlsZXNKeG9uVHJlZSkgPyBtZWRpYUZpbGVzSnhvblRyZWUgOiBbbWVkaWFGaWxlc0p4b25UcmVlXTtcblxuICAgICAgbWVkaWFGaWxlc0p4b25UcmVlLmZvckVhY2goZnVuY3Rpb24gKG1mRGF0YSkge1xuICAgICAgICBtZWRpYUZpbGVzLnB1c2gobmV3IE1lZGlhRmlsZShtZkRhdGEpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWVkaWFGaWxlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSWNvbnMoaWNvbnNKeG9uVHJlZSkge1xuICAgIHZhciBpY29ucyA9IFtdO1xuICAgIGlmICh1dGlsaXRpZXMuaXNEZWZpbmVkKGljb25zSnhvblRyZWUpKSB7XG4gICAgICBpY29uc0p4b25UcmVlID0gdXRpbGl0aWVzLmlzQXJyYXkoaWNvbnNKeG9uVHJlZSkgPyBpY29uc0p4b25UcmVlIDogW2ljb25zSnhvblRyZWVdO1xuXG4gICAgICBpY29uc0p4b25UcmVlLmZvckVhY2goZnVuY3Rpb24gKGljb25EYXRhKSB7XG4gICAgICAgIGljb25zLnB1c2gobmV3IEljb24oaWNvbkRhdGEpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaWNvbnM7XG4gIH1cbn1cblxuLyoqXG4gKiBNdXN0IHJldHVybiB0cnVlIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgTWVkaWFGaWxlcycgdHlwZSBpcyBzdXBwb3J0ZWRcbiAqL1xuTGluZWFyLnByb3RvdHlwZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yKGk9MCwgbGVuPXRoaXMubWVkaWFGaWxlcy5sZW5ndGg7IGk8bGVuOyBpKz0xKSB7XG4gICAgaWYodGhpcy5tZWRpYUZpbGVzW2ldLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZWFyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgeG1sID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMveG1sJyk7XG52YXIgdmFzdFV0aWwgPSByZXF1aXJlKCcuL3Zhc3RVdGlsJyk7XG5cbnZhciBhdHRyaWJ1dGVzTGlzdCA9IFtcbiAgLy9SZXF1aXJlZCBhdHRyaWJ1dGVzXG4gICdkZWxpdmVyeScsXG4gICd0eXBlJyxcbiAgJ3dpZHRoJyxcbiAgJ2hlaWdodCcsXG4gIC8vT3B0aW9uYWwgYXR0cmlidXRlc1xuICAnY29kZWMnLFxuICAnaWQnLFxuICAnYml0cmF0ZScsXG4gICdtaW5CaXRyYXRlJyxcbiAgJ21heEJpdHJhdGUnLFxuICAnc2NhbGFibGUnLFxuICAnbWFpbnRhaW5Bc3BlY3RSYXRpbycsXG4gICdhcGlGcmFtZXdvcmsnXG5dO1xuXG5mdW5jdGlvbiBNZWRpYUZpbGUobWVkaWFGaWxlSlRyZWUpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1lZGlhRmlsZSkpIHtcbiAgICByZXR1cm4gbmV3IE1lZGlhRmlsZShtZWRpYUZpbGVKVHJlZSk7XG4gIH1cblxuICAvL1JlcXVpcmVkIGF0dHJpYnV0ZXNcbiAgdGhpcy5zcmMgPSB4bWwua2V5VmFsdWUobWVkaWFGaWxlSlRyZWUpO1xuXG4gIGZvcih2YXIgeD0wOyB4PGF0dHJpYnV0ZXNMaXN0Lmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNMaXN0W3hdO1xuICAgIHRoaXNbYXR0cmlidXRlXSA9IG1lZGlhRmlsZUpUcmVlLmF0dHIoYXR0cmlidXRlKTtcbiAgfVxufVxuXG5NZWRpYUZpbGUucHJvdG90eXBlLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24oKXtcbiAgaWYodmFzdFV0aWwuaXNWUEFJRCh0aGlzKSkge1xuICAgIHJldHVybiAhIXZhc3RVdGlsLmZpbmRTdXBwb3J0ZWRWUEFJRFRlY2godGhpcy50eXBlKTtcbiAgfVxuXG4gIGlmICh0aGlzLnR5cGUgPT09ICd2aWRlby94LWZsdicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWVkaWFGaWxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2VycyA9IHJlcXVpcmUoJy4vcGFyc2VycycpO1xuXG52YXIgeG1sID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMveG1sJyk7XG5cbmZ1bmN0aW9uIFRyYWNraW5nRXZlbnQodHJhY2tpbmdKVHJlZSwgZHVyYXRpb24pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYWNraW5nRXZlbnQpKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja2luZ0V2ZW50KHRyYWNraW5nSlRyZWUsIGR1cmF0aW9uKTtcbiAgfVxuXG4gIHRoaXMubmFtZSA9IHRyYWNraW5nSlRyZWUuYXR0cignZXZlbnQnKTtcbiAgdGhpcy51cmkgPSB4bWwua2V5VmFsdWUodHJhY2tpbmdKVHJlZSk7XG5cbiAgaWYoJ3Byb2dyZXNzJyA9PT0gdGhpcy5uYW1lKSB7XG4gICAgdGhpcy5vZmZzZXQgPSBwYXJzZXJzLm9mZnNldCh0cmFja2luZ0pUcmVlLmF0dHIoJ29mZnNldCcpLCBkdXJhdGlvbik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFja2luZ0V2ZW50OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gVW5pdmVyc2FsQWRJZCh1bml2ZXJzYWxBZElkSlRyZWUpIHtcblx0ICBpZighKHRoaXMgaW5zdGFuY2VvZiBVbml2ZXJzYWxBZElkKSkge1xuXHQgICAgcmV0dXJuIG5ldyBVbml2ZXJzYWxBZElkKHVuaXZlcnNhbEFkSWRKVHJlZSk7XG5cdCAgfVxuXG5cdCAgdGhpcy5pZFJlZ2lzdHJ5ID0gdW5pdmVyc2FsQWRJZEpUcmVlLmF0dHIoJ2lkUmVnaXN0cnknKTtcblx0ICB0aGlzLmlkVmFsdWUgPSB1bml2ZXJzYWxBZElkSlRyZWUuYXR0cignaWRWYWx1ZScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaXZlcnNhbEFkSWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBZCA9IHJlcXVpcmUoJy4vQWQnKTtcbnZhciBWQVNURXJyb3IgPSByZXF1aXJlKCcuL1ZBU1RFcnJvcicpO1xudmFyIFZBU1RSZXNwb25zZSA9IHJlcXVpcmUoJy4vVkFTVFJlc3BvbnNlJyk7XG52YXIgdmFzdFV0aWwgPSByZXF1aXJlKCcuL3Zhc3RVdGlsJyk7XG5cbnZhciBhc3luYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FzeW5jJyk7XG52YXIgaHR0cCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2h0dHAnKS5odHRwO1xudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3V0aWxpdHlGdW5jdGlvbnMnKTtcbnZhciB4bWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy94bWwnKTtcblxudmFyIGxvZ2dlciA9IHJlcXVpcmUgKCcuLi8uLi91dGlscy9jb25zb2xlTG9nZ2VyJyk7XG5cbmZ1bmN0aW9uIFZBU1RDbGllbnQob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVkFTVENsaWVudCkpIHtcbiAgICByZXR1cm4gbmV3IFZBU1RDbGllbnQob3B0aW9ucyk7XG4gIH1cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIFdSQVBQRVJfTElNSVQ6IG9wdGlvbnMgJiYgb3B0aW9ucy53cmFwcGVyTGltaXQgJiYgb3B0aW9ucy53cmFwcGVyTGltaXQgPiAwID8gb3B0aW9ucy53cmFwcGVyTGltaXQgOiA1XG4gIH07XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuc2V0dGluZ3MgPSB1dGlsaXRpZXMuZXh0ZW5kKHt9LCBvcHRpb25zLCBkZWZhdWx0T3B0aW9ucyk7XG4gIHRoaXMuZXJyb3JVUkxNYWNyb3MgPSBbXTtcbn1cblxuVkFTVENsaWVudC5wcm90b3R5cGUuZ2V0VkFTVFJlc3BvbnNlID0gZnVuY3Rpb24gZ2V0VkFTVFJlc3BvbnNlKGFkVGFnVXJsLCBjYWxsYmFjaykge1xuICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgdmFyIGVycm9yID0gc2FuaXR5Q2hlY2soYWRUYWdVcmwsIGNhbGxiYWNrKTtcbiAgaWYgKGVycm9yKSB7XG4gICAgaWYgKHV0aWxpdGllcy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBhc3luYy53YXRlcmZhbGwoW1xuICAgICAgdGhpcy5fZ2V0VkFTVEFkLmJpbmQodGhpcywgYWRUYWdVcmwpLFxuICAgICAgYnVpbGRWQVNUUmVzcG9uc2VcbiAgICBdLFxuICAgIGNhbGxiYWNrKTtcblxuICAvKioqIExvY2FsIGZ1bmN0aW9ucyAqKiovXG4gIGZ1bmN0aW9uIGJ1aWxkVkFTVFJlc3BvbnNlKGFkc0NoYWluLCBjYikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB0aGF0Ll9idWlsZFZBU1RSZXNwb25zZShhZHNDaGFpbik7XG4gICAgICBjYihudWxsLCByZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2IoZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2FuaXR5Q2hlY2soYWRUYWdVcmwsIGNiKSB7XG4gICAgaWYgKCFhZFRhZ1VybCkge1xuICAgICAgcmV0dXJuIG5ldyBWQVNURXJyb3IoJ29uIFZBU1RDbGllbnQuZ2V0VkFTVFJlc3BvbnNlLCBtaXNzaW5nIGFkIHRhZyBVUkwnKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWxpdGllcy5pc0Z1bmN0aW9uKGNiKSkge1xuICAgICAgcmV0dXJuIG5ldyBWQVNURXJyb3IoJ29uIFZBU1RDbGllbnQuZ2V0VkFTVFJlc3BvbnNlLCBtaXNzaW5nIGNhbGxiYWNrIGZ1bmN0aW9uJyk7XG4gICAgfVxuICB9XG59O1xuXG5WQVNUQ2xpZW50LnByb3RvdHlwZS5fZ2V0VkFTVEFkID0gZnVuY3Rpb24gKGFkVGFnVXJsLCBjYWxsYmFjaykge1xuICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgZ2V0QWRXYXRlcmZhbGwoYWRUYWdVcmwsIGZ1bmN0aW9uIChlcnJvciwgdmFzdFRyZWUpIHtcbiAgICB2YXIgd2F0ZXJmYWxsQWRzID0gdmFzdFRyZWUgJiYgdXRpbGl0aWVzLmlzQXJyYXkodmFzdFRyZWUuYWRzKSA/IHZhc3RUcmVlLmFkcyA6IG51bGw7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aGF0Ll90cmFja0Vycm9yKGVycm9yLCB3YXRlcmZhbGxBZHMpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yLCB3YXRlcmZhbGxBZHMpO1xuICAgIH1cbiAgICBnZXRBZCh3YXRlcmZhbGxBZHMuc2hpZnQoKSwgW10sIHdhdGVyZmFsbEhhbmRsZXIpO1xuXG4gICAgLyoqKiBMb2NhbCBmdW5jdGlvbnMgKioqL1xuICAgIGZ1bmN0aW9uIHdhdGVyZmFsbEhhbmRsZXIoZXJyb3IsIGFkQ2hhaW4pIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aGF0Ll90cmFja0Vycm9yKGVycm9yLCBhZENoYWluKTtcbiAgICAgICAgaWYgKHdhdGVyZmFsbEFkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZ2V0QWQod2F0ZXJmYWxsQWRzLnNoaWZ0KCksW10sIHdhdGVyZmFsbEhhbmRsZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBhZENoYWluKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgYWRDaGFpbik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKioqIExvY2FsIGZ1bmN0aW9ucyAqKiovXG4gIGZ1bmN0aW9uIGdldEFkV2F0ZXJmYWxsKGFkVGFnVXJsLCBjYWxsYmFjaykge1xuICAgIHZhciByZXF1ZXN0VmFzdFhNTCA9IHRoYXQuX3JlcXVlc3RWQVNUWG1sLmJpbmQodGhhdCwgYWRUYWdVcmwpO1xuICAgIGFzeW5jLndhdGVyZmFsbChbXG4gICAgICByZXF1ZXN0VmFzdFhNTCxcbiAgICAgIGJ1aWxkVmFzdFdhdGVyZmFsbFxuICAgIF0sIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkVmFzdFdhdGVyZmFsbCh4bWxTdHIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHZhc3RUcmVlO1xuICAgIHRyeSB7XG4gICAgICB2YXN0VHJlZSA9IHhtbC50b0pYT05UcmVlKHhtbFN0cik7XG4gICAgICBsb2dnZXIuZGVidWcgKFwiYnVpbHQgSlhPTlRyZWUgZnJvbSBWQVNUIHJlc3BvbnNlOlwiLCB2YXN0VHJlZSk7XG5cbiAgICAgIGlmKHV0aWxpdGllcy5pc0FycmF5KHZhc3RUcmVlLmFkKSkge1xuICAgICAgICB2YXN0VHJlZS5hZHMgPSB2YXN0VHJlZS5hZDtcbiAgICAgIH0gZWxzZSBpZih2YXN0VHJlZS5hZCl7XG4gICAgICAgIHZhc3RUcmVlLmFkcyA9IFt2YXN0VHJlZS5hZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXN0VHJlZS5hZHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKHZhbGlkYXRlVkFTVFRyZWUodmFzdFRyZWUpLCB2YXN0VHJlZSk7XG5cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhuZXcgVkFTVEVycm9yKFwib24gVkFTVENsaWVudC5nZXRWQVNUQWQuYnVpbGRWYXN0V2F0ZXJmYWxsLCBlcnJvciBwYXJzaW5nIHhtbFwiLCAxMDApLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZVZBU1RUcmVlKHZhc3RUcmVlKSB7XG4gICAgdmFyIHZhc3RWZXJzaW9uID0geG1sLmF0dHIodmFzdFRyZWUsICd2ZXJzaW9uJyk7XG5cbiAgICBpZiAoIXZhc3RUcmVlLmFkKSB7XG4gICAgICByZXR1cm4gbmV3IFZBU1RFcnJvcignb24gVkFTVENsaWVudC5nZXRWQVNUQWQudmFsaWRhdGVWQVNUVHJlZSwgbm8gQWQgaW4gVkFTVCB0cmVlJywgMzAzKTtcbiAgICB9XG5cbiAgICAvL2lmICh2YXN0VmVyc2lvbiAmJiAodmFzdFZlcnNpb24gIT0gMyAmJiB2YXN0VmVyc2lvbiAhPSAyKSkge1xuICAgIGlmICh2YXN0VmVyc2lvbiAmJiAodmFzdFZlcnNpb24gIT0gMyAmJiB2YXN0VmVyc2lvbiAhPSAyICYmIHZhc3RWZXJzaW9uICE9IDQpKSB7XG4gICAgICByZXR1cm4gbmV3IFZBU1RFcnJvcignb24gVkFTVENsaWVudC5nZXRWQVNUQWQudmFsaWRhdGVWQVNUVHJlZSwgbm90IHN1cHBvcnRlZCBWQVNUIHZlcnNpb24gXCInICsgdmFzdFZlcnNpb24gKyAnXCInLCAxMDIpO1xuICAgIH1cbiAgICB3aW5kb3cubW9sX3Zhc3RWZXJzaW9uID0gdmFzdFZlcnNpb247XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFkKGFkVGFnVXJsLCBhZENoYWluLCBjYWxsYmFjaykge1xuICAgIGlmIChhZENoYWluLmxlbmd0aCA+PSB0aGF0LnNldHRpbmdzLldSQVBQRVJfTElNSVQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgVkFTVEVycm9yKFwib24gVkFTVENsaWVudC5nZXRWQVNUQWQuZ2V0QWQsIHBsYXllcnMgd3JhcHBlciBsaW1pdCByZWFjaGVkICh0aGUgbGltaXQgaXMgXCIgKyBcbiAgICAgICAgdGhhdC5zZXR0aW5ncy5XUkFQUEVSX0xJTUlUICsgXCIpXCIsIDMwMiksIGFkQ2hhaW4pO1xuICAgIH1cblxuICAgIGFzeW5jLndhdGVyZmFsbChbXG4gICAgICBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICBpZiAodXRpbGl0aWVzLmlzU3RyaW5nKGFkVGFnVXJsKSkge1xuICAgICAgICAgIHJlcXVlc3RWQVNUQWQoYWRUYWdVcmwsIG5leHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQobnVsbCwgYWRUYWdVcmwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYnVpbGRBZFxuICAgIF0sIGZ1bmN0aW9uIChlcnJvciwgYWQpIHtcbiAgICAgIGlmIChhZCkge1xuICAgICAgICBhZENoYWluLnB1c2goYWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yLCBhZENoYWluKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkLndyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkKGFkLndyYXBwZXIuVkFTVEFkVGFnVVJJLCBhZENoYWluLCBjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBhZENoYWluKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkQWQoYWRKeG9uVHJlZSwgY2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGFkID0gbmV3IEFkKGFkSnhvblRyZWUpO1xuICAgICAgY2FsbGJhY2sodmFsaWRhdGVBZChhZCksIGFkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhuZXcgVkFTVEVycm9yKCdvbiBWQVNUQ2xpZW50LmdldFZBU1RBZC5idWlsZEFkLCBlcnJvciBwYXJzaW5nIHhtbCcsIDEwMCksIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQWQoYWQpIHtcbiAgICB2YXIgd3JhcHBlciA9IGFkLndyYXBwZXI7XG4gICAgdmFyIGluTGluZSA9IGFkLmluTGluZTtcbiAgICB2YXIgZXJyTXNnUHJlZml4ID0gJ29uIFZBU1RDbGllbnQuZ2V0VkFTVEFkLnZhbGlkYXRlQWQsICc7XG5cbiAgICBpZiAoaW5MaW5lICYmIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBuZXcgVkFTVEVycm9yKGVyck1zZ1ByZWZpeCArXCJJbkxpbmUgYW5kIFdyYXBwZXIgYm90aCBmb3VuZCBvbiB0aGUgc2FtZSBBZFwiLCAxMDEpO1xuICAgIH1cblxuICAgIGlmICghaW5MaW5lICYmICF3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gbmV3IFZBU1RFcnJvcihlcnJNc2dQcmVmaXggKyBcIm5vciB3cmFwcGVyIG5vciBpbmxpbmUgZWxlbWVudHMgZm91bmQgb24gdGhlIEFkXCIsIDEwMSk7XG4gICAgfVxuXG4gICAgaWYgKGluTGluZSAmJiAhaW5MaW5lLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIHJldHVybiBuZXcgVkFTVEVycm9yKGVyck1zZ1ByZWZpeCArIFwiY291bGQgbm90IGZpbmQgTWVkaWFGaWxlIHRoYXQgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgdmlkZW8gcGxheWVyXCIsIDQwMyk7XG4gICAgfVxuXG4gICAgaWYgKHdyYXBwZXIgJiYgIXdyYXBwZXIuVkFTVEFkVGFnVVJJKSB7XG4gICAgICByZXR1cm4gbmV3IFZBU1RFcnJvcihlcnJNc2dQcmVmaXggKyBcIm1pc3NpbmcgJ1ZBU1RBZFRhZ1VSSScgaW4gd3JhcHBlclwiLCAxMDEpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVxdWVzdFZBU1RBZChhZFRhZ1VybCwgY2FsbGJhY2spIHtcbiAgICB0aGF0Ll9yZXF1ZXN0VkFTVFhtbChhZFRhZ1VybCwgZnVuY3Rpb24gKGVycm9yLCB4bWxTdHIpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHZhc3RUcmVlID0geG1sLnRvSlhPTlRyZWUoeG1sU3RyKTtcbiAgICAgICAgY2FsbGJhY2sodmFsaWRhdGVWQVNUVHJlZSh2YXN0VHJlZSksIHZhc3RUcmVlLmFkKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IFZBU1RFcnJvcihcIm9uIFZBU1RDbGllbnQuZ2V0VkFTVEFkLnJlcXVlc3RWQVNUQWQsIGVycm9yIHBhcnNpbmcgeG1sXCIsIDEwMCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5WQVNUQ2xpZW50LnByb3RvdHlwZS5fcmVxdWVzdFZBU1RYbWwgPSBmdW5jdGlvbiByZXF1ZXN0VkFTVFhtbChhZFRhZ1VybCwgY2FsbGJhY2spIHtcbiAgdHJ5IHtcbiAgICBpZiAodXRpbGl0aWVzLmlzRnVuY3Rpb24oYWRUYWdVcmwpKSB7XG4gICAgICBhZFRhZ1VybChyZXF1ZXN0SGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5pbmZvIChcInJlcXVlc3RpbmcgYWRUYWdVcmw6IFwiICsgYWRUYWdVcmwpO1xuICAgICAgaHR0cC5nZXQoYWRUYWdVcmwsIHJlcXVlc3RIYW5kbGVyLCB7XG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY2FsbGJhY2soZSk7XG4gIH1cblxuICAvKioqIExvY2FsIGZ1bmN0aW9ucyAqKiovXG4gIGZ1bmN0aW9uIHJlcXVlc3RIYW5kbGVyKGVycm9yLCByZXNwb25zZSwgc3RhdHVzKSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB2YXIgZXJyTXNnID0gdXRpbGl0aWVzLmlzRGVmaW5lZChzdGF0dXMpID9cbiAgICAgIFwib24gVkFTVENsaWVudC5yZXF1ZXN0VmFzdFhNTCwgSFRUUCByZXF1ZXN0IGVycm9yIHdpdGggc3RhdHVzICdcIiArIHN0YXR1cyArIFwiJ1wiIDpcbiAgICAgICAgXCJvbiBWQVNUQ2xpZW50LnJlcXVlc3RWYXN0WE1MLCBFcnJvciBnZXR0aW5nIHRoZSB0aGUgVkFTVCBYTUwgd2l0aCBoZSBwYXNzZWQgYWRUYWdYTUwgZm5cIjtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgVkFTVEVycm9yKGVyck1zZywgMzAxKSwgbnVsbCk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xuICB9XG59O1xuXG5WQVNUQ2xpZW50LnByb3RvdHlwZS5fYnVpbGRWQVNUUmVzcG9uc2UgPSBmdW5jdGlvbiBidWlsZFZBU1RSZXNwb25zZShhZHNDaGFpbikge1xuICB2YXIgcmVzcG9uc2UgPSBuZXcgVkFTVFJlc3BvbnNlKCk7XG4gIGFkZEFkc1RvUmVzcG9uc2UocmVzcG9uc2UsIGFkc0NoYWluKTtcbiAgdmFsaWRhdGVSZXNwb25zZShyZXNwb25zZSk7XG5cbiAgcmV0dXJuIHJlc3BvbnNlO1xuXG4gIC8vKioqIExvY2FsIGZ1bmN0aW9uICoqKipcbiAgZnVuY3Rpb24gYWRkQWRzVG9SZXNwb25zZShyZXNwb25zZSwgYWRzKSB7XG4gICAgYWRzLmZvckVhY2goZnVuY3Rpb24gKGFkKSB7XG4gICAgICByZXNwb25zZS5hZGRBZChhZCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgdmFyIHByb2dyZXNzRXZlbnRzID0gcmVzcG9uc2UudHJhY2tpbmdFdmVudHMucHJvZ3Jlc3M7XG5cbiAgICBpZiAoIXJlc3BvbnNlLmhhc0xpbmVhcigpKSB7XG4gICAgICB0aHJvdyBuZXcgVkFTVEVycm9yKFwib24gVkFTVENsaWVudC5fYnVpbGRWQVNUUmVzcG9uc2UsIFJlY2VpdmVkIGFuIEFkIHR5cGUgdGhhdCBpcyBub3Qgc3VwcG9ydGVkXCIsIDIwMCk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlLmR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBWQVNURXJyb3IoXCJvbiBWQVNUQ2xpZW50Ll9idWlsZFZBU1RSZXNwb25zZSwgTWlzc2luZyBkdXJhdGlvbiBmaWVsZCBpbiBWQVNUIHJlc3BvbnNlXCIsIDEwMSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2dyZXNzRXZlbnRzKSB7XG4gICAgICBwcm9ncmVzc0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmVzc0V2ZW50KSB7XG4gICAgICAgIGlmICghdXRpbGl0aWVzLmlzTnVtYmVyKHByb2dyZXNzRXZlbnQub2Zmc2V0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBWQVNURXJyb3IoXCJvbiBWQVNUQ2xpZW50Ll9idWlsZFZBU1RSZXNwb25zZSwgbWlzc2luZyBvciB3cm9uZyBvZmZzZXQgYXR0cmlidXRlIG9uIHByb2dyZXNzIHRyYWNraW5nIGV2ZW50XCIsIDEwMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuVkFTVENsaWVudC5wcm90b3R5cGUuX3RyYWNrRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGFkQ2hhaW4pIHtcbiAgaWYgKCF1dGlsaXRpZXMuaXNBcnJheShhZENoYWluKSB8fCBhZENoYWluLmxlbmd0aCA9PT0gMCkgeyAvL1RoZXJlIGlzIG5vdGhpbmcgdG8gdHJhY2tcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXJyb3JVUkxNYWNyb3MgPSBbXTtcbiAgYWRDaGFpbi5mb3JFYWNoKGFkZEVycm9yVXJsTWFjcm9zKTtcbiAgdmFzdFV0aWwudHJhY2soZXJyb3JVUkxNYWNyb3MsIHtFUlJPUkNPREU6IGVycm9yLmNvZGUgfHwgOTAwfSk7ICAvLzkwMCA8PT0gVW5kZWZpbmVkIGVycm9yXG5cbiAgLyoqKiBMb2NhbCBmdW5jdGlvbnMgICoqKi9cbiAgZnVuY3Rpb24gYWRkRXJyb3JVcmxNYWNyb3MoYWQpIHtcbiAgICAvKmlmIChhZC53cmFwcGVyICYmIGFkLndyYXBwZXIuZXJyb3IgJiYgdHlwZW9mKGFkLndyYXBwZXIuZXJyb3IpID09PSAnc3RyaW5nJykge1xuICAgICAgICBlcnJvclVSTE1hY3Jvcy5wdXNoKGFkLndyYXBwZXIuZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChhZC5pbkxpbmUgJiYgYWQuaW5MaW5lLmVycm9yICYmIHR5cGVvZihhZC5pbkxpbmUuZXJyb3IpID09PSAnc3RyaW5nJykge1xuICAgIFx0ZXJyb3JVUkxNYWNyb3MucHVzaChhZC5pbkxpbmUuZXJyb3IpO1xuICAgIH0qL1xuXHQgIFxuICAgICAgaWYgKGFkLndyYXBwZXIgJiYgYWQud3JhcHBlci5lcnJvcnMgJiYgQXJyYXkuaXNBcnJheShhZC53cmFwcGVyLmVycm9ycykpIHtcbiAgICBcdCAgZXJyb3JVUkxNYWNyb3MgPSBlcnJvclVSTE1hY3Jvcy5jb25jYXQoYWQud3JhcHBlci5lcnJvcnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWQuaW5MaW5lICYmIGFkLmluTGluZS5lcnJvcnMgJiYgQXJyYXkuaXNBcnJheShhZC5pbkxpbmUuZXJyb3JzKSkge1xuICAgIFx0ICBlcnJvclVSTE1hY3JvcyA9IGVycm9yVVJMTWFjcm9zLmNvbmNhdChhZC5pbkxpbmUuZXJyb3JzKTtcbiAgICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWQVNUQ2xpZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBWQVNURXJyb3IobWVzc2FnZSwgY29kZSkge1xuICB0aGlzLm1lc3NhZ2UgPSAnVkFTVCBFcnJvcjogJyArIChtZXNzYWdlIHx8ICcnKTtcbiAgaWYgKGNvZGUpIHtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59XG5cblZBU1RFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblZBU1RFcnJvci5wcm90b3R5cGUubmFtZSA9IFwiVkFTVCBFcnJvclwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZBU1RFcnJvcjsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogSW5uZXIgaGVscGVyIGNsYXNzIHRoYXQgZGVhbHMgd2l0aCB0aGUgbG9naWMgb2YgdGhlIGluZGl2aWR1YWwgc3RlcHMgbmVlZGVkIHRvIHNldHVwIGFuIGFkIGluIHRoZSBwbGF5ZXIuXG4gKlxuICogQHBhcmFtIHBsYXllciB7b2JqZWN0fSBpbnN0YW5jZSBvZiB0aGUgcGxheWVyIHRoYXQgd2lsbCBwbGF5IHRoZSBhZC4gSXQgYXNzdW1lcyB0aGF0IHRoZSB2aWRlb2pzLWNvbnRyaWItYWRzIHBsdWdpblxuICogICAgICAgICAgICAgICAgICAgICAgICBoYXMgYmVlbiBpbml0aWFsaXplZCB3aGVuIHlvdSB1c2UgaXRzIHV0aWxpdHkgZnVuY3Rpb25zLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBWQVNUUmVzcG9uc2UgPSByZXF1aXJlKCcuL1ZBU1RSZXNwb25zZScpO1xudmFyIFZBU1RFcnJvciA9IHJlcXVpcmUoJy4vVkFTVEVycm9yJyk7XG52YXIgVkFTVFRyYWNrZXIgPSByZXF1aXJlKCcuL1ZBU1RUcmFja2VyJyk7XG52YXIgdmFzdFV0aWwgPSByZXF1aXJlKCcuL3Zhc3RVdGlsJyk7XG5cbnZhciBhc3luYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FzeW5jJyk7XG52YXIgZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZG9tJyk7XG52YXIgcGxheWVyVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9wbGF5ZXJVdGlscycpO1xudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3V0aWxpdHlGdW5jdGlvbnMnKTtcblxudmFyIGxvZ2dlciA9IHJlcXVpcmUgKCcuLi8uLi91dGlscy9jb25zb2xlTG9nZ2VyJyk7XG5cbmZ1bmN0aW9uIFZBU1RJbnRlZ3JhdG9yKHBsYXllcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVkFTVEludGVncmF0b3IpKSB7XG4gICAgcmV0dXJuIG5ldyBWQVNUSW50ZWdyYXRvcihwbGF5ZXIpO1xuICB9XG5cbiAgdGhpcy5wbGF5ZXIgPSBwbGF5ZXI7XG4gIHRoaXMuZW5hYmxlRnVsbHNjcmVlbkNsaWNrSUZyYW1lID0gZmFsc2U7XG59XG5cblZBU1RJbnRlZ3JhdG9yLnByb3RvdHlwZS5wbGF5QWQgPSBmdW5jdGlvbiBwbGF5QWQodmFzdFJlc3BvbnNlLCBjYWxsYmFjaykge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgdXRpbGl0aWVzLm5vb3A7XG5cbiAgaWYgKCEodmFzdFJlc3BvbnNlIGluc3RhbmNlb2YgVkFTVFJlc3BvbnNlKSkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgVkFTVEVycm9yKCdPbiBWQVNUSW50ZWdyYXRvciwgbWlzc2luZyByZXF1aXJlZCBWQVNUUmVzcG9uc2UnKSk7XG4gIH1cblxuICBhc3luYy53YXRlcmZhbGwoW1xuICAgIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICBuZXh0KG51bGwsIHZhc3RSZXNwb25zZSk7XG4gICAgfSxcbiAgICB0aGlzLl9zZWxlY3RBZFNvdXJjZS5iaW5kKHRoaXMpLFxuICAgIHRoaXMuX2NyZWF0ZVZBU1RUcmFja2VyLmJpbmQodGhpcyksXG4gICAgdGhpcy5fYWRkQ2xpY2tUaHJvdWdoLmJpbmQodGhpcyksXG4gICAgdGhpcy5fYWRkQ2xpY2tUaHJvdWdoRGl2QmxvY2tlci5iaW5kKHRoaXMpLFxuICAgIHRoaXMuX2FkZFNraXBCdXR0b24uYmluZCh0aGlzKSxcbiAgICB0aGlzLl9zZXR1cEV2ZW50cy5iaW5kKHRoaXMpLFxuICAgIHRoaXMuX3BsYXlTZWxlY3RlZEFkLmJpbmQodGhpcylcbiAgXSwgZnVuY3Rpb24gKGVycm9yLCByZXNwb25zZSkge1xuICAgIGlmIChlcnJvciAmJiByZXNwb25zZSkge1xuICAgICAgICBpZiAod2luZG93Lk1vYXRBcGlSZWZlcmVuY2UpIHtcbiAgICAgICAgXHR3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZS5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnQWRFcnJvcicsIGFkVm9sdW1lOiB0aGF0LnBsYXllci52b2x1bWUoKX0pO1xuICAgICAgICB9XG4gICAgICB0aGF0Ll90cmFja0Vycm9yKGVycm9yLCByZXNwb25zZSk7XG4gICAgfVxuICAgIGNhbGxiYWNrKGVycm9yLCByZXNwb25zZSk7XG4gIH0pO1xuXG4gIHRoaXMuX2FkVW5pdCA9IHtcbiAgICBfc3JjOiBudWxsLFxuICAgIHR5cGU6ICdWQVNUJyxcbiAgICBwYXVzZUFkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LnBsYXllci5wYXVzZSh0cnVlKTtcbiAgICB9LFxuXG4gICAgcmVzdW1lQWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQucGxheWVyLnBsYXkodHJ1ZSk7XG4gICAgfSxcblxuICAgIGlzUGF1c2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhhdC5wbGF5ZXIucGF1c2VkKHRydWUpO1xuICAgIH0sXG5cbiAgICBnZXRTcmM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zcmM7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzLl9hZFVuaXQ7XG59O1xuXG5WQVNUSW50ZWdyYXRvci5wcm90b3R5cGUuX3NlbGVjdEFkU291cmNlID0gZnVuY3Rpb24gc2VsZWN0QWRTb3VyY2UocmVzcG9uc2UsIGNhbGxiYWNrKSB7XG4gIHZhciBzb3VyY2U7XG5cbiAgdmFyIHBsYXllcldpZHRoID0gZG9tLmdldERpbWVuc2lvbih0aGlzLnBsYXllci5lbCgpKS53aWR0aDtcbiAgcmVzcG9uc2UubWVkaWFGaWxlcy5zb3J0KGZ1bmN0aW9uIGNvbXBhcmVUbyhhLCBiKSB7XG4gICAgdmFyIGRlbHRhQSA9IE1hdGguYWJzKHBsYXllcldpZHRoIC0gYS53aWR0aCk7XG4gICAgdmFyIGRlbHRhQiA9IE1hdGguYWJzKHBsYXllcldpZHRoIC0gYi53aWR0aCk7XG4gICAgcmV0dXJuIGRlbHRhQSAtIGRlbHRhQjtcbiAgfSk7XG5cbiAgc291cmNlID0gdGhpcy5wbGF5ZXIuc2VsZWN0U291cmNlKHJlc3BvbnNlLm1lZGlhRmlsZXMpLnNvdXJjZTtcbiAgaWYgKHNvdXJjZSkge1xuICAgIHRoaXMucGxheWVyLnRyaWdnZXIoe3R5cGU6ICd0cmFjZS5tZXNzYWdlJywgZGF0YToge21lc3NhZ2U6ICdQbGF5aW5nICcgKyBzb3VyY2Uuc3JjICsgJyAodHlwZSA9ICcgKyBzb3VyY2UudHlwZSArICcpJ319KTtcbiAgfVxuICBcbiAgaWYgKHNvdXJjZSkge1xuICAgIGxvZ2dlci5pbmZvIChcInNlbGVjdGVkIHNvdXJjZTogXCIsIHNvdXJjZSk7XG4gICAgaWYgKHRoaXMuX2FkVW5pdCkge1xuICAgICAgdGhpcy5fYWRVbml0Ll9zcmMgPSBzb3VyY2U7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBzb3VyY2UsIHJlc3BvbnNlKTtcbiAgfVxuXG4gIC8vIGNvZGUgNDAzIDw9PSBDb3VsZG4ndCBmaW5kIE1lZGlhRmlsZSB0aGF0IGlzIHN1cHBvcnRlZCBieSB0aGlzIHZpZGVvIHBsYXllclxuICBjYWxsYmFjayhuZXcgVkFTVEVycm9yKFwiQ291bGQgbm90IGZpbmQgQWQgbWVkaWFmaWxlIHN1cHBvcnRlZCBieSB0aGlzIHBsYXllclwiLCA0MDMpLCByZXNwb25zZSk7XG59O1xuXG5WQVNUSW50ZWdyYXRvci5wcm90b3R5cGUuX2NyZWF0ZVZBU1RUcmFja2VyID0gZnVuY3Rpb24gY3JlYXRlVkFTVFRyYWNrZXIoYWRNZWRpYUZpbGUsIHJlc3BvbnNlLCBjYWxsYmFjaykge1xuICB0cnkge1xuICAgIGNhbGxiYWNrKG51bGwsIGFkTWVkaWFGaWxlLCBuZXcgVkFTVFRyYWNrZXIoYWRNZWRpYUZpbGUuc3JjLCByZXNwb25zZSksIHJlc3BvbnNlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhbGxiYWNrKGUsIHJlc3BvbnNlKTtcbiAgfVxufTtcblxuVkFTVEludGVncmF0b3IucHJvdG90eXBlLl9zZXR1cEV2ZW50cyA9IGZ1bmN0aW9uIHNldHVwRXZlbnRzKGFkTWVkaWFGaWxlLCB0cmFja2VyLCByZXNwb25zZSwgY2FsbGJhY2spIHtcbiAgdmFyIHByZXZpb3VzbHlNdXRlZDtcbiAgdmFyIHBsYXllciA9IHRoaXMucGxheWVyO1xuICBwbGF5ZXIub24oJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB0cmFja0Z1bGxzY3JlZW5DaGFuZ2UpO1xuICBwbGF5ZXIub24oJ3Zhc3QuYWRTdGFydCcsIHRyYWNrSW1wcmVzc2lvbnMpO1xuICBwbGF5ZXIub24oJ3BhdXNlJywgdHJhY2tQYXVzZSk7XG4gIHBsYXllci5vbigndGltZXVwZGF0ZScsIHRyYWNrUHJvZ3Jlc3MpO1xuICBwbGF5ZXIub24oJ3ZvbHVtZWNoYW5nZScsIHRyYWNrVm9sdW1lQ2hhbmdlKTtcblxuICBwbGF5ZXJVdGlscy5vbmNlKHBsYXllciwgWyd2YXN0LmFkRW5kJywgJ3Zhc3QuYWRzQ2FuY2VsJ10sIHVuYmluZEV2ZW50cyk7XG4gIHBsYXllclV0aWxzLm9uY2UocGxheWVyLCBbJ3Zhc3QuYWRFbmQnLCAndmFzdC5hZHNDYW5jZWwnLCAndmFzdC5hZFNraXAnXSwgZnVuY3Rpb24oZXZ0KXtcbiAgICBpZihldnQudHlwZSA9PT0gJ3Zhc3QuYWRFbmQnKXtcbiAgICAgIHRyYWNrZXIudHJhY2tDb21wbGV0ZSgpO1xuICAgIH1cbiAgICBpZiAod2luZG93Lk1vYXRBcGlSZWZlcmVuY2UpIHtcbiAgICBcdHZhciB0eXBlID0gZXZ0LnR5cGUgPT09ICd2YXN0LmFkRW5kJyA/ICdBZFZpZGVvQ29tcGxldGUnIDogJ0FkU3RvcHBlZCc7XG4gIFx0ICB3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZS5kaXNwYXRjaEV2ZW50KHt0eXBlOiB0eXBlLCBhZFZvbHVtZTogcGxheWVyLnZvbHVtZSgpfSk7XG4gICAgfVxuICB9KTtcbiAgXG4gIHBsYXllci5vbmUoJ2FkU3RvcCcsIGZ1bmN0aW9uKCkge1xuXHQgcGxheWVyLnRyaWdnZXIoJ3Zhc3QuYWRzQ2FuY2VsJyk7IFxuICB9KTtcblxuICByZXR1cm4gY2FsbGJhY2sobnVsbCwgYWRNZWRpYUZpbGUsIHJlc3BvbnNlKTtcblxuICAvKioqIExvY2FsIEZ1bmN0aW9ucyAqKiovXG4gIGZ1bmN0aW9uIHVuYmluZEV2ZW50cygpIHtcbiAgICBwbGF5ZXIub2ZmKCdmdWxsc2NyZWVuY2hhbmdlJywgdHJhY2tGdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICBwbGF5ZXIub2ZmKCd2YXN0LmFkU3RhcnQnLCB0cmFja0ltcHJlc3Npb25zKTtcbiAgICBwbGF5ZXIub2ZmKCdwYXVzZScsIHRyYWNrUGF1c2UpO1xuICAgIHBsYXllci5vZmYoJ3RpbWV1cGRhdGUnLCB0cmFja1Byb2dyZXNzKTtcbiAgICBwbGF5ZXIub2ZmKCd2b2x1bWVjaGFuZ2UnLCB0cmFja1ZvbHVtZUNoYW5nZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFja0Z1bGxzY3JlZW5DaGFuZ2UoKSB7XG4gICAgaWYgKHBsYXllci5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgdHJhY2tlci50cmFja0Z1bGxzY3JlZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2tlci50cmFja0V4aXRGdWxsc2NyZWVuKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJhY2tQYXVzZSgpIHtcbiAgICAvL05PVEU6IHdoZW5ldmVyIGEgdmlkZW8gZW5kcyB0aGUgdmlkZW8gRWxlbWVudCB0cmlnZ2VycyBhICdwYXVzZScgZXZlbnQgYmVmb3JlIHRoZSAnZW5kZWQnIGV2ZW50LlxuICAgIC8vICAgICAgV2Ugc2hvdWxkIG5vdCB0cmFjayB0aGlzIHBhdXNlIGV2ZW50IGJlY2F1c2UgaXQgbWFrZXMgdGhlIFZBU1QgdHJhY2tpbmcgY29uZnVzaW5nIGFnYWluIHdlIHVzZSBhXG4gICAgLy8gICAgICBUaHJlc2hvbGQgb2YgMiBzZWNvbmRzIHRvIHByZXZlbnQgZmFsc2UgcG9zaXRpdmVzIG9uIElPUy5cblx0XHRpZiAod2luZG93Ll9tb2xTZXR0aW5ncy5icmVha0R1cmF0aW9uKSB7XG5cdFx0XHRpZiAod2luZG93Ll9tb2xTZXR0aW5ncy5yZWFsVmlkZW9EdXJhdGlvbikge1xuXHRcdFx0ICAgIGlmIChNYXRoLmFicyh3aW5kb3cuX21vbFNldHRpbmdzLnJlYWxWaWRlb0R1cmF0aW9uIC0gcGxheWVyLmN1cnJlbnRUaW1lKCkpIDwgMikge1xuXHRcdFx0ICAgICAgICByZXR1cm47XG5cdFx0XHQgICAgfVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmIChNYXRoLmFicyhwbGF5ZXIuZHVyYXRpb24oKSAtIHBsYXllci5jdXJyZW50VGltZSgpKSA8IDIpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG4gICAgaWYgKHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlKSB7XG4gICAgXHQgIHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlLmRpc3BhdGNoRXZlbnQoe3R5cGU6ICdBZFBhdXNlZCcsIGFkVm9sdW1lOiBwbGF5ZXIudm9sdW1lKCl9KTtcbiAgICB9XG4gICAgdHJhY2tlci50cmFja1BhdXNlKCk7XG4gICAgcGxheWVyVXRpbHMuc2hvd0JpZ1BsYXlCdXR0b24ocGxheWVyLCB0cnVlKTtcbiAgICBwbGF5ZXJVdGlscy5vbmNlKHBsYXllciwgWydwbGF5JywgJ3Zhc3QuYWRFbmQnLCAndmFzdC5hZHNDYW5jZWwnXSwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaWYoZXZ0LnR5cGUgPT09ICdwbGF5Jyl7XG5cdCAgICBpZiAod2luZG93Lk1vYXRBcGlSZWZlcmVuY2UpIHtcblx0ICAgIFx0ICB3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZS5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnQWRQbGF5aW5nJywgYWRWb2x1bWU6IHBsYXllci52b2x1bWUoKX0pO1xuXHQgICAgfVxuICAgICAgICB0cmFja2VyLnRyYWNrUmVzdW1lKCk7XG4gICAgICAgIHBsYXllclV0aWxzLnNob3dCaWdQbGF5QnV0dG9uKHBsYXllciwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhY2tQcm9ncmVzcygpIHtcbiAgICB2YXIgY3VycmVudFRpbWVJbk1zID0gcGxheWVyLmN1cnJlbnRUaW1lKCkgKiAxMDAwO1xuICAgIHRyYWNrZXIudHJhY2tQcm9ncmVzcyhjdXJyZW50VGltZUluTXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhY2tJbXByZXNzaW9ucygpIHtcbiAgICBpZiAod2luZG93Lk1vYXRBcGlSZWZlcmVuY2UpIHtcbiAgICBcdCAgd2luZG93Lk1vYXRBcGlSZWZlcmVuY2UuZGlzcGF0Y2hFdmVudCh7dHlwZTogJ0FkSW1wcmVzc2lvbicsIGFkVm9sdW1lOiBwbGF5ZXIudm9sdW1lKCl9KTtcbiAgICB9XG4gICAgdHJhY2tlci50cmFja0ltcHJlc3Npb25zKCk7XG4gICAgdHJhY2tlci50cmFja0NyZWF0aXZlVmlldygpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhY2tWb2x1bWVDaGFuZ2UoKSB7XG4gICAgaWYgKHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlKSB7XG4gIFx0ICB3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZS5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnQWRWb2x1bWVDaGFuZ2UnLCBhZFZvbHVtZTogcGxheWVyLnZvbHVtZSgpfSk7XG4gICAgfVxuICAgIHZhciBtdXRlZCA9IHBsYXllci5tdXRlZCgpO1xuICAgIGlmIChtdXRlZCkge1xuICAgICAgdHJhY2tlci50cmFja011dGUoKTtcbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzbHlNdXRlZCkge1xuICAgICAgdHJhY2tlci50cmFja1VubXV0ZSgpO1xuICAgIH1cbiAgICBwcmV2aW91c2x5TXV0ZWQgPSBtdXRlZDtcbiAgfVxufTtcblxuVkFTVEludGVncmF0b3IucHJvdG90eXBlLl9hZGRTa2lwQnV0dG9uID0gZnVuY3Rpb24gYWRkU2tpcEJ1dHRvbihzb3VyY2UsIHRyYWNrZXIsIHJlc3BvbnNlLCBjYWxsYmFjaykge1xuICB2YXIgc2tpcE9mZnNldEluU2VjO1xuICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgaWYgKHV0aWxpdGllcy5pc051bWJlcihyZXNwb25zZS5za2lwb2Zmc2V0KSkge1xuICAgIHNraXBPZmZzZXRJblNlYyA9IHJlc3BvbnNlLnNraXBvZmZzZXQgLyAxMDAwO1xuICAgIGFkZFNraXBCdXR0b25Ub1BsYXllcih0aGlzLnBsYXllciwgc2tpcE9mZnNldEluU2VjKTtcbiAgfVxuICBjYWxsYmFjayhudWxsLCBzb3VyY2UsIHRyYWNrZXIsIHJlc3BvbnNlKTtcblxuICAvKioqIExvY2FsIGZ1bmN0aW9uICoqKi9cbiAgZnVuY3Rpb24gYWRkU2tpcEJ1dHRvblRvUGxheWVyKHBsYXllciwgc2tpcE9mZnNldCkge1xuICAgIHZhciBza2lwQnV0dG9uID0gY3JlYXRlU2tpcEJ1dHRvbihwbGF5ZXIpO1xuICAgIHZhciB1cGRhdGVTa2lwQnV0dG9uID0gdXBkYXRlU2tpcEJ1dHRvblN0YXRlLmJpbmQodGhhdCwgc2tpcEJ1dHRvbiwgc2tpcE9mZnNldCwgcGxheWVyKTtcblxuICAgIHBsYXllci5lbCgpLmFwcGVuZENoaWxkKHNraXBCdXR0b24pO1xuICAgIHBsYXllci5vbigndGltZXVwZGF0ZScsIHVwZGF0ZVNraXBCdXR0b24pO1xuXG4gICAgcGxheWVyVXRpbHMub25jZShwbGF5ZXIsIFsndmFzdC5hZEVuZCcsICd2YXN0LmFkc0NhbmNlbCddLCByZW1vdmVTa2lwQnV0dG9uKTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZVNraXBCdXR0b24oKSB7XG4gICAgICBwbGF5ZXIub2ZmKCd0aW1ldXBkYXRlJywgdXBkYXRlU2tpcEJ1dHRvbik7XG4gICAgICBkb20ucmVtb3ZlKHNraXBCdXR0b24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNraXBCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIHNraXBCdXR0b24gPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkb20uYWRkQ2xhc3Moc2tpcEJ1dHRvbiwgXCJ2YXN0LXNraXAtYnV0dG9uXCIpO1xuICAgIHNraXBCdXR0b24uaWQgPSAnYWRTa2lwQnV0dG9uJztcblxuICAgIHNraXBCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZG9tLmhhc0NsYXNzKHNraXBCdXR0b24sICdlbmFibGVkJykpIHtcbiAgICAgICAgICBpZiAod2luZG93Lk1vYXRBcGlSZWZlcmVuY2UpIHtcbiAgICAgICAgXHQgIHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlLmRpc3BhdGNoRXZlbnQoe3R5cGU6ICdBZFNraXBwZWQnLCBhZFZvbHVtZTogcGxheWVyLnZvbHVtZSgpfSk7XG4gICAgICAgICAgfVxuICAgICAgICB0cmFja2VyLnRyYWNrU2tpcCgpO1xuICAgICAgICBwbGF5ZXIudHJpZ2dlcigndmFzdC5hZFNraXAnKTtcbiAgICAgIH1cbiAgICAgIHBsYXllclV0aWxzLnNob3dCaWdQbGF5QnV0dG9uKHBsYXllciwgZmFsc2UpO1xuXG4gICAgICAvL1dlIHByZXZlbnQgZXZlbnQgcHJvcGFnYXRpb24gdG8gYXZvaWQgcHJvYmxlbXMgd2l0aCB0aGUgY2xpY2tUaHJvdWdoIGFuZCBzbyBvblxuICAgICAgaWYgKHdpbmRvdy5FdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHNraXBCdXR0b247XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTa2lwQnV0dG9uU3RhdGUoc2tpcEJ1dHRvbiwgc2tpcE9mZnNldCwgcGxheWVyKSB7XG4gICAgdmFyIHRpbWVMZWZ0ID0gTWF0aC5jZWlsKHNraXBPZmZzZXQgLSBwbGF5ZXIuY3VycmVudFRpbWUoKSk7XG4gICAgaWYgKHRpbWVMZWZ0ID4gMCkge1xuICAgICAgICAvL3NraXBCdXR0b24uaW5uZXJIVE1MID0gXCJTa2lwIGluIFwiICsgdXRpbGl0aWVzLnRvRml4ZWREaWdpdHModGltZUxlZnQsIDIpICsgXCIuLi5cIjtcbiAgICAgICAgc2tpcEJ1dHRvbi5pbm5lckhUTUwgPSAnPHAgY2xhc3M9XCJ2YXN0LXNraXAtYnV0dG9uLXRleHRcIj4nICsgd2luZG93Ll9tb2xTZXR0aW5ncy5za2lwVGV4dC5yZXBsYWNlKCclJVRJTUUlJScsIHV0aWxpdGllcy50b0ZpeGVkRGlnaXRzKHRpbWVMZWZ0LCAyKSkgKyAnPC9wPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZG9tLmhhc0NsYXNzKHNraXBCdXR0b24sICdlbmFibGVkJykpIHtcbiAgICAgICAgZG9tLmFkZENsYXNzKHNraXBCdXR0b24sICdlbmFibGVkJyk7XG4gICAgICAgIC8vc2tpcEJ1dHRvbi5pbm5lckhUTUwgPSBcIlNraXAgYWRcIjtcbiAgICAgICAgc2tpcEJ1dHRvbi5pbm5lckhUTUwgPSB3aW5kb3cuX21vbFNldHRpbmdzLnNraXBCdXR0b25UZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaWZyYW1lQmFja0J1dHRvbiA9IHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWZyYW1lQmFja0J1dHRvbicpO1xuICAgIGlmICghaWZyYW1lQmFja0J1dHRvbikge1xuICAgICAgICBza2lwQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cbiAgfVxufTtcblxuVkFTVEludGVncmF0b3IucHJvdG90eXBlLl9hZGRDbGlja1Rocm91Z2ggPSBmdW5jdGlvbiBhZGRDbGlja1Rocm91Z2gobWVkaWFGaWxlLCB0cmFja2VyLCByZXNwb25zZSwgY2FsbGJhY2spIHtcbiAgdmFyIGVuYWJsZUZ1bGxzY3JlZW5DbGlja0lGcmFtZSA9IHRoaXMuZW5hYmxlRnVsbHNjcmVlbkNsaWNrSUZyYW1lO1xuICBcbiAgdmFyIHBsYXllciA9IHRoaXMucGxheWVyO1xuICB2YXIgYmxvY2tlciA9IGNyZWF0ZUNsaWNrVGhyb3VnaEJsb2NrZXIocGxheWVyLCB0cmFja2VyLCByZXNwb25zZSk7XG4gIHZhciB1cGRhdGVCbG9ja2VyID0gdXBkYXRlQmxvY2tlclVSTC5iaW5kKHRoaXMsIGJsb2NrZXIsIHJlc3BvbnNlLCBwbGF5ZXIpO1xuXG4gIHBsYXllci5lbCgpLmluc2VydEJlZm9yZShibG9ja2VyLCBwbGF5ZXIuY29udHJvbEJhci5lbCgpKTtcbiAgcGxheWVyLm9uKCd0aW1ldXBkYXRlJywgdXBkYXRlQmxvY2tlcik7XG4gIHBsYXllclV0aWxzLm9uY2UocGxheWVyLCBbJ3Zhc3QuYWRFbmQnLCAndmFzdC5hZHNDYW5jZWwnXSwgcmVtb3ZlQmxvY2tlcik7XG4gIFxuICBpZiAoZW5hYmxlRnVsbHNjcmVlbkNsaWNrSUZyYW1lKSB7XG5cdCAgcGxheWVyLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgdXBkYXRlRGlzcGxheVN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhudWxsLCBtZWRpYUZpbGUsIHRyYWNrZXIsIHJlc3BvbnNlKTtcblxuICAvKioqIExvY2FsIEZ1bmN0aW9ucyAqKiovXG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2xpY2tUaHJvdWdoQmxvY2tlcihwbGF5ZXIsIHRyYWNrZXIsIHJlc3BvbnNlKSB7XG5cdFx0aWYgKHdpbmRvdy5fbW9sU2V0dGluZ3MuZGlzYWJsZUNsaWNrVGhydSkge1xuXHRcdCAgICB2YXIgYmxvY2tlckRpdiA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdCAgICBkb20uYWRkQ2xhc3MoYmxvY2tlckRpdiwgJ3Zhc3QtYmxvY2tlcicpO1xuXHRcdFx0cmV0dXJuIGJsb2NrZXJEaXY7XG5cdFx0fVxuICAgIHZhciBibG9ja2VyID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIHZhciBjbGlja1Rocm91Z2hNYWNybyA9IHJlc3BvbnNlLmNsaWNrVGhyb3VnaDtcblxuICAgIGRvbS5hZGRDbGFzcyhibG9ja2VyLCAndmFzdC1ibG9ja2VyJyk7XG4gICAgYmxvY2tlci5ocmVmID0gZ2VuZXJhdGVDbGlja1Rocm91Z2hVUkwoY2xpY2tUaHJvdWdoTWFjcm8sIHBsYXllcik7XG5cbiAgICBpZiAodXRpbGl0aWVzLmlzU3RyaW5nKGNsaWNrVGhyb3VnaE1hY3JvKSkge1xuICAgICAgYmxvY2tlci50YXJnZXQgPSBcIl9ibGFua1wiO1xuICAgIH1cblxuICAgIHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChwbGF5ZXIucGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHBsYXllci5wbGF5KCk7XG5cbiAgICAgICAgICAgIC8vV2UgcHJldmVudCBldmVudCBwcm9wYWdhdGlvbiB0byBhdm9pZCBwcm9ibGVtcyB3aXRoIHRoZSBwbGF5ZXIncyBub3JtYWwgcGF1c2UgbWVjaGFuaXNtXG4gICAgICAgICAgICBpZiAod2luZG93LkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgICBwbGF5ZXIucGF1c2UoKTtcbiAgICAgICAgICB0cmFja2VyLnRyYWNrQ2xpY2soKTtcblxuICAgICAgICAgIGlmICh3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZSkge1xuICAgICAgICBcdCAgd2luZG93Lk1vYXRBcGlSZWZlcmVuY2UuZGlzcGF0Y2hFdmVudCh7dHlwZTogJ0FkQ2xpY2tUaHJ1JywgYWRWb2x1bWU6IHBsYXllci52b2x1bWUoKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXRpbGl0aWVzLmlzSURldmljZSgpKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5vcGVuKGdlbmVyYXRlQ2xpY2tUaHJvdWdoVVJMKGNsaWNrVGhyb3VnaE1hY3JvLCBwbGF5ZXIpLCAnX2JsYW5rJyk7XG4gICAgICAgICAgICAgIGlmICh3aW5kb3cuRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgIH07XG4gIFxuICAgIGlmICh1dGlsaXRpZXMuaXNJRGV2aWNlKCkpIHtcbiAgICAgICAgYmxvY2tlci5vbnRvdWNoZW5kID0gY2xpY2tIYW5kbGVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYmxvY2tlci5vbmNsaWNrID0gY2xpY2tIYW5kbGVyO1xuICAgIH1cbiAgICBcbiAgICBpZiAocGxheWVyLmlzRnVsbHNjcmVlbigpICYmIGVuYWJsZUZ1bGxzY3JlZW5DbGlja0lGcmFtZSkge1xuICAgIFx0YmxvY2tlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIHJldHVybiBibG9ja2VyO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQmxvY2tlclVSTChibG9ja2VyLCByZXNwb25zZSwgcGxheWVyKSB7XG4gICAgYmxvY2tlci5ocmVmID0gZ2VuZXJhdGVDbGlja1Rocm91Z2hVUkwocmVzcG9uc2UuY2xpY2tUaHJvdWdoLCBwbGF5ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVDbGlja1Rocm91Z2hVUkwoY2xpY2tUaHJvdWdoTWFjcm8sIHBsYXllcikge1xuICAgIHZhciB2YXJpYWJsZXMgPSB7XG4gICAgICBBU1NFVFVSSTogbWVkaWFGaWxlLnNyYyxcbiAgICAgIENPTlRFTlRQTEFZSEVBRDogdmFzdFV0aWwuZm9ybWF0UHJvZ3Jlc3MocGxheWVyLmN1cnJlbnRUaW1lKCkgKiAxMDAwKVxuICAgIH07XG5cbiAgICByZXR1cm4gY2xpY2tUaHJvdWdoTWFjcm8gPyB2YXN0VXRpbC5wYXJzZVVSTE1hY3JvKGNsaWNrVGhyb3VnaE1hY3JvLCB2YXJpYWJsZXMpIDogJyMnO1xuICB9XG4gIFxuICBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5U3R5bGUoKSB7XG5cdCAgYmxvY2tlci5zdHlsZS5kaXNwbGF5ID0gcGxheWVyLmlzRnVsbHNjcmVlbigpID8gJ25vbmUnIDogJ2Jsb2NrJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUJsb2NrZXIoKSB7XG4gICAgcGxheWVyLm9mZigndGltZXVwZGF0ZScsIHVwZGF0ZUJsb2NrZXIpO1xuXHRwbGF5ZXIub2ZmKCdmdWxsc2NyZWVuY2hhbmdlJywgdXBkYXRlRGlzcGxheVN0eWxlKTtcbiAgICBkb20ucmVtb3ZlKGJsb2NrZXIpO1xuICB9XG59O1xuXG5WQVNUSW50ZWdyYXRvci5wcm90b3R5cGUuX2FkZENsaWNrVGhyb3VnaERpdkJsb2NrZXIgPSBmdW5jdGlvbiBhZGRDbGlja1Rocm91Z2gobWVkaWFGaWxlLCB0cmFja2VyLCByZXNwb25zZSwgY2FsbGJhY2spIHtcblx0aWYgKCF0aGlzLmVuYWJsZUZ1bGxzY3JlZW5DbGlja0lGcmFtZSkge1xuXHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBtZWRpYUZpbGUsIHRyYWNrZXIsIHJlc3BvbnNlKTtcblx0fVxuXHR2YXIgcGxheWVyID0gdGhpcy5wbGF5ZXI7XG5cdCAgdmFyIGJsb2NrZXIgPSBjcmVhdGVDbGlja1Rocm91Z2hEaXYocGxheWVyLCB0cmFja2VyLCByZXNwb25zZSk7XG5cdCAgdmFyIHVwZGF0ZUJsb2NrZXIgPSB1cGRhdGVCbG9ja2VyVVJMLmJpbmQodGhpcywgYmxvY2tlciwgcmVzcG9uc2UsIHBsYXllcik7XG5cdCAgdmFyIGJsb2NrZXJVcmw7XG5cdCAgdmFyIGlGcmFtZTtcblx0ICB2YXIgaUZyYW1lQmFja0J1dHRvbjtcblxuXHQgIHBsYXllci5lbCgpLmluc2VydEJlZm9yZShibG9ja2VyLCBwbGF5ZXIuY29udHJvbEJhci5lbCgpKTtcblx0ICBwbGF5ZXIub24oJ3RpbWV1cGRhdGUnLCB1cGRhdGVCbG9ja2VyKTtcblx0ICBwbGF5ZXJVdGlscy5vbmNlKHBsYXllciwgWyd2YXN0LmFkRW5kJywgJ3Zhc3QuYWRzQ2FuY2VsJ10sIHJlbW92ZUJsb2NrZXIpO1xuXG5cdCAgcGxheWVyLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgdXBkYXRlRGlzcGxheVN0eWxlKTtcblxuXHQgIHJldHVybiBjYWxsYmFjayhudWxsLCBtZWRpYUZpbGUsIHRyYWNrZXIsIHJlc3BvbnNlKTtcblx0XG5cdCAgZnVuY3Rpb24gY3JlYXRlQ2xpY2tUaHJvdWdoRGl2KHBsYXllciwgdHJhY2tlcikge1xuXHQgICAgdmFyIGJsb2NrZXIgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHQgICAgZG9tLmFkZENsYXNzKGJsb2NrZXIsICd2YXN0LWJsb2NrZXInKTtcblxuXHRcdGlmICghd2luZG93Ll9tb2xTZXR0aW5ncy5kaXNhYmxlQ2xpY2tUaHJ1KSB7XG5cdFx0ICAgIGJsb2NrZXIub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0ICAgICAgaWYgKHBsYXllci5wYXVzZWQoKSkge1xuXHRcdCAgICAgICAgcGxheWVyLnBsYXkoKTtcblx0XG5cdFx0ICAgICAgICAvL1dlIHByZXZlbnQgZXZlbnQgcHJvcGFnYXRpb24gdG8gYXZvaWQgcHJvYmxlbXMgd2l0aCB0aGUgcGxheWVyJ3Mgbm9ybWFsIHBhdXNlIG1lY2hhbmlzbVxuXHRcdCAgICAgICAgaWYgKHdpbmRvdy5FdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICB9XG5cdFxuXHRcdCAgICAgIHBsYXllci5wYXVzZSgpO1xuXHRcdCAgICAgIHRyYWNrZXIudHJhY2tDbGljaygpO1xuXHRcblx0XHQgICAgICBpZiAod2luZG93Lk1vYXRBcGlSZWZlcmVuY2UpIHtcblx0XHQgICAgXHQgIHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlLmRpc3BhdGNoRXZlbnQoe3R5cGU6ICdBZENsaWNrVGhydScsIGFkVm9sdW1lOiBwbGF5ZXIudm9sdW1lKCl9KTtcblx0XHQgICAgICB9XG5cdFx0ICAgICAgXG5cdFx0ICAgICAgLy8gY3JlYXRlIElGcmFtZSB3aXRoIGJhY2sgYnV0dG9uXG5cdFx0ICAgICAgaUZyYW1lID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG5cdFx0XHQgIGRvbS5hZGRDbGFzcyhpRnJhbWUsICd2YXN0LWJsb2NrZXInKTtcblx0XHRcdCAgaUZyYW1lLnNyYyA9IGJsb2NrZXJVcmw7XG5cdFx0XHQgIGJsb2NrZXIuYXBwZW5kQ2hpbGQoaUZyYW1lKTtcblx0XHRcdCAgXG5cdFx0XHQgIGlGcmFtZUJhY2tCdXR0b24gPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdCAgZG9tLmFkZENsYXNzKGlGcmFtZUJhY2tCdXR0b24sIFwidmFzdC1iYWNrLWJ1dHRvblwiKTtcblx0XHQgICAgICBkb20uYWRkQ2xhc3MoaUZyYW1lQmFja0J1dHRvbiwgJ2VuYWJsZWQnKTtcblx0XHRcdCAgaUZyYW1lQmFja0J1dHRvbi5pbm5lckhUTUwgPSBcIkJhY2tcIjtcblx0XHRcdCAgaUZyYW1lQmFja0J1dHRvbi5pZCA9ICdpZnJhbWVCYWNrQnV0dG9uJztcblx0XHRcdCAgYmxvY2tlci5hcHBlbmRDaGlsZChpRnJhbWVCYWNrQnV0dG9uKTtcblx0XHRcdCAgaUZyYW1lQmFja0J1dHRvbi5hZGRFdmVudExpc3RlbmVyIChcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQgIGJsb2NrZXIucmVtb3ZlQ2hpbGQoaUZyYW1lKTtcblx0XHRcdFx0ICBpRnJhbWUgPSBudWxsO1xuXHRcdFx0XHQgIGJsb2NrZXIucmVtb3ZlQ2hpbGQoaUZyYW1lQmFja0J1dHRvbik7XG5cdFx0XHRcdCAgaUZyYW1lQmFja0J1dHRvbiA9IG51bGw7XG5cdFxuXHRcdFx0XHQgIC8vIHNob3cgY29udHJvbHNcblx0XHRcdFx0ICB2YXIgc2tpcEJ1dHRvbiA9IHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWRTa2lwQnV0dG9uJyk7XG5cdFx0XHRcdCAgaWYgKHNraXBCdXR0b24pIHtcblx0XHRcdFx0XHQgIHNraXBCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7IFxuXHRcdFx0XHQgIH1cblx0XHRcdFx0ICBwbGF5ZXIuY29udHJvbHModHJ1ZSk7XG5cdFx0XHRcdCAgXG5cdFx0XHRcdCAgaWYgKHdpbmRvdy5FdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdCAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHQgIH1cblx0XHRcdCAgfSk7XG5cdFx0XHQgIFxuXHRcdFx0ICAvLyBoaWRlIGNvbnRyb2xzXG5cdFx0XHQgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCAgcGxheWVyVXRpbHMuc2hvd0JpZ1BsYXlCdXR0b24ocGxheWVyLCBmYWxzZSk7XG5cdFx0XHQgIH0sIDEpO1xuXHRcdFx0ICB2YXIgc2tpcEJ1dHRvbiA9IHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWRTa2lwQnV0dG9uJyk7XG5cdFx0XHQgIGlmIChza2lwQnV0dG9uKSB7XG5cdFx0XHRcdCAgc2tpcEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyBcblx0XHRcdCAgfVxuXHRcdFx0ICBwbGF5ZXIuY29udHJvbHMoZmFsc2UpO1xuXHRcblx0XHQgICAgfTtcblx0XHR9XG5cblx0ICAgIGlmICghcGxheWVyLmlzRnVsbHNjcmVlbigpKSB7XG5cdCAgICBcdGJsb2NrZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGJsb2NrZXI7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdXBkYXRlQmxvY2tlclVSTChibG9ja2VyLCByZXNwb25zZSwgcGxheWVyKSB7XG5cdFx0ICBibG9ja2VyVXJsID0gZ2VuZXJhdGVDbGlja1Rocm91Z2hVUkwocmVzcG9uc2UuY2xpY2tUaHJvdWdoLCBwbGF5ZXIpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGdlbmVyYXRlQ2xpY2tUaHJvdWdoVVJMKGNsaWNrVGhyb3VnaE1hY3JvLCBwbGF5ZXIpIHtcblx0ICAgIHZhciB2YXJpYWJsZXMgPSB7XG5cdCAgICAgIEFTU0VUVVJJOiBtZWRpYUZpbGUuc3JjLFxuXHQgICAgICBDT05URU5UUExBWUhFQUQ6IHZhc3RVdGlsLmZvcm1hdFByb2dyZXNzKHBsYXllci5jdXJyZW50VGltZSgpICogMTAwMClcblx0ICAgIH07XG5cblx0ICAgIHJldHVybiBjbGlja1Rocm91Z2hNYWNybyA/IHZhc3RVdGlsLnBhcnNlVVJMTWFjcm8oY2xpY2tUaHJvdWdoTWFjcm8sIHZhcmlhYmxlcykgOiAnIyc7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheVN0eWxlKCkge1xuXHRcdCAgYmxvY2tlci5zdHlsZS5kaXNwbGF5ID0gcGxheWVyLmlzRnVsbHNjcmVlbigpID8gJ2Jsb2NrJyA6ICdub25lJztcblx0XHQgIGlmICghcGxheWVyLmlzRnVsbHNjcmVlbigpICYmIGlGcmFtZSkge1xuXHRcdFx0ICBibG9ja2VyLnJlbW92ZUNoaWxkKGlGcmFtZSk7XG5cdFx0XHQgIGlGcmFtZSA9IG51bGw7XG5cdFx0XHQgIGJsb2NrZXIucmVtb3ZlQ2hpbGQoaUZyYW1lQmFja0J1dHRvbik7XG5cdFx0XHQgIGlGcmFtZUJhY2tCdXR0b24gPSBudWxsO1xuXHRcdFx0ICBcblx0XHRcdCAgcGxheWVyVXRpbHMuc2hvd0JpZ1BsYXlCdXR0b24ocGxheWVyLCB0cnVlKTtcblx0XHRcdCAgdmFyIHNraXBCdXR0b24gPSB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkU2tpcEJ1dHRvbicpO1xuXHRcdFx0ICBpZiAoc2tpcEJ1dHRvbikge1xuXHRcdFx0XHQgIHNraXBCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJzsgXG5cdFx0XHQgIH1cblx0XHRcdCAgcGxheWVyLmNvbnRyb2xzKHRydWUpO1xuXHRcdCAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHJlbW92ZUJsb2NrZXIoKSB7XG5cdCAgICBwbGF5ZXIub2ZmKCd0aW1ldXBkYXRlJywgdXBkYXRlQmxvY2tlcik7XG5cdFx0cGxheWVyLm9mZignZnVsbHNjcmVlbmNoYW5nZScsIHVwZGF0ZURpc3BsYXlTdHlsZSk7XG5cdCAgICBkb20ucmVtb3ZlKGJsb2NrZXIpO1xuXHQgIH1cbn07XG5cblZBU1RJbnRlZ3JhdG9yLnByb3RvdHlwZS5fcGxheVNlbGVjdGVkQWQgPSBmdW5jdGlvbiBwbGF5U2VsZWN0ZWRBZChzb3VyY2UsIHJlc3BvbnNlLCBjYWxsYmFjaykge1xuICB2YXIgcGxheWVyID0gdGhpcy5wbGF5ZXI7XG5cbiAgLy93aW5kb3cuTW9hdEFwaVJlZmVyZW5jZSA9IG51bGw7XG5cbiAgcGxheWVyLnByZWxvYWQoXCJhdXRvXCIpOyAvL3dpdGhvdXQgcHJlbG9hZD1hdXRvIHRoZSBkdXJhdGlvbmNoYW5nZSBldmVudCBpcyBuZXZlciBmaXJlZFxuICBwbGF5ZXIuc3JjKHNvdXJjZSk7XG5cbiAgbG9nZ2VyLmRlYnVnIChcIjxWQVNUSW50ZWdyYXRvci5fcGxheVNlbGVjdGVkQWQ+IHdhaXRpbmcgZm9yIGR1cmF0aW9uY2hhbmdlIHRvIHBsYXkgdGhlIGFkLi4uXCIpO1xuXG4gIHBsYXllclV0aWxzLm9uY2UocGxheWVyLCBbJ2R1cmF0aW9uY2hhbmdlJywgJ2Vycm9yJywgJ3Zhc3QuYWRzQ2FuY2VsJ10sIGZ1bmN0aW9uIChldnQpIHtcbiAgICBpZiAoZXZ0LnR5cGUgPT09ICdkdXJhdGlvbmNoYW5nZScpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyAoXCI8VkFTVEludGVncmF0b3IuX3BsYXlTZWxlY3RlZEFkPiBnb3QgZHVyYXRpb25jaGFuZ2U7IGNhbGxpbmcgcGxheUFkKClcIik7XG4gICAgICBwbGF5QWQoKTtcbiAgICB9IGVsc2UgaWYoZXZ0LnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBWQVNURXJyb3IoXCJvbiBWQVNUSW50ZWdyYXRvciwgUGxheWVyIGlzIHVuYWJsZSB0byBwbGF5IHRoZSBBZFwiLCA0MDApLCByZXNwb25zZSk7XG4gICAgfVxuICAgIC8vTk9URTogSWYgdGhlIGFkcyBnZXQgY2FuY2VsZWQgd2UgZG8gbm90aGluZy9cbiAgfSk7XG5cbiAgLyoqKiogbG9jYWwgZnVuY3Rpb25zICoqKioqKi9cbiAgZnVuY3Rpb24gcGxheUFkKCkge1xuXG4gICAgcGxheWVyVXRpbHMub25jZShwbGF5ZXIsIFsncGxheWluZycsICd2YXN0LmFkc0NhbmNlbCddLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZihldnQudHlwZSA9PT0gJ3Zhc3QuYWRzQ2FuY2VsJyl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLypDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNiBNb2F0IEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC4qL1xuICAgICAgLypmdW5jdGlvbiBpbml0TW9hdFRyYWNraW5nKGEsYyxkLGgsayl7dmFyIGY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSxiPVtdO2M9e2FkRGF0YTp7aWRzOmMsZHVyYXRpb246ZCx1cmw6a30sZGlzcGF0Y2hFdmVudDpmdW5jdGlvbihhKXt0aGlzLnNlbmRFdmVudD8oYiYmKGIucHVzaChhKSxhPWIsYj0hMSksdGhpcy5zZW5kRXZlbnQoYSkpOmIucHVzaChhKX19O2Q9XCJfbW9hdEFwaVwiK01hdGguZmxvb3IoMUU4Kk1hdGgucmFuZG9tKCkpO3ZhciBlLGc7dHJ5e2U9YS5vd25lckRvY3VtZW50LGc9ZS5kZWZhdWx0Vmlld3x8ZS5wYXJlbnRXaW5kb3d9Y2F0Y2gobCl7ZT1kb2N1bWVudCxnPXdpbmRvd31nW2RdPWM7Zi50eXBlPVwidGV4dC9qYXZhc2NyaXB0XCI7YSYmYS5pbnNlcnRCZWZvcmUoZixhLmNoaWxkTm9kZXNbMF18fG51bGwpO2Yuc3JjPVwiaHR0cHM6Ly96Lm1vYXRhZHMuY29tL1wiK2grXCIvbW9hdHZpZGVvLmpzI1wiK2Q7cmV0dXJuIGN9O1xuICAgICAgd2luZG93Lk1vYXRBcGlSZWZlcmVuY2UgPSBudWxsO1xuICAgICAgaWYgKHJlc3BvbnNlLmFkcyAmJiByZXNwb25zZS5hZHMubGVuZ3RoID4gMCAmJiByZXNwb25zZS5hZHNbMF0uaW5MaW5lICYmIHJlc3BvbnNlLmFkc1swXS5pbkxpbmUubW9hdCkge1xuICAgIFx0ICB2YXIgaWRzID0ge2xldmVsMTogcmVzcG9uc2UuYWRzWzBdLmluTGluZS5tb2F0LmFkdmlkLFxuICAgIFx0XHRcdCAgICAgbGV2ZWwyOiByZXNwb25zZS5hZHNbMF0uaW5MaW5lLm1vYXQuY3BnaWQsXG4gICAgXHRcdFx0ICAgICBsZXZlbDM6IHJlc3BvbnNlLmFkc1swXS5pbkxpbmUubW9hdC5jcGlkLFxuICAgIFx0XHRcdCAgICAgbGV2ZWw0OiByZXNwb25zZS5hZHNbMF0uaW5MaW5lLm1vYXQuY3JpZH07XG4gICAgXHQgIGlmIChyZXNwb25zZS5hZHNbMF0uaW5MaW5lLm1vYXQuc2l0ZV9pZCkge1xuICAgIFx0XHQgIGlkcy5zbGljZXIxID0gcmVzcG9uc2UuYWRzWzBdLmluTGluZS5tb2F0LnNpdGVfaWQ7XG4gICAgXHQgIH1cbiAgICBcdCAgd2luZG93Lk1vYXRBcGlSZWZlcmVuY2UgPSBpbml0TW9hdFRyYWNraW5nKHBsYXllci5lbF8sIGlkcywgcGxheWVyLmR1cmF0aW9uKCksIHJlc3BvbnNlLmFkc1swXS5pbkxpbmUubW9hdC5wYXJ0bmVyY29kZSwgcGxheWVyLmN1cnJlbnRTb3VyY2UoKS5zcmMpO1xuICAgIFx0ICAvL3dpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlID0gaW5pdE1vYXRUcmFja2luZyhwbGF5ZXIuZWxfLCBpZHMsIHBsYXllci5kdXJhdGlvbigpLCAnbmluZW1lZGlhdnBhaWQ3ODk2MTE2NCcsIHBsYXllci5jdXJyZW50U291cmNlKCkuc3JjKTtcbiAgICAgIH1cbiAgICAgIGlmICh3aW5kb3cuX21vbFNldHRpbmdzLnZpZXdhYmlsaXR5VHJhY2tpbmcpIHtcbiAgICBcdCAgd2luZG93Ll9tb2xTZXR0aW5ncy52aWV3YWJpbGl0eVRyYWNraW5nLmluaXQod2luZG93Ll9tb2xTZXR0aW5ncy52aWV3YWJpbGl0eS5jb250ZXh0SWQsIFxuICAgIFx0XHRcdCAgcGxheWVyLmR1cmF0aW9uKCksIHBsYXllci5lbF8ub2Zmc2V0V2lkdGgsIHBsYXllci5lbF8ub2Zmc2V0SGVpZ2h0KTtcbiAgICAgIH0qL1xuICAgICAgXG4gICAgICBsb2dnZXIuZGVidWcgKFwiPFZBU1RJbnRlZ3JhdG9yLl9wbGF5U2VsZWN0ZWRBZC9wbGF5QWQ+IGdvdCBwbGF5aW5nIGV2ZW50OyB0cmlnZ2VyaW5nIHZhc3QuYWRTdGFydC4uLlwiKTtcblxuICAgICAgcGxheWVyLnRyaWdnZXIoJ3Zhc3QuYWRTdGFydCcpO1xuXG4gICAgICBpZiAodXRpbGl0aWVzLmlzTW9iaWxlKCkpIHtcbiAgICAgICAgICAvLyBWSURMQS0yMzM2IChzaW11bGF0ZSB1c2VyIGFjdGl2aXR5IHRvIG1ha2Ugc3VyZSBjb250cm9sLWJhciBpcyB2aXNpYmxlIG9uIG1vYmlsZSBkZXZpY2VzKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgXHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIFx0XHRwbGF5ZXIudXNlckFjdGl2ZSh0cnVlKTtcbiAgICAgICAgICBcdH0sIGkgKiAyMDAwKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZSkge1xuICAgIFx0ICB3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZS5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnQWRWaWRlb1N0YXJ0JywgYWRWb2x1bWU6IHBsYXllci52b2x1bWUoKX0pO1xuICAgICAgfVxuXG4gICAgICBwbGF5ZXIub24oJ2VuZGVkJywgcHJvY2VlZCk7XG4gICAgICBwbGF5ZXIub24oJ3Zhc3QuYWRzQ2FuY2VsJywgcHJvY2VlZCk7XG4gICAgICBwbGF5ZXIub24oJ3Zhc3QuYWRTa2lwJywgcHJvY2VlZCk7XG5cbiAgICAgIGZ1bmN0aW9uIHByb2NlZWQoZXZ0KSB7XG5cbiAgICAgICAgICBpZihldnQudHlwZSA9PT0gJ2VuZGVkJykge1xuICAgICAgICAgICAgICAvLyBJZ25vcmUgZW5kZWQgZXZlbnQgaWYgdGhlIEFkIHRpbWUgd2FzIG5vdCAnbmVhcicgdGhlIGVuZFxuICAgICAgICAgICAgICAvLyBhdm9pZHMgaXNzdWVzIHdoZXJlIElPUyBjb250cm9scyBjb3VsZCBza2lwIHRoZSBBZFxuICAgICAgICAgICAgXHRpZiAod2luZG93Ll9tb2xTZXR0aW5ncy5icmVha0R1cmF0aW9uKSB7XG4gICAgICAgICAgICBcdFx0aWYgKHdpbmRvdy5fbW9sU2V0dGluZ3MucmVhbFZpZGVvRHVyYXRpb24pIHtcbiAgICAgICAgICAgIFx0XHQgICAgaWYgKCh3aW5kb3cuX21vbFNldHRpbmdzLnJlYWxWaWRlb0R1cmF0aW9uIC0gcGxheWVyLmN1cnJlbnRUaW1lKCkpID4gMykge1xuICAgICAgICAgICAgXHRcdCAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXHRcdCAgICB9XG4gICAgICAgICAgICBcdFx0fVxuICAgICAgICAgICAgXHR9XG4gICAgICAgICAgICBcdGVsc2UgaWYgKChwbGF5ZXIuZHVyYXRpb24oKSAtIHBsYXllci5jdXJyZW50VGltZSgpKSA+IDMpIHtcbiAgICBcdFx0XHRcdHJldHVybjtcbiAgICBcdFx0XHR9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgLyppZihldnQudHlwZSA9PT0gJ2VuZGVkJyAmJiAocGxheWVyLmR1cmF0aW9uKCkgLSBwbGF5ZXIuY3VycmVudFRpbWUoKSkgPiAzICkge1xuICAgICAgICAgIC8vIElnbm9yZSBlbmRlZCBldmVudCBpZiB0aGUgQWQgdGltZSB3YXMgbm90ICduZWFyJyB0aGUgZW5kXG4gICAgICAgICAgLy8gYXZvaWRzIGlzc3VlcyB3aGVyZSBJT1MgY29udHJvbHMgY291bGQgc2tpcCB0aGUgQWRcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0qL1xuXG4gICAgICAgIHBsYXllci5vZmYoJ2VuZGVkJywgcHJvY2VlZCk7XG4gICAgICAgIHBsYXllci5vZmYoJ3Zhc3QuYWRzQ2FuY2VsJywgcHJvY2VlZCk7XG4gICAgICAgIHBsYXllci5vZmYoJ3Zhc3QuYWRTa2lwJywgcHJvY2VlZCk7XG5cbiAgICAgICAgLy9OT1RFOiBpZiB0aGUgYWRzIGdldCBjYW5jZWwgd2UgZG8gbm90aGluZyBhcGFydCByZW1vdmluZyB0aGUgbGlzdG5lcnNcbiAgICAgICAgaWYoZXZ0LnR5cGUgPT09ICdlbmRlZCcgfHwgZXZ0LnR5cGUgPT09ICd2YXN0LmFkU2tpcCcpe1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbG9nZ2VyLmRlYnVnIChcIjxWQVNUSW50ZWdyYXRvci5fcGxheVNlbGVjdGVkQWQvcGxheUFkPiBjYWxsaW5nIHBsYXllci5wbGF5KCkuLi5cIik7XG5cbiAgICBwbGF5ZXIucGxheSgpO1xuICB9XG59O1xuXG5WQVNUSW50ZWdyYXRvci5wcm90b3R5cGUuX3RyYWNrRXJyb3IgPSBmdW5jdGlvbiB0cmFja0Vycm9yKGVycm9yLCByZXNwb25zZSkge1xuICB2YXN0VXRpbC50cmFjayhyZXNwb25zZS5lcnJvclVSTE1hY3Jvcywge0VSUk9SQ09ERTogZXJyb3IuY29kZSB8fCA5MDB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVkFTVEludGVncmF0b3I7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWQgPSByZXF1aXJlKCcuL0FkJyk7XG52YXIgVmlkZW9DbGlja3MgPSByZXF1aXJlKCcuL1ZpZGVvQ2xpY2tzJyk7XG52YXIgTGluZWFyID0gcmVxdWlyZSgnLi9MaW5lYXInKTtcbnZhciBJbkxpbmUgPSByZXF1aXJlKCcuL0luTGluZScpO1xudmFyIFdyYXBwZXIgPSByZXF1aXJlKCcuL1dyYXBwZXInKTtcblxudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3V0aWxpdHlGdW5jdGlvbnMnKTtcbi8vdmFyIHhtbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3htbCcpO1xuXG53aW5kb3cuSW5MaW5lX19BID0gSW5MaW5lO1xuZnVuY3Rpb24gVkFTVFJlc3BvbnNlKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVkFTVFJlc3BvbnNlKSkge1xuICAgIHJldHVybiBuZXcgVkFTVFJlc3BvbnNlKCk7XG4gIH1cblxuICB0aGlzLl9saW5lYXJBZGRlZCA9IGZhbHNlO1xuICB0aGlzLnZhc3RWZXJzaW9uID0gdW5kZWZpbmVkO1xuICB0aGlzLmFkcyA9IFtdO1xuICB0aGlzLmVycm9yVVJMTWFjcm9zID0gW107XG4gIHRoaXMuaW1wcmVzc2lvbnMgPSBbXTtcbiAgdGhpcy5jbGlja1RyYWNraW5ncyA9IFtdO1xuICB0aGlzLmN1c3RvbUNsaWNrcyA9IFtdO1xuICB0aGlzLnRyYWNraW5nRXZlbnRzID0ge307XG4gIHRoaXMubWVkaWFGaWxlcyA9IFtdO1xuICB0aGlzLmNsaWNrVGhyb3VnaCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5hZFRpdGxlID0gJyc7XG4gIHRoaXMuZHVyYXRpb24gPSB1bmRlZmluZWQ7XG4gIHRoaXMuc2tpcG9mZnNldCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pY29ucyA9IFtdO1xufVxuXG5WQVNUUmVzcG9uc2UucHJvdG90eXBlLmFkZEFkID0gZnVuY3Rpb24gKGFkKSB7XG4gIHZhciBpbkxpbmUsIHdyYXBwZXI7XG4gIGlmIChhZCBpbnN0YW5jZW9mIEFkKSB7XG4gICAgaW5MaW5lID0gYWQuaW5MaW5lO1xuICAgIHdyYXBwZXIgPSBhZC53cmFwcGVyO1xuXG4gICAgdGhpcy5hZHMucHVzaChhZCk7XG5cbiAgICBpZiAoaW5MaW5lKSB7XG4gICAgICB0aGlzLl9hZGRJbkxpbmUoaW5MaW5lKTtcbiAgICB9XG5cbiAgICBpZiAod3JhcHBlcikge1xuICAgICAgdGhpcy5fYWRkV3JhcHBlcih3cmFwcGVyKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qVkFTVFJlc3BvbnNlLnByb3RvdHlwZS5fYWRkRXJyb3JUcmFja1VybCA9IGZ1bmN0aW9uIChlcnJvcikge1xuXHQgIHZhciBlcnJvclVSTCA9IGVycm9yIGluc3RhbmNlb2YgeG1sLkpYT05UcmVlID8geG1sLmtleVZhbHVlKGVycm9yKSA6IGVycm9yO1xuXHQgIGlmIChlcnJvclVSTCkge1xuXHQgICAgdGhpcy5lcnJvclVSTE1hY3Jvcy5wdXNoKGVycm9yVVJMKTtcblx0ICB9XG5cdH07Ki9cblZBU1RSZXNwb25zZS5wcm90b3R5cGUuX2FkZEVycm9yVHJhY2tVcmxzID0gZnVuY3Rpb24gKGVycm9ycykge1xuXHQgIHV0aWxpdGllcy5pc0FycmF5KGVycm9ycykgJiYgYXBwZW5kVG9BcnJheSh0aGlzLmVycm9yVVJMTWFjcm9zLCBlcnJvcnMpO1xuXHR9O1xuXG5WQVNUUmVzcG9uc2UucHJvdG90eXBlLl9hZGRJbXByZXNzaW9ucyA9IGZ1bmN0aW9uIChpbXByZXNzaW9ucykge1xuICB1dGlsaXRpZXMuaXNBcnJheShpbXByZXNzaW9ucykgJiYgYXBwZW5kVG9BcnJheSh0aGlzLmltcHJlc3Npb25zLCBpbXByZXNzaW9ucyk7XG59O1xuXG5WQVNUUmVzcG9uc2UucHJvdG90eXBlLl9hZGRDbGlja1Rocm91Z2ggPSBmdW5jdGlvbiAoY2xpY2tUaHJvdWdoKSB7XG4gIGlmICh1dGlsaXRpZXMuaXNOb3RFbXB0eVN0cmluZyhjbGlja1Rocm91Z2gpKSB7XG4gICAgdGhpcy5jbGlja1Rocm91Z2ggPSBjbGlja1Rocm91Z2g7XG4gIH1cbn07XG5cblZBU1RSZXNwb25zZS5wcm90b3R5cGUuX2FkZENsaWNrVHJhY2tpbmdzID0gZnVuY3Rpb24gKGNsaWNrVHJhY2tpbmdzKSB7XG4gIHV0aWxpdGllcy5pc0FycmF5KGNsaWNrVHJhY2tpbmdzKSAmJiBhcHBlbmRUb0FycmF5KHRoaXMuY2xpY2tUcmFja2luZ3MsIGNsaWNrVHJhY2tpbmdzKTtcbn07XG5cblZBU1RSZXNwb25zZS5wcm90b3R5cGUuX2FkZEN1c3RvbUNsaWNrcyA9IGZ1bmN0aW9uIChjdXN0b21DbGlja3MpIHtcbiAgdXRpbGl0aWVzLmlzQXJyYXkoY3VzdG9tQ2xpY2tzKSAmJiBhcHBlbmRUb0FycmF5KHRoaXMuY3VzdG9tQ2xpY2tzLCBjdXN0b21DbGlja3MpO1xufTtcblxuVkFTVFJlc3BvbnNlLnByb3RvdHlwZS5fYWRkVHJhY2tpbmdFdmVudHMgPSBmdW5jdGlvbiAodHJhY2tpbmdFdmVudHMpIHtcbiAgdmFyIGV2ZW50c01hcCA9IHRoaXMudHJhY2tpbmdFdmVudHM7XG5cbiAgaWYgKHRyYWNraW5nRXZlbnRzKSB7XG4gICAgdHJhY2tpbmdFdmVudHMgPSB1dGlsaXRpZXMuaXNBcnJheSh0cmFja2luZ0V2ZW50cykgPyB0cmFja2luZ0V2ZW50cyA6IFt0cmFja2luZ0V2ZW50c107XG4gICAgdHJhY2tpbmdFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tpbmdFdmVudCkge1xuICAgICAgaWYgKCFldmVudHNNYXBbdHJhY2tpbmdFdmVudC5uYW1lXSkge1xuICAgICAgICBldmVudHNNYXBbdHJhY2tpbmdFdmVudC5uYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgZXZlbnRzTWFwW3RyYWNraW5nRXZlbnQubmFtZV0ucHVzaCh0cmFja2luZ0V2ZW50KTtcbiAgICB9KTtcbiAgfVxufTtcblxuVkFTVFJlc3BvbnNlLnByb3RvdHlwZS5fYWRkVGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgaWYgKHV0aWxpdGllcy5pc05vdEVtcHR5U3RyaW5nKHRpdGxlKSkge1xuICAgIHRoaXMuYWRUaXRsZSA9IHRpdGxlO1xuICB9XG59O1xuXG5WQVNUUmVzcG9uc2UucHJvdG90eXBlLl9hZGREdXJhdGlvbiA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICBpZiAodXRpbGl0aWVzLmlzTnVtYmVyKGR1cmF0aW9uKSkge1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgfVxufTtcblxuVkFTVFJlc3BvbnNlLnByb3RvdHlwZS5fYWRkVmlkZW9DbGlja3MgPSBmdW5jdGlvbiAodmlkZW9DbGlja3MpIHtcbiAgaWYgKHZpZGVvQ2xpY2tzIGluc3RhbmNlb2YgVmlkZW9DbGlja3MpIHtcbiAgICB0aGlzLl9hZGRDbGlja1Rocm91Z2godmlkZW9DbGlja3MuY2xpY2tUaHJvdWdoKTtcbiAgICB0aGlzLl9hZGRDbGlja1RyYWNraW5ncyh2aWRlb0NsaWNrcy5jbGlja1RyYWNraW5ncyk7XG4gICAgdGhpcy5fYWRkQ3VzdG9tQ2xpY2tzKHZpZGVvQ2xpY2tzLmN1c3RvbUNsaWNrcyk7XG4gIH1cbn07XG5cblZBU1RSZXNwb25zZS5wcm90b3R5cGUuX2FkZE1lZGlhRmlsZXMgPSBmdW5jdGlvbiAobWVkaWFGaWxlcykge1xuICB1dGlsaXRpZXMuaXNBcnJheShtZWRpYUZpbGVzKSAmJiBhcHBlbmRUb0FycmF5KHRoaXMubWVkaWFGaWxlcywgbWVkaWFGaWxlcyk7XG59O1xuXG5WQVNUUmVzcG9uc2UucHJvdG90eXBlLl9hZGRTa2lwb2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuXHQgIGlmICh3aW5kb3cuX21vbFNldHRpbmdzICYmIHdpbmRvdy5fbW9sU2V0dGluZ3Muc2tpcHBhYmxlKSB7XG5cdFx0ICBpZiAod2luZG93Ll9tb2xTZXR0aW5ncy5za2lwcGFibGUuZW5hYmxlZCkge1xuXHRcdFx0ICBpZiAoIXRoaXMuZHVyYXRpb24gfHwgIXdpbmRvdy5fbW9sU2V0dGluZ3Muc2tpcHBhYmxlLnZpZGVvVGhyZXNob2xkIHx8IHRoaXMuZHVyYXRpb24gPj0gd2luZG93Ll9tb2xTZXR0aW5ncy5za2lwcGFibGUudmlkZW9UaHJlc2hvbGQpIHtcblx0XHRcdFx0ICB0aGlzLnNraXBvZmZzZXQgPSB3aW5kb3cuX21vbFNldHRpbmdzLnNraXBwYWJsZS52aWRlb09mZnNldDtcblx0XHRcdCAgfVxuXHRcdCAgfVxuXHQgIH1cblx0ICBlbHNlIGlmIChvZmZzZXQpIHtcblx0ICAgIHRoaXMuc2tpcG9mZnNldCA9IG9mZnNldDtcblx0ICB9XG59O1xuXG5WQVNUUmVzcG9uc2UucHJvdG90eXBlLl9hZGRBZFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoYWRQYXJhbWV0ZXJzKSB7XG4gIGlmIChhZFBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLmFkUGFyYW1ldGVycyA9IGFkUGFyYW1ldGVycztcbiAgfVxufTtcblxuVkFTVFJlc3BvbnNlLnByb3RvdHlwZS5fYWRkSWNvbnMgPSBmdW5jdGlvbiAoaWNvbnMpIHtcbiAgdXRpbGl0aWVzLmlzQXJyYXkoaWNvbnMpICYmIGFwcGVuZFRvQXJyYXkodGhpcy5pY29ucywgaWNvbnMpO1xufTtcblxuVkFTVFJlc3BvbnNlLnByb3RvdHlwZS5fYWRkTGluZWFyID0gZnVuY3Rpb24gKGxpbmVhcikge1xuICBpZiAobGluZWFyIGluc3RhbmNlb2YgTGluZWFyKSB7XG4gICAgdGhpcy5fYWRkRHVyYXRpb24obGluZWFyLmR1cmF0aW9uKTtcbiAgICB0aGlzLl9hZGRUcmFja2luZ0V2ZW50cyhsaW5lYXIudHJhY2tpbmdFdmVudHMpO1xuICAgIHRoaXMuX2FkZFZpZGVvQ2xpY2tzKGxpbmVhci52aWRlb0NsaWNrcyk7XG4gICAgdGhpcy5fYWRkTWVkaWFGaWxlcyhsaW5lYXIubWVkaWFGaWxlcyk7XG4gICAgdGhpcy5fYWRkU2tpcG9mZnNldChsaW5lYXIuc2tpcG9mZnNldCk7XG4gICAgdGhpcy5fYWRkQWRQYXJhbWV0ZXJzKGxpbmVhci5hZFBhcmFtZXRlcnMpO1xuICAgIHRoaXMuX2FkZEljb25zKGxpbmVhci5pY29ucyk7XG4gICAgdGhpcy5fbGluZWFyQWRkZWQgPSB0cnVlO1xuICB9XG59O1xuXG5WQVNUUmVzcG9uc2UucHJvdG90eXBlLl9hZGRJbkxpbmUgPSBmdW5jdGlvbiAoaW5MaW5lKSB7XG4gIHZhciB0aGF0ID0gdGhpcztcblxuICBpZiAoaW5MaW5lIGluc3RhbmNlb2YgSW5MaW5lKSB7XG4gICAgdGhpcy5fYWRkVGl0bGUoaW5MaW5lLmFkVGl0bGUpO1xuICAgIHRoaXMuX2FkZEVycm9yVHJhY2tVcmxzKGluTGluZS5lcnJvcnMpO1xuICAgIHRoaXMuX2FkZEltcHJlc3Npb25zKGluTGluZS5pbXByZXNzaW9ucyk7XG5cbiAgICBpbkxpbmUuY3JlYXRpdmVzLmZvckVhY2goZnVuY3Rpb24gKGNyZWF0aXZlKSB7XG4gICAgICBpZiAoY3JlYXRpdmUubGluZWFyKSB7XG4gICAgICAgIHRoYXQuX2FkZExpbmVhcihjcmVhdGl2ZS5saW5lYXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5WQVNUUmVzcG9uc2UucHJvdG90eXBlLl9hZGRXcmFwcGVyID0gZnVuY3Rpb24gKHdyYXBwZXIpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgV3JhcHBlcikge1xuICAgIHRoaXMuX2FkZEVycm9yVHJhY2tVcmxzKHdyYXBwZXIuZXJyb3JzKTtcbiAgICB0aGlzLl9hZGRJbXByZXNzaW9ucyh3cmFwcGVyLmltcHJlc3Npb25zKTtcblxuICAgIHdyYXBwZXIuY3JlYXRpdmVzLmZvckVhY2goZnVuY3Rpb24gKGNyZWF0aXZlKSB7XG4gICAgICB2YXIgbGluZWFyID0gY3JlYXRpdmUubGluZWFyO1xuICAgICAgaWYgKGxpbmVhcikge1xuICAgICAgICB0aGF0Ll9hZGRWaWRlb0NsaWNrcyhsaW5lYXIudmlkZW9DbGlja3MpO1xuICAgICAgICB0aGF0LmNsaWNrVGhyb3VnaCA9IHVuZGVmaW5lZDsvL1dlIGVuc3VyZSB0aGF0IG5vIGNsaWNrVGhyb3VnaCBoYXMgYmVlbiBhZGRlZFxuICAgICAgICB0aGF0Ll9hZGRUcmFja2luZ0V2ZW50cyhsaW5lYXIudHJhY2tpbmdFdmVudHMpO1xuICAgICAgICB0aGF0Ll9hZGRJY29ucyhsaW5lYXIuaWNvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5WQVNUUmVzcG9uc2UucHJvdG90eXBlLmhhc0xpbmVhciA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLl9saW5lYXJBZGRlZDtcbn07XG5cbmZ1bmN0aW9uIGFwcGVuZFRvQXJyYXkoYXJyYXksIGl0ZW1zKSB7XG4gIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgYXJyYXkucHVzaChpdGVtKTtcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZBU1RSZXNwb25zZTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVkFTVEVycm9yID0gcmVxdWlyZSgnLi9WQVNURXJyb3InKTtcbnZhciBWQVNUUmVzcG9uc2UgPSByZXF1aXJlKCcuL1ZBU1RSZXNwb25zZScpO1xudmFyIHZhc3RVdGlsID0gcmVxdWlyZSgnLi92YXN0VXRpbCcpO1xudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3V0aWxpdHlGdW5jdGlvbnMnKTtcblxuZnVuY3Rpb24gVkFTVFRyYWNrZXIoYXNzZXRVUkksIHZhc3RSZXNwb25zZSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVkFTVFRyYWNrZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBWQVNUVHJhY2tlcihhc3NldFVSSSwgdmFzdFJlc3BvbnNlKTtcbiAgfVxuXG4gIHRoaXMuc2FuaXR5Q2hlY2soYXNzZXRVUkksIHZhc3RSZXNwb25zZSk7XG4gIHRoaXMuaW5pdGlhbGl6ZShhc3NldFVSSSwgdmFzdFJlc3BvbnNlKTtcblxufVxuXG5WQVNUVHJhY2tlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGFzc2V0VVJJLCB2YXN0UmVzcG9uc2UpIHtcbiAgdGhpcy5yZXNwb25zZSA9IHZhc3RSZXNwb25zZTtcbiAgdGhpcy5hc3NldFVSSSA9IGFzc2V0VVJJO1xuICB0aGlzLnByb2dyZXNzID0gMDtcbiAgdGhpcy5xdWFydGlsZXMgPSB7XG4gICAgZmlyc3RRdWFydGlsZToge3RyYWNrZWQ6IGZhbHNlLCB0aW1lOiBNYXRoLnJvdW5kKDI1ICogdmFzdFJlc3BvbnNlLmR1cmF0aW9uKSAvIDEwMH0sXG4gICAgbWlkcG9pbnQ6IHt0cmFja2VkOiBmYWxzZSwgdGltZTogTWF0aC5yb3VuZCg1MCAqIHZhc3RSZXNwb25zZS5kdXJhdGlvbikgLyAxMDB9LFxuICAgIHRoaXJkUXVhcnRpbGU6IHt0cmFja2VkOiBmYWxzZSwgdGltZTogTWF0aC5yb3VuZCg3NSAqIHZhc3RSZXNwb25zZS5kdXJhdGlvbikgLyAxMDB9XG4gIH07XG59O1xuXG5WQVNUVHJhY2tlci5wcm90b3R5cGUuc2FuaXR5Q2hlY2sgPSBmdW5jdGlvbihhc3NldFVSSSwgdmFzdFJlc3BvbnNlKSB7XG4gIGlmICghdXRpbGl0aWVzLmlzU3RyaW5nKGFzc2V0VVJJKSB8fCB1dGlsaXRpZXMuaXNFbXB0eVN0cmluZyhhc3NldFVSSSkpIHtcbiAgICB0aHJvdyBuZXcgVkFTVEVycm9yKCdvbiBWQVNUVHJhY2tlciBjb25zdHJ1Y3RvciwgbWlzc2luZyByZXF1aXJlZCB0aGUgVVJJIG9mIHRoZSBhZCBhc3NldCBiZWluZyBwbGF5ZWQnKTtcbiAgfVxuXG4gIGlmICghKHZhc3RSZXNwb25zZSBpbnN0YW5jZW9mIFZBU1RSZXNwb25zZSkpIHtcbiAgICB0aHJvdyBuZXcgVkFTVEVycm9yKCdvbiBWQVNUVHJhY2tlciBjb25zdHJ1Y3RvciwgbWlzc2luZyByZXF1aXJlZCBWQVNUIHJlc3BvbnNlJyk7XG4gIH1cbn07XG5cblZBU1RUcmFja2VyLnByb3RvdHlwZS50cmFja1VSTHMgPSBmdW5jdGlvbiB0cmFja1VSTHModXJscywgdmFyaWFibGVzKSB7XG4gIGlmICh1dGlsaXRpZXMuaXNBcnJheSh1cmxzKSAmJiB1cmxzLmxlbmd0aCA+IDApIHtcbiAgICB2YXJpYWJsZXMgPSB1dGlsaXRpZXMuZXh0ZW5kKHtcbiAgICAgIEFTU0VUVVJJOiB0aGlzLmFzc2V0VVJJLFxuICAgICAgQ09OVEVOVFBMQVlIRUFEOiB2YXN0VXRpbC5mb3JtYXRQcm9ncmVzcyh0aGlzLnByb2dyZXNzKVxuICAgIH0sIHZhcmlhYmxlcyB8fCB7fSk7XG5cbiAgICB2YXN0VXRpbC50cmFjayh1cmxzLCB2YXJpYWJsZXMpO1xuICB9XG59O1xuXG5WQVNUVHJhY2tlci5wcm90b3R5cGUudHJhY2tFdmVudCA9IGZ1bmN0aW9uIHRyYWNrRXZlbnQoZXZlbnROYW1lLCB0cmFja09uY2UpIHtcbiAgICBpZiAodGhpcy5yZXNwb25zZS50cmFja2luZ0V2ZW50c1tldmVudE5hbWVdICYmIHdpbmRvdy5fbW9sU2V0dGluZ3Mudmlld2FiaWxpdHlUcmFja2luZykge1xuICAgIFx0ICB3aW5kb3cuX21vbFNldHRpbmdzLnZpZXdhYmlsaXR5VHJhY2tpbmcuaW52b2tlRXZlbnQoZXZlbnROYW1lKTtcbiAgICB9XG4gIHRoaXMudHJhY2tVUkxzKGdldEV2ZW50VXJpcyh0aGlzLnJlc3BvbnNlLnRyYWNraW5nRXZlbnRzW2V2ZW50TmFtZV0pKTtcbiAgaWYgKHRyYWNrT25jZSkge1xuICAgIHRoaXMucmVzcG9uc2UudHJhY2tpbmdFdmVudHNbZXZlbnROYW1lXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKiogTG9jYWwgZnVuY3Rpb24gKioqL1xuICBmdW5jdGlvbiBnZXRFdmVudFVyaXModHJhY2tpbmdFdmVudHMpIHtcbiAgICB2YXIgdXJpcztcblxuICAgIGlmICh0cmFja2luZ0V2ZW50cykge1xuICAgICAgdXJpcyA9IFtdO1xuICAgICAgdHJhY2tpbmdFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoIWV2ZW50LnVyaSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXJpcy5wdXNoKGV2ZW50LnVyaSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaXM7XG4gIH1cbn07XG5cblZBU1RUcmFja2VyLnByb3RvdHlwZS50cmFja1Byb2dyZXNzID0gZnVuY3Rpb24gdHJhY2tQcm9ncmVzcyhuZXdQcm9ncmVzc0luTXMpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIgZXZlbnRzID0gW107XG4gIHZhciBPTkNFID0gdHJ1ZTtcbiAgdmFyIEFMV0FZUyA9IGZhbHNlO1xuICB2YXIgdHJhY2tpbmdFdmVudHMgPSB0aGlzLnJlc3BvbnNlLnRyYWNraW5nRXZlbnRzO1xuXG4gIGlmICh1dGlsaXRpZXMuaXNOdW1iZXIobmV3UHJvZ3Jlc3NJbk1zKSkge1xuICAgIGFkZFRyYWNrRXZlbnQoJ3N0YXJ0JywgT05DRSwgbmV3UHJvZ3Jlc3NJbk1zID4gMCk7XG4gICAgYWRkVHJhY2tFdmVudCgncmV3aW5kJywgQUxXQVlTLCBoYXNSZXdvdW5kKHRoaXMucHJvZ3Jlc3MsIG5ld1Byb2dyZXNzSW5NcykpO1xuICAgIGFkZFF1YXJ0aWxlRXZlbnRzKG5ld1Byb2dyZXNzSW5Ncyk7XG4gICAgdHJhY2tQcm9ncmVzc0V2ZW50cyhuZXdQcm9ncmVzc0luTXMpO1xuICAgIHRyYWNrRXZlbnRzKCk7XG4gICAgdGhpcy5wcm9ncmVzcyA9IG5ld1Byb2dyZXNzSW5NcztcbiAgfVxuXG4gIC8qKiogTG9jYWwgZnVuY3Rpb24gKioqL1xuICBmdW5jdGlvbiBoYXNSZXdvdW5kKGN1cnJlbnRQcm9ncmVzcywgbmV3UHJvZ3Jlc3MpIHtcbiAgICB2YXIgUkVXSU5EX1RIUkVTSE9MRCA9IDMwMDA7IC8vSU9TIHZpZGVvIGNsb2NrIGlzIHZlcnkgdW5yZWxpYWJsZSBhbmQgd2UgbmVlZCBhIDMgc2Vjb25kcyB0aHJlc2hvbGQgdG8gZW5zdXJlIHRoYXQgdGhlcmUgd2FzIGEgcmV3aW5kIGFuIHRoYXQgaXQgd2FzIG9uIHB1cnBvc2UuXG4gICAgcmV0dXJuIGN1cnJlbnRQcm9ncmVzcyA+IG5ld1Byb2dyZXNzSW5NcyAmJiBNYXRoLmFicyhuZXdQcm9ncmVzcyAtIGN1cnJlbnRQcm9ncmVzcykgPiBSRVdJTkRfVEhSRVNIT0xEO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkVHJhY2tFdmVudChldmVudE5hbWUsIHRyYWNrT25jZSwgY2FuQmVBZGRlZCkge1xuICAgIGlmICh0cmFja2luZ0V2ZW50c1tldmVudE5hbWVdICYmIGNhbkJlQWRkZWQpIHtcbiAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICB0cmFja09uY2U6ICEhdHJhY2tPbmNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRRdWFydGlsZUV2ZW50cyhwcm9ncmVzcykge1xuICAgIHZhciBxdWFydGlsZXMgPSB0aGF0LnF1YXJ0aWxlcztcbiAgICB2YXIgZmlyc3RRdWFydGlsZSA9IHRoYXQucXVhcnRpbGVzLmZpcnN0UXVhcnRpbGU7XG4gICAgdmFyIG1pZHBvaW50ID0gdGhhdC5xdWFydGlsZXMubWlkcG9pbnQ7XG4gICAgdmFyIHRoaXJkUXVhcnRpbGUgPSB0aGF0LnF1YXJ0aWxlcy50aGlyZFF1YXJ0aWxlO1xuXG4gICAgaWYgKCFmaXJzdFF1YXJ0aWxlLnRyYWNrZWQpIHtcbiAgICAgIHRyYWNrUXVhcnRpbGUoJ2ZpcnN0UXVhcnRpbGUnLCBwcm9ncmVzcyk7XG4gICAgfSBlbHNlIGlmICghbWlkcG9pbnQudHJhY2tlZCkge1xuICAgICAgdHJhY2tRdWFydGlsZSgnbWlkcG9pbnQnLCBwcm9ncmVzcyk7XG4gICAgfSBlbHNlIGlmICghdGhpcmRRdWFydGlsZS50cmFja2VkKXtcbiAgICAgIHRyYWNrUXVhcnRpbGUoJ3RoaXJkUXVhcnRpbGUnLCBwcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLyoqKiBMb2NhbCBmdW5jdGlvbiAqKiovXG4gICAgZnVuY3Rpb24gdHJhY2tRdWFydGlsZShxdWFydGlsZU5hbWUsIHByb2dyZXNzKXtcbiAgICAgIHZhciBxdWFydGlsZSA9IHF1YXJ0aWxlc1txdWFydGlsZU5hbWVdO1xuICAgICAgaWYoY2FuQmVUcmFja2VkKHF1YXJ0aWxlLCBwcm9ncmVzcykpe1xuICAgICAgICBxdWFydGlsZS50cmFja2VkID0gdHJ1ZTtcbiAgICAgICAgYWRkVHJhY2tFdmVudChxdWFydGlsZU5hbWUsIE9OQ0UsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkJlVHJhY2tlZChxdWFydGlsZSwgcHJvZ3Jlc3MpIHtcbiAgICB2YXIgcXVhcnRpbGVUaW1lID0gcXVhcnRpbGUudGltZTtcbiAgICAvL1dlIG9ubHkgZmlyZSB0aGUgcXVhcnRpbGUgZXZlbnQgaWYgdGhlIHByb2dyZXNzIGlzIGJpZ2dlciB0aGFuIHRoZSBxdWFydGlsZSB0aW1lIGJ5IDUgc2Vjb25kcyBhdCBtb3N0LlxuICAgIHJldHVybiBwcm9ncmVzcyA+PSBxdWFydGlsZVRpbWUgJiYgcHJvZ3Jlc3MgPD0gKHF1YXJ0aWxlVGltZSArIDUwMDApO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhY2tQcm9ncmVzc0V2ZW50cyhwcm9ncmVzcykge1xuICAgIGlmICghdXRpbGl0aWVzLmlzQXJyYXkodHJhY2tpbmdFdmVudHMucHJvZ3Jlc3MpKSB7XG4gICAgICByZXR1cm47IC8vTm90aGluZyB0byB0cmFja1xuICAgIH1cblxuICAgIHZhciBwZW5kaW5nUHJvZ3Jlc3NFdnRzID0gW107XG5cbiAgICB0cmFja2luZ0V2ZW50cy5wcm9ncmVzcy5mb3JFYWNoKGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGlmIChldnQub2Zmc2V0IDw9IHByb2dyZXNzKSB7XG4gICAgICAgIHRoYXQudHJhY2tVUkxzKFtldnQudXJpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nUHJvZ3Jlc3NFdnRzLnB1c2goZXZ0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0cmFja2luZ0V2ZW50cy5wcm9ncmVzcyA9IHBlbmRpbmdQcm9ncmVzc0V2dHM7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFja0V2ZW50cygpIHtcbiAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHRoYXQudHJhY2tFdmVudChldmVudC5uYW1lLCBldmVudC50cmFja09uY2UpO1xuICAgIH0pO1xuICB9XG59O1xuXG5bXG4gICdyZXdpbmQnLFxuICAnZnVsbHNjcmVlbicsXG4gICdleGl0RnVsbHNjcmVlbicsXG4gICdwYXVzZScsXG4gICdyZXN1bWUnLFxuICAnbXV0ZScsXG4gICd1bm11dGUnLFxuICAnYWNjZXB0SW52aXRhdGlvbicsXG4gICdhY2NlcHRJbnZpdGF0aW9uTGluZWFyJyxcbiAgJ2NvbGxhcHNlJyxcbiAgJ2V4cGFuZCdcbl0uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgVkFTVFRyYWNrZXIucHJvdG90eXBlWyd0cmFjaycgKyB1dGlsaXRpZXMuY2FwaXRhbGl6ZShldmVudE5hbWUpXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudHJhY2tFdmVudChldmVudE5hbWUpO1xuICAgIH07XG4gIH0pO1xuXG5bXG4gICdzdGFydCcsXG4gICdza2lwJyxcbiAgJ2Nsb3NlJyxcbiAgJ2Nsb3NlTGluZWFyJ1xuXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICBWQVNUVHJhY2tlci5wcm90b3R5cGVbJ3RyYWNrJyArIHV0aWxpdGllcy5jYXBpdGFsaXplKGV2ZW50TmFtZSldID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmFja0V2ZW50KGV2ZW50TmFtZSwgdHJ1ZSk7XG4gICAgfTtcbiAgfSk7XG5cbltcbiAgJ2ZpcnN0UXVhcnRpbGUnLFxuICAnbWlkcG9pbnQnLFxuICAndGhpcmRRdWFydGlsZSdcbl0uZm9yRWFjaChmdW5jdGlvbiAocXVhcnRpbGUpIHtcbiAgICBWQVNUVHJhY2tlci5wcm90b3R5cGVbJ3RyYWNrJyArIHV0aWxpdGllcy5jYXBpdGFsaXplKHF1YXJ0aWxlKV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnF1YXJ0aWxlc1txdWFydGlsZV0udHJhY2tlZCA9IHRydWU7XG4gICAgICB0aGlzLnRyYWNrRXZlbnQocXVhcnRpbGUsIHRydWUpO1xuICAgIH07XG4gIH0pO1xuXG5WQVNUVHJhY2tlci5wcm90b3R5cGUudHJhY2tDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYodGhpcy5xdWFydGlsZXMudGhpcmRRdWFydGlsZS50cmFja2VkKXtcbiAgICB0aGlzLnRyYWNrRXZlbnQoJ2NvbXBsZXRlJywgdHJ1ZSk7XG4gIH1cbn07XG5cblZBU1RUcmFja2VyLnByb3RvdHlwZS50cmFja0Vycm9yV2l0aENvZGUgPSBmdW5jdGlvbiB0cmFja0Vycm9yV2l0aENvZGUoZXJyb3Jjb2RlKSB7XG4gIGlmICh1dGlsaXRpZXMuaXNOdW1iZXIoZXJyb3Jjb2RlKSkge1xuICAgIHRoaXMudHJhY2tVUkxzKHRoaXMucmVzcG9uc2UuZXJyb3JVUkxNYWNyb3MsIHtFUlJPUkNPREU6IGVycm9yY29kZX0pO1xuICB9XG59O1xuXG5WQVNUVHJhY2tlci5wcm90b3R5cGUudHJhY2tJbXByZXNzaW9ucyA9IGZ1bmN0aW9uIHRyYWNrSW1wcmVzc2lvbnMoKSB7XG4gIHRoaXMudHJhY2tVUkxzKHRoaXMucmVzcG9uc2UuaW1wcmVzc2lvbnMpO1xufTtcblxuVkFTVFRyYWNrZXIucHJvdG90eXBlLnRyYWNrQ3JlYXRpdmVWaWV3ID0gZnVuY3Rpb24gdHJhY2tDcmVhdGl2ZVZpZXcoKSB7XG4gIHRoaXMudHJhY2tFdmVudCgnY3JlYXRpdmVWaWV3Jyk7XG59O1xuXG5WQVNUVHJhY2tlci5wcm90b3R5cGUudHJhY2tDbGljayA9IGZ1bmN0aW9uIHRyYWNrQ2xpY2soKSB7XG4gICAgaWYgKHdpbmRvdy5fbW9sU2V0dGluZ3Mudmlld2FiaWxpdHlUcmFja2luZykge1xuICBcdCAgd2luZG93Ll9tb2xTZXR0aW5ncy52aWV3YWJpbGl0eVRyYWNraW5nLmludm9rZUV2ZW50KCdhZC1jbGljaycpO1xuICAgIH1cbiAgdGhpcy50cmFja1VSTHModGhpcy5yZXNwb25zZS5jbGlja1RyYWNraW5ncyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZBU1RUcmFja2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgeG1sID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMveG1sJyk7XG52YXIgdmFzdFV0aWwgPSByZXF1aXJlKCcuL3Zhc3RVdGlsJyk7XG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXRpbGl0eUZ1bmN0aW9ucycpO1xuXG5mdW5jdGlvbiBWZXJpZmljYXRpb24odmVyaWZpY2F0aW9uSlRyZWUpIHtcbiAgaWYoISh0aGlzIGluc3RhbmNlb2YgVmVyaWZpY2F0aW9uKSkge1xuICAgIHJldHVybiBuZXcgVmVyaWZpY2F0aW9uKHZlcmlmaWNhdGlvbkpUcmVlKTtcbiAgfVxuXG4gIHRoaXMudmVuZG9yID0gdmVyaWZpY2F0aW9uSlRyZWUuYXR0cigndmVuZG9yJyk7XG4gIGlmICh2ZXJpZmljYXRpb25KVHJlZS5qYXZhU2NyaXB0UmVzb3VyY2UpIHtcblx0ICB0aGlzLmphdmFTY3JpcHRSZXNvdXJjZXMgPSBwYXJzZVJlc291cmNlcyh2ZXJpZmljYXRpb25KVHJlZS5qYXZhU2NyaXB0UmVzb3VyY2UpO1xuICB9XG4gIGlmICh2YXN0VXRpbC5pc0ZsYXNoU3VwcG9ydGVkKCkgJiYgdmVyaWZpY2F0aW9uSlRyZWUuZmxhc2hSZXNvdXJjZSkge1xuXHQgIHRoaXMuamF2YVNjcmlwdFJlc291cmNlcyA9IHBhcnNlUmVzb3VyY2VzKHZlcmlmaWNhdGlvbkpUcmVlLmphdmFTY3JpcHRSZXNvdXJjZSk7XG4gIH1cbiAgaWYgKHZlcmlmaWNhdGlvbkpUcmVlLnZpZXdhYmxlSW1wcmVzc2lvbikge1xuXHQgIHRoaXMudmlld2FibGVJbXByZXNzaW9uID0ge2lkOiB2ZXJpZmljYXRpb25KVHJlZS52aWV3YWJsZUltcHJlc3Npb24uYXR0cignaWQnKSwgdXJpOiB4bWwua2V5VmFsdWUodmVyaWZpY2F0aW9uSlRyZWUudmlld2FibGVJbXByZXNzaW9uKX07XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHBhcnNlUmVzb3VyY2VzKHJlc291cmNlcykge1xuXHQgIHZhciBhcnIgPSBbXTtcblx0ICB2YXIgYXJyRGF0YTtcblx0ICBpZiAocmVzb3VyY2VzKSB7XG5cdFx0ICBhcnJEYXRhID0gdXRpbGl0aWVzLmlzQXJyYXkocmVzb3VyY2VzKSA/IHJlc291cmNlcyA6IFtyZXNvdXJjZXNdO1xuXHRcdCAgYXJyRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtKSB7XG5cdFx0XHQgIGFyci5wdXNoKHthcGlGcmFtZXdvcms6IGVsZW0uYXR0cignYXBpRnJhbWV3b3JrJyksIHVyaTogeG1sLmtleVZhbHVlKGVsZW0pfSk7XG5cdFx0ICB9KTtcblx0ICB9XG5cdCAgcmV0dXJuIGFycjtcbiAgfVxufVxuXG5WZXJpZmljYXRpb24ucGFyc2VBZFZlcmlmaWNhdGlvbnMgPSBmdW5jdGlvbiBwYXJzZUFkVmVyaWZpY2F0aW9ucyh2ZXJpZmljYXRpb25zSlRyZWUpIHtcbiAgdmFyIHZlcmlmaWNhdGlvbnMgPSBbXTtcbiAgdmFyIHZlcmlmaWNhdGlvbnNEYXRhO1xuICBpZiAodXRpbGl0aWVzLmlzRGVmaW5lZCh2ZXJpZmljYXRpb25zSlRyZWUpICYmIHV0aWxpdGllcy5pc0RlZmluZWQodmVyaWZpY2F0aW9uc0pUcmVlLnZlcmlmaWNhdGlvbikpIHtcblx0ICB2ZXJpZmljYXRpb25zRGF0YSA9IHV0aWxpdGllcy5pc0FycmF5KHZlcmlmaWNhdGlvbnNKVHJlZS52ZXJpZmljYXRpb24pID8gdmVyaWZpY2F0aW9uc0pUcmVlLnZlcmlmaWNhdGlvbiA6IFt2ZXJpZmljYXRpb25zSlRyZWUudmVyaWZpY2F0aW9uXTtcblx0ICB2ZXJpZmljYXRpb25zRGF0YS5mb3JFYWNoKGZ1bmN0aW9uICh2ZXJpZmljYXRpb24pIHtcbiAgICBcdHZlcmlmaWNhdGlvbnMucHVzaChuZXcgVmVyaWZpY2F0aW9uKHZlcmlmaWNhdGlvbikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB2ZXJpZmljYXRpb25zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZXJpZmljYXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91dGlsaXR5RnVuY3Rpb25zJyk7XG52YXIgeG1sID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMveG1sJyk7XG5cbmZ1bmN0aW9uIFZpZGVvQ2xpY2tzKHZpZGVvQ2xpY2tKVHJlZSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVmlkZW9DbGlja3MpKSB7XG4gICAgcmV0dXJuIG5ldyBWaWRlb0NsaWNrcyh2aWRlb0NsaWNrSlRyZWUpO1xuICB9XG5cbiAgdGhpcy5jbGlja1Rocm91Z2ggPSB4bWwua2V5VmFsdWUodmlkZW9DbGlja0pUcmVlLmNsaWNrVGhyb3VnaCk7XG4gIHRoaXMuY2xpY2tUcmFja2luZ3MgPSBwYXJzZUNsaWNrVHJhY2tpbmdzKHZpZGVvQ2xpY2tKVHJlZS5jbGlja1RyYWNraW5nKTtcbiAgdGhpcy5jdXN0b21DbGlja3MgPSBwYXJzZUNsaWNrVHJhY2tpbmdzKHZpZGVvQ2xpY2tKVHJlZS5jdXN0b21DbGljayk7XG5cbiAgLyoqKiBMb2NhbCBmdW5jdGlvbnMgKioqL1xuICBmdW5jdGlvbiBwYXJzZUNsaWNrVHJhY2tpbmdzKHRyYWNraW5nRGF0YSkge1xuICAgIHZhciBjbGlja1RyYWNraW5ncyA9IFtdO1xuICAgIGlmICh0cmFja2luZ0RhdGEpIHtcbiAgICAgIHRyYWNraW5nRGF0YSA9IHV0aWxpdGllcy5pc0FycmF5KHRyYWNraW5nRGF0YSkgPyB0cmFja2luZ0RhdGEgOiBbdHJhY2tpbmdEYXRhXTtcbiAgICAgIHRyYWNraW5nRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChjbGlja1RyYWNraW5nRGF0YSkge1xuICAgICAgICBjbGlja1RyYWNraW5ncy5wdXNoKHhtbC5rZXlWYWx1ZShjbGlja1RyYWNraW5nRGF0YSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjbGlja1RyYWNraW5ncztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZGVvQ2xpY2tzOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHhtbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3htbCcpO1xudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3V0aWxpdHlGdW5jdGlvbnMnKTtcblxuZnVuY3Rpb24gVmlld2FibGVJbXByZXNzaW9uKHZpZXdhYmxlSW1wcmVzc2lvbkpUcmVlKSB7XG5cdCAgaWYoISh0aGlzIGluc3RhbmNlb2YgVmlld2FibGVJbXByZXNzaW9uKSkge1xuXHQgICAgcmV0dXJuIG5ldyBWaWV3YWJsZUltcHJlc3Npb24odmlld2FibGVJbXByZXNzaW9uSlRyZWUpO1xuXHQgIH1cblxuXHQgIC8vT3B0aW9uYWwgRmllbGRzXG5cdCAgdGhpcy5pZCA9IHZpZXdhYmxlSW1wcmVzc2lvbkpUcmVlLmF0dHIoJ2lkJyk7XG5cdCAgaWYgKHZpZXdhYmxlSW1wcmVzc2lvbkpUcmVlLnZpZXdhYmxlKSB7XG5cdFx0ICB0aGlzLnZpZXdhYmxlcyA9IHBhcnNlVXJpQXJyYXkodmlld2FibGVJbXByZXNzaW9uSlRyZWUudmlld2FibGUpO1xuXHQgIH1cblx0ICBpZiAodmlld2FibGVJbXByZXNzaW9uSlRyZWUubm90Vmlld2FibGUpIHtcblx0XHQgIHRoaXMubm90Vmlld2FibGVzID0gcGFyc2VVcmlBcnJheSh2aWV3YWJsZUltcHJlc3Npb25KVHJlZS5ub3RWaWV3YWJsZSk7XG5cdCAgfVxuXHQgIGlmICh2aWV3YWJsZUltcHJlc3Npb25KVHJlZS52aWV3VW5kZXRlcm1pbmVkKSB7XG5cdFx0ICB0aGlzLnZpZXdVbmRldGVybWluZWRzID0gcGFyc2VVcmlBcnJheSh2aWV3YWJsZUltcHJlc3Npb25KVHJlZS52aWV3VW5kZXRlcm1pbmVkKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBwYXJzZVVyaUFycmF5KGFyckpUcmVlKSB7XG5cdFx0ICB2YXIgYXJyID0gW107XG5cdFx0ICB2YXIgYXJyRGF0YTtcblx0XHQgIGlmIChhcnJKVHJlZSkge1xuXHRcdFx0ICBhcnJEYXRhID0gdXRpbGl0aWVzLmlzQXJyYXkoYXJySlRyZWUpID8gYXJySlRyZWUgOiBbYXJySlRyZWVdO1xuXHRcdFx0ICBhcnJEYXRhLmZvckVhY2goZnVuY3Rpb24gKGVsZW0pIHtcblx0XHRcdFx0ICBhcnIucHVzaCh4bWwua2V5VmFsdWUoZWxlbSkpO1xuXHRcdFx0ICB9KTtcblx0XHQgIH1cblx0XHQgIHJldHVybiBhcnI7XG5cdCB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld2FibGVJbXByZXNzaW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmFzdFV0aWwgPSByZXF1aXJlKCcuL3Zhc3RVdGlsJyk7XG52YXIgQ3JlYXRpdmUgPSByZXF1aXJlKCcuL0NyZWF0aXZlJyk7XG52YXIgVmlld2FibGVJbXByZXNzaW9uID0gcmVxdWlyZSgnLi9WaWV3YWJsZUltcHJlc3Npb24nKTtcbnZhciBWZXJpZmljYXRpb24gPSByZXF1aXJlKCcuL1ZlcmlmaWNhdGlvbicpO1xuXG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXRpbGl0eUZ1bmN0aW9ucycpO1xudmFyIHhtbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3htbCcpO1xuXG5mdW5jdGlvbiBXcmFwcGVyKHdyYXBwZXJKVHJlZSkge1xuICBpZighKHRoaXMgaW5zdGFuY2VvZiBXcmFwcGVyKSkge1xuICAgIHJldHVybiBuZXcgV3JhcHBlcih3cmFwcGVySlRyZWUpO1xuICB9XG5cbiAgLy9SZXF1aXJlZCBlbGVtZW50c1xuICB0aGlzLmFkU3lzdGVtID0geG1sLmtleVZhbHVlKHdyYXBwZXJKVHJlZS5hZFN5c3RlbSk7XG4gIHRoaXMuaW1wcmVzc2lvbnMgPSB2YXN0VXRpbC5wYXJzZUltcHJlc3Npb25zKHdyYXBwZXJKVHJlZS5pbXByZXNzaW9uKTtcbiAgdGhpcy5WQVNUQWRUYWdVUkkgPSB4bWwua2V5VmFsdWUod3JhcHBlckpUcmVlLnZBU1RBZFRhZ1VSSSk7XG5cbiAgLy9PcHRpb25hbCBlbGVtZW50c1xuICB0aGlzLmNyZWF0aXZlcyA9IENyZWF0aXZlLnBhcnNlQ3JlYXRpdmVzKHdyYXBwZXJKVHJlZS5jcmVhdGl2ZXMpO1xuICAvL3RoaXMuZXJyb3IgPSB4bWwua2V5VmFsdWUod3JhcHBlckpUcmVlLmVycm9yKTtcbiAgdGhpcy5lcnJvcnMgPSB2YXN0VXRpbC5wYXJzZUVycm9ycyh3cmFwcGVySlRyZWUuZXJyb3IpO1xuICB0aGlzLmV4dGVuc2lvbnMgPSB3cmFwcGVySlRyZWUuZXh0ZW5zaW9ucztcblxuICAvL09wdGlvbmFsIGF0dHJzXG4gIHRoaXMuZm9sbG93QWRkaXRpb25hbFdyYXBwZXJzID0gdXRpbGl0aWVzLmlzRGVmaW5lZCh4bWwuYXR0cih3cmFwcGVySlRyZWUsICdmb2xsb3dBZGRpdGlvbmFsV3JhcHBlcnMnKSk/IHhtbC5hdHRyKHdyYXBwZXJKVHJlZSwgJ2ZvbGxvd0FkZGl0aW9uYWxXcmFwcGVycycpOiB0cnVlO1xuICB0aGlzLmFsbG93TXVsdGlwbGVBZHMgPSB4bWwuYXR0cih3cmFwcGVySlRyZWUsICdhbGxvd011bHRpcGxlQWRzJyk7XG4gIHRoaXMuZmFsbGJhY2tPbk5vQWQgPSB4bWwuYXR0cih3cmFwcGVySlRyZWUsICdmYWxsYmFja09uTm9BZCcpO1xuXG4gIGlmICh3aW5kb3cubW9sX3Zhc3RWZXJzaW9uID09PSA0KSB7XG5cdCAgaWYgKHdyYXBwZXJKVHJlZS52aWV3YWJsZUltcHJlc3Npb24pIHtcblx0XHQgIHRoaXMudmlld2FibGVJbXByZXNzaW9uID0gbmV3IFZpZXdhYmxlSW1wcmVzc2lvbih3cmFwcGVySlRyZWUudmlld2FibGVJbXByZXNzaW9uKTtcblx0ICB9XG5cdCAgaWYgKHdyYXBwZXJKVHJlZS5hZFZlcmlmaWNhdGlvbnMpIHtcblx0XHQgIHRoaXMuYWRWZXJpZmljYXRpb25zID0gVmVyaWZpY2F0aW9uLnBhcnNlQWRWZXJpZmljYXRpb25zKHdyYXBwZXJKVHJlZS5hZFZlcmlmaWNhdGlvbnMpO1xuXHQgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyYXBwZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91dGlsaXR5RnVuY3Rpb25zJyk7XG5cbnZhciBkdXJhdGlvblJlZ2V4ID0gLyhcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpKFxcLihcXGRcXGRcXGQpKT8vO1xuXG52YXIgcGFyc2VycyA9IHtcblxuICBkdXJhdGlvbjogZnVuY3Rpb24gcGFyc2VEdXJhdGlvbihkdXJhdGlvblN0cikge1xuXG4gICAgdmFyIG1hdGNoLCBkdXJhdGlvbkluTXM7XG5cbiAgICBpZiAodXRpbGl0aWVzLmlzU3RyaW5nKGR1cmF0aW9uU3RyKSkge1xuICAgICAgbWF0Y2ggPSBkdXJhdGlvblN0ci5tYXRjaChkdXJhdGlvblJlZ2V4KTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBkdXJhdGlvbkluTXMgPSBwYXJzZUhvdXJzVG9NcyhtYXRjaFsxXSkgKyBwYXJzZU1pblRvTXMobWF0Y2hbMl0pICsgcGFyc2VTZWNUb01zKG1hdGNoWzNdKSArIHBhcnNlSW50KG1hdGNoWzVdIHx8IDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpc05hTihkdXJhdGlvbkluTXMpID8gbnVsbCA6IGR1cmF0aW9uSW5NcztcblxuICAgIC8qKiogbG9jYWwgZnVuY3Rpb25zICoqKi9cbiAgICBmdW5jdGlvbiBwYXJzZUhvdXJzVG9Ncyhob3VyU3RyKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoaG91clN0ciwgMTApICogNjAgKiA2MCAqIDEwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNaW5Ub01zKG1pblN0cikge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KG1pblN0ciwgMTApICogNjAgKiAxMDAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU2VjVG9NcyhzZWNTdHIpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChzZWNTdHIsIDEwKSAqIDEwMDA7XG4gICAgfVxuICB9LFxuXG4gIG9mZnNldDogZnVuY3Rpb24gcGFyc2VPZmZzZXQob2Zmc2V0LCBkdXJhdGlvbikge1xuICAgIGlmKGlzUGVyY2VudGFnZShvZmZzZXQpKXtcbiAgICAgIHJldHVybiBjYWxjdWxhdGVQZXJjZW50YWdlKG9mZnNldCwgZHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2Vycy5kdXJhdGlvbihvZmZzZXQpO1xuXG4gICAgLyoqKiBMb2NhbCBmdW5jdGlvbiAqKiovXG4gICAgZnVuY3Rpb24gaXNQZXJjZW50YWdlKG9mZnNldCkge1xuICAgICAgdmFyIHBlcmNlbnRhZ2VSZWdleCA9IC9eXFxkKyhcXC5cXGQrKT8lJC9nO1xuICAgICAgcmV0dXJuIHBlcmNlbnRhZ2VSZWdleC50ZXN0KG9mZnNldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlUGVyY2VudGFnZShwZXJjZW50U3RyLCBkdXJhdGlvbikge1xuICAgICAgaWYoZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGNhbGNQZXJjZW50KGR1cmF0aW9uLCBwYXJzZUZsb2F0KHBlcmNlbnRTdHIucmVwbGFjZSgnJScsICcnKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY1BlcmNlbnQocXVhbnRpdHksIHBlcmNlbnQpe1xuICAgICAgcmV0dXJuIHF1YW50aXR5ICogcGVyY2VudCAvIDEwMDtcbiAgICB9XG4gIH1cblxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlcnM7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXRpbGl0eUZ1bmN0aW9ucycpO1xudmFyIFZQQUlESFRNTDVUZWNoID0gcmVxdWlyZSgnLi4vdnBhaWQvVlBBSURIVE1MNVRlY2gnKTtcblxudmFyIHZhc3RVdGlsID0ge1xuXG4gIHRyYWNrOiBmdW5jdGlvbiB0cmFjayhVUkxNYWNyb3MsIHZhcmlhYmxlcykge1xuICAgIHZhciBzb3VyY2VzID0gdmFzdFV0aWwucGFyc2VVUkxNYWNyb3MoVVJMTWFjcm9zLCB2YXJpYWJsZXMpO1xuICAgIHZhciB0cmFja0ltZ3MgPSBbXTtcbiAgICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNyYykge1xuICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1nLnNyYyA9IHNyYztcbiAgICAgIHRyYWNrSW1ncy5wdXNoKGltZyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYWNrSW1ncztcbiAgfSxcblxuICBwYXJzZVVSTE1hY3JvczogZnVuY3Rpb24gcGFyc2VNYWNyb3MoVVJMTWFjcm9zLCB2YXJpYWJsZXMpIHtcbiAgICB2YXIgcGFyc2VkVVJMcyA9IFtdO1xuXG4gICAgdmFyaWFibGVzID0gdmFyaWFibGVzIHx8IHt9O1xuXG4gICAgaWYgKCEodmFyaWFibGVzW1wiQ0FDSEVCVVNUSU5HXCJdKSkge1xuICAgICAgdmFyaWFibGVzW1wiQ0FDSEVCVVNUSU5HXCJdID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMS4wZSsxMCk7XG4gICAgfVxuXG4gICAgVVJMTWFjcm9zLmZvckVhY2goZnVuY3Rpb24gKFVSTE1hY3JvKSB7XG4gICAgICBwYXJzZWRVUkxzLnB1c2godmFzdFV0aWwuX3BhcnNlVVJMTWFjcm8oVVJMTWFjcm8sIHZhcmlhYmxlcykpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhcnNlZFVSTHM7XG4gIH0sXG5cbiAgcGFyc2VVUkxNYWNybzogZnVuY3Rpb24gcGFyc2VNYWNybyhVUkxNYWNybywgdmFyaWFibGVzKSB7XG4gICAgdmFyaWFibGVzID0gdmFyaWFibGVzIHx8IHt9O1xuXG4gICAgaWYgKCEodmFyaWFibGVzW1wiQ0FDSEVCVVNUSU5HXCJdKSkge1xuICAgICAgdmFyaWFibGVzW1wiQ0FDSEVCVVNUSU5HXCJdID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMS4wZSsxMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhc3RVdGlsLl9wYXJzZVVSTE1hY3JvKFVSTE1hY3JvLCB2YXJpYWJsZXMpO1xuICB9LFxuXG4gIF9wYXJzZVVSTE1hY3JvOiBmdW5jdGlvbiBwYXJzZU1hY3JvKFVSTE1hY3JvLCB2YXJpYWJsZXMpIHtcbiAgICB2YXJpYWJsZXMgPSB2YXJpYWJsZXMgfHwge307XG5cbiAgICB1dGlsaXRpZXMuZm9yRWFjaCh2YXJpYWJsZXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBVUkxNYWNybyA9IFVSTE1hY3JvLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFxbXCIgKyBrZXkgKyBcIlxcXFxcXF1cIiwgJ2dtJyksIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBVUkxNYWNybztcbiAgfSxcblxuICBwYXJzZUR1cmF0aW9uOiBmdW5jdGlvbiBwYXJzZUR1cmF0aW9uKGR1cmF0aW9uU3RyKSB7XG4gICAgdmFyIGR1cmF0aW9uUmVnZXggPSAvKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkoXFwuKFxcZFxcZFxcZCkpPy87XG4gICAgdmFyIG1hdGNoLCBkdXJhdGlvbkluTXM7XG5cbiAgICBpZiAodXRpbGl0aWVzLmlzU3RyaW5nKGR1cmF0aW9uU3RyKSkge1xuICAgICAgbWF0Y2ggPSBkdXJhdGlvblN0ci5tYXRjaChkdXJhdGlvblJlZ2V4KTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBkdXJhdGlvbkluTXMgPSBwYXJzZUhvdXJzVG9NcyhtYXRjaFsxXSkgKyBwYXJzZU1pblRvTXMobWF0Y2hbMl0pICsgcGFyc2VTZWNUb01zKG1hdGNoWzNdKSArIHBhcnNlSW50KG1hdGNoWzVdIHx8IDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpc05hTihkdXJhdGlvbkluTXMpID8gbnVsbCA6IGR1cmF0aW9uSW5NcztcblxuICAgIC8qKiogbG9jYWwgZnVuY3Rpb25zICoqKi9cbiAgICBmdW5jdGlvbiBwYXJzZUhvdXJzVG9Ncyhob3VyU3RyKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoaG91clN0ciwgMTApICogNjAgKiA2MCAqIDEwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNaW5Ub01zKG1pblN0cikge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KG1pblN0ciwgMTApICogNjAgKiAxMDAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU2VjVG9NcyhzZWNTdHIpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChzZWNTdHIsIDEwKSAqIDEwMDA7XG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSW1wcmVzc2lvbnM6IGZ1bmN0aW9uIHBhcnNlSW1wcmVzc2lvbnMoaW1wcmVzc2lvbnMpIHtcblx0ICAgIGlmIChpbXByZXNzaW9ucykge1xuXHQgICAgICBpbXByZXNzaW9ucyA9IHV0aWxpdGllcy5pc0FycmF5KGltcHJlc3Npb25zKSA/IGltcHJlc3Npb25zIDogW2ltcHJlc3Npb25zXTtcblx0ICAgICAgcmV0dXJuIHV0aWxpdGllcy50cmFuc2Zvcm1BcnJheShpbXByZXNzaW9ucywgZnVuY3Rpb24gKGltcHJlc3Npb24pIHtcblx0ICAgICAgICBpZiAodXRpbGl0aWVzLmlzTm90RW1wdHlTdHJpbmcoaW1wcmVzc2lvbi5rZXlWYWx1ZSkpIHtcblx0ICAgICAgICAgIHJldHVybiBpbXByZXNzaW9uLmtleVZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBbXTtcblx0ICB9LFxuXG5cdCAgcGFyc2VFcnJvcnM6IGZ1bmN0aW9uIHBhcnNlRXJyb3JzKGVycm9ycykge1xuXHQgICAgaWYgKGVycm9ycykge1xuXHQgICAgXHRlcnJvcnMgPSB1dGlsaXRpZXMuaXNBcnJheShlcnJvcnMpID8gZXJyb3JzIDogW2Vycm9yc107XG5cdCAgICAgIHJldHVybiB1dGlsaXRpZXMudHJhbnNmb3JtQXJyYXkoZXJyb3JzLCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICBpZiAodXRpbGl0aWVzLmlzTm90RW1wdHlTdHJpbmcoZXJyb3Iua2V5VmFsdWUpKSB7XG5cdCAgICAgICAgICByZXR1cm4gZXJyb3Iua2V5VmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFtdO1xuXHQgIH0sXG5cbiAgLy9XZSBhc3N1bWUgdGhhdCB0aGUgcHJvZ3Jlc3MgaXMgZ29pbmcgdG8gYXJyaXZlIGluIG1pbGxpc2Vjb25kc1xuICBmb3JtYXRQcm9ncmVzczogZnVuY3Rpb24gZm9ybWF0UHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICB2YXIgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcztcbiAgICBob3VycyA9IHByb2dyZXNzIC8gKDYwICogNjAgKiAxMDAwKTtcbiAgICBob3VycyA9IE1hdGguZmxvb3IoaG91cnMpO1xuICAgIG1pbnV0ZXMgPSAocHJvZ3Jlc3MgLyAoNjAgKiAxMDAwKSkgJSA2MDtcbiAgICBtaW51dGVzID0gTWF0aC5mbG9vcihtaW51dGVzKTtcbiAgICBzZWNvbmRzID0gKHByb2dyZXNzIC8gMTAwMCkgJSA2MDtcbiAgICBzZWNvbmRzID0gTWF0aC5mbG9vcihzZWNvbmRzKTtcbiAgICBtaWxsaXNlY29uZHMgPSBwcm9ncmVzcyAlIDEwMDA7XG4gICAgcmV0dXJuIHV0aWxpdGllcy50b0ZpeGVkRGlnaXRzKGhvdXJzLCAyKSArICc6JyArIHV0aWxpdGllcy50b0ZpeGVkRGlnaXRzKG1pbnV0ZXMsIDIpICsgJzonICsgdXRpbGl0aWVzLnRvRml4ZWREaWdpdHMoc2Vjb25kcywgMikgKyAnLicgKyB1dGlsaXRpZXMudG9GaXhlZERpZ2l0cyhtaWxsaXNlY29uZHMsIDMpO1xuICB9LFxuXG4gIHBhcnNlT2Zmc2V0OiBmdW5jdGlvbiBwYXJzZU9mZnNldChvZmZzZXQsIGR1cmF0aW9uKSB7XG4gICAgaWYgKGlzUGVyY2VudGFnZShvZmZzZXQpKSB7XG4gICAgICByZXR1cm4gY2FsY3VsYXRlUGVyY2VudGFnZShvZmZzZXQsIGR1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhc3RVdGlsLnBhcnNlRHVyYXRpb24ob2Zmc2V0KTtcblxuICAgIC8qKiogTG9jYWwgZnVuY3Rpb24gKioqL1xuICAgIGZ1bmN0aW9uIGlzUGVyY2VudGFnZShvZmZzZXQpIHtcbiAgICAgIHZhciBwZXJjZW50YWdlUmVnZXggPSAvXlxcZCsoXFwuXFxkKyk/JSQvZztcbiAgICAgIHJldHVybiBwZXJjZW50YWdlUmVnZXgudGVzdChvZmZzZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVBlcmNlbnRhZ2UocGVyY2VudFN0ciwgZHVyYXRpb24pIHtcbiAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICByZXR1cm4gY2FsY1BlcmNlbnQoZHVyYXRpb24sIHBhcnNlRmxvYXQocGVyY2VudFN0ci5yZXBsYWNlKCclJywgJycpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjUGVyY2VudChxdWFudGl0eSwgcGVyY2VudCkge1xuICAgICAgcmV0dXJuIHF1YW50aXR5ICogcGVyY2VudCAvIDEwMDtcbiAgICB9XG4gIH0sXG5cblxuICAvL0xpc3Qgb2Ygc3VwcG9ydGVkIFZQQUlEIHRlY2hub2xvZ2llc1xuICBWUEFJRF90ZWNoczogW1xuICAgIC8vVlBBSURGbGFzaFRlY2gsXG4gICAgVlBBSURIVE1MNVRlY2hcbiAgXSxcblxuICBpc1ZQQUlEOiBmdW5jdGlvbiBpc1ZQQUlETWVkaWFGaWxlKG1lZGlhRmlsZSkge1xuICAgIHJldHVybiAhIW1lZGlhRmlsZSAmJiBtZWRpYUZpbGUuYXBpRnJhbWV3b3JrID09PSAnVlBBSUQnO1xuICB9LFxuXG4gIGZpbmRTdXBwb3J0ZWRWUEFJRFRlY2g6IGZ1bmN0aW9uIGZpbmRTdXBwb3J0ZWRWUEFJRFRlY2gobWltZVR5cGUpIHtcbiAgICB2YXIgaSwgbGVuLCBWUEFJRFRlY2g7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLlZQQUlEX3RlY2hzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBWUEFJRFRlY2ggPSB0aGlzLlZQQUlEX3RlY2hzW2ldO1xuICAgICAgaWYgKFZQQUlEVGVjaC5zdXBwb3J0cyhtaW1lVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIFZQQUlEVGVjaDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgaXNGbGFzaFN1cHBvcnRlZDogZnVuY3Rpb24gaXNGbGFzaFN1cHBvcnRlZCgpIHtcblx0ICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmFzdFV0aWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWQVNURXJyb3IgPSByZXF1aXJlKCcuLi92YXN0L1ZBU1RFcnJvcicpO1xuXG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXRpbGl0eUZ1bmN0aW9ucycpO1xuXG5mdW5jdGlvbiBWUEFJREFkVW5pdFdyYXBwZXIodnBhaWRBZFVuaXQsIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFZQQUlEQWRVbml0V3JhcHBlcikpIHtcbiAgICByZXR1cm4gbmV3IFZQQUlEQWRVbml0V3JhcHBlcih2cGFpZEFkVW5pdCwgb3B0cyk7XG4gIH1cbiAgc2FuaXR5Q2hlY2sodnBhaWRBZFVuaXQsIG9wdHMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxpdGllcy5leHRlbmQoe30sIG9wdHMpO1xuICB0aGlzLmFkU3RhcnRlZCA9IGZhbHNlO1xuXG4gIHRoaXMuX2FkVW5pdCA9IHZwYWlkQWRVbml0O1xuXG4gIC8qKiogTG9jYWwgRnVuY3Rpb25zICoqKi9cbiAgZnVuY3Rpb24gc2FuaXR5Q2hlY2soYWRVbml0LCBvcHRzKSB7XG4gICAgaWYgKCFhZFVuaXQgfHwgIVZQQUlEQWRVbml0V3JhcHBlci5jaGVja1ZQQUlESW50ZXJmYWNlKGFkVW5pdCkpIHtcbiAgICAgIHRocm93IG5ldyBWQVNURXJyb3IoJ29uIFZQQUlEQWRVbml0V3JhcHBlciwgdGhlIHBhc3NlZCBWUEFJRCBhZFVuaXQgZG9lcyBub3QgZnVsbHkgaW1wbGVtZW50IHRoZSBWUEFJRCBpbnRlcmZhY2UnKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWxpdGllcy5pc09iamVjdChvcHRzKSkge1xuICAgICAgdGhyb3cgbmV3IFZBU1RFcnJvcihcIm9uIFZQQUlEQWRVbml0V3JhcHBlciwgZXhwZWN0ZWQgb3B0aW9ucyBoYXNoICBidXQgZ290ICdcIiArIG9wdHMgKyBcIidcIik7XG4gICAgfVxuXG4gICAgaWYgKCEoXCJyZXNwb25zZVRpbWVvdXRcIiBpbiBvcHRzKSB8fCAhdXRpbGl0aWVzLmlzTnVtYmVyKG9wdHMucmVzcG9uc2VUaW1lb3V0KSApe1xuICAgICAgdGhyb3cgbmV3IFZBU1RFcnJvcihcIm9uIFZQQUlEQWRVbml0V3JhcHBlciwgZXhwZWN0ZWQgcmVzcG9uc2VUaW1lb3V0IGluIG9wdGlvbnNcIik7XG4gICAgfVxuICB9XG59XG5cblZQQUlEQWRVbml0V3JhcHBlci5jaGVja1ZQQUlESW50ZXJmYWNlID0gZnVuY3Rpb24gY2hlY2tWUEFJREludGVyZmFjZShWUEFJREFkVW5pdCkge1xuICAvL05PVEU6IHNraXBBZCBpcyBub3QgcGFydCBvZiB0aGUgbWV0aG9kIGxpc3QgYmVjYXVzZSBpdCBvbmx5IGFwcGVhcnMgaW4gVlBBSUQgMi4wIGFuZCB3ZSBzdXBwb3J0IFZQQUlEIDEuMFxuICB2YXIgVlBBSURJbnRlcmZhY2VNZXRob2RzID0gW1xuICAgICdoYW5kc2hha2VWZXJzaW9uJywgJ2luaXRBZCcsICdzdGFydEFkJywgJ3N0b3BBZCcsICdyZXNpemVBZCcsICdwYXVzZUFkJywgJ2V4cGFuZEFkJywgJ2NvbGxhcHNlQWQnXG4gIF07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IFZQQUlESW50ZXJmYWNlTWV0aG9kcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghVlBBSURBZFVuaXQgfHwgIXV0aWxpdGllcy5pc0Z1bmN0aW9uKFZQQUlEQWRVbml0W1ZQQUlESW50ZXJmYWNlTWV0aG9kc1tpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cblxuICByZXR1cm4gY2FuU3Vic2NyaWJlVG9FdmVudHMoVlBBSURBZFVuaXQpICYmIGNhblVuc3Vic2NyaWJlRnJvbUV2ZW50cyhWUEFJREFkVW5pdCk7XG5cbiAgLyoqKiBMb2NhbCBGdW5jdGlvbnMgKioqL1xuXG4gIGZ1bmN0aW9uIGNhblN1YnNjcmliZVRvRXZlbnRzKGFkVW5pdCkge1xuICAgIHJldHVybiB1dGlsaXRpZXMuaXNGdW5jdGlvbihhZFVuaXQuc3Vic2NyaWJlKSB8fCB1dGlsaXRpZXMuaXNGdW5jdGlvbihhZFVuaXQuYWRkRXZlbnRMaXN0ZW5lcikgfHwgdXRpbGl0aWVzLmlzRnVuY3Rpb24oYWRVbml0Lm9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhblVuc3Vic2NyaWJlRnJvbUV2ZW50cyhhZFVuaXQpIHtcbiAgICByZXR1cm4gdXRpbGl0aWVzLmlzRnVuY3Rpb24oYWRVbml0LnVuc3Vic2NyaWJlKSB8fCB1dGlsaXRpZXMuaXNGdW5jdGlvbihhZFVuaXQucmVtb3ZlRXZlbnRMaXN0ZW5lcikgfHwgdXRpbGl0aWVzLmlzRnVuY3Rpb24oYWRVbml0Lm9mZik7XG5cbiAgfVxufTtcblxuVlBBSURBZFVuaXRXcmFwcGVyLnByb3RvdHlwZS5hZFVuaXRBc3luY0NhbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gdXRpbGl0aWVzLmFycmF5TGlrZU9ialRvQXJyYXkoYXJndW1lbnRzKTtcbiAgdmFyIG1ldGhvZCA9IGFyZ3Muc2hpZnQoKTtcbiAgdmFyIGNiID0gYXJncy5wb3AoKTtcbiAgdmFyIHRpbWVvdXRJZDtcblxuICBzYW5pdHlDaGVjayhtZXRob2QsIGNiLCB0aGlzLl9hZFVuaXQpO1xuICBhcmdzLnB1c2god3JhcENhbGxiYWNrKCkpO1xuXG4gIHRoaXMuX2FkVW5pdFttZXRob2RdLmFwcGx5KHRoaXMuX2FkVW5pdCwgYXJncyk7XG4gIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgY2IobmV3IFZBU1RFcnJvcihcIm9uIFZQQUlEQWRVbml0V3JhcHBlciwgdGltZW91dCB3aGlsZSB3YWl0aW5nIGZvciBhIHJlc3BvbnNlIG9uIGNhbGwgJ1wiICsgbWV0aG9kICsgXCInXCIpKTtcbiAgICBjYiA9IHV0aWxpdGllcy5ub29wO1xuICB9LCB0aGlzLm9wdGlvbnMucmVzcG9uc2VUaW1lb3V0KTtcblxuICAvKioqIExvY2FsIGZ1bmN0aW9ucyAqKiovXG4gIGZ1bmN0aW9uIHNhbml0eUNoZWNrKG1ldGhvZCwgY2IsIGFkVW5pdCkge1xuICAgIGlmICghdXRpbGl0aWVzLmlzU3RyaW5nKG1ldGhvZCkgfHwgIXV0aWxpdGllcy5pc0Z1bmN0aW9uKGFkVW5pdFttZXRob2RdKSkge1xuICAgICAgdGhyb3cgbmV3IFZBU1RFcnJvcihcIm9uIFZQQUlEQWRVbml0V3JhcHBlci5hZFVuaXRBc3luY0NhbGwsIGludmFsaWQgbWV0aG9kIG5hbWVcIik7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsaXRpZXMuaXNGdW5jdGlvbihjYikpIHtcbiAgICAgIHRocm93IG5ldyBWQVNURXJyb3IoXCJvbiBWUEFJREFkVW5pdFdyYXBwZXIuYWRVbml0QXN5bmNDYWxsLCBtaXNzaW5nIGNhbGxiYWNrXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBDYWxsYmFjaygpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIH1cbiAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufTtcblxuVlBBSURBZFVuaXRXcmFwcGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldnROYW1lLCBoYW5kbGVyKSB7XG4gIHZhciBhZGRFdmVudExpc3RlbmVyID0gdGhpcy5fYWRVbml0LmFkZEV2ZW50TGlzdGVuZXIgfHwgdGhpcy5fYWRVbml0LnN1YnNjcmliZSB8fCB0aGlzLl9hZFVuaXQub247XG4gIGFkZEV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLl9hZFVuaXQsIGV2dE5hbWUsIGhhbmRsZXIpO1xufTtcblxuVlBBSURBZFVuaXRXcmFwcGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZ0TmFtZSwgaGFuZGxlcikge1xuICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHRoaXMuX2FkVW5pdC5yZW1vdmVFdmVudExpc3RlbmVyIHx8IHRoaXMuX2FkVW5pdC51bnN1YnNjcmliZSB8fCB0aGlzLl9hZFVuaXQub2ZmO1xuICByZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcy5fYWRVbml0LCBldnROYW1lLCBoYW5kbGVyKTtcbn07XG5cblZQQUlEQWRVbml0V3JhcHBlci5wcm90b3R5cGUud2FpdEZvckV2ZW50ID0gZnVuY3Rpb24gKGV2dE5hbWUsIGNiLCBjb250ZXh0KSB7XG5cdCAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIgdGltZW91dElkO1xuICBzYW5pdHlDaGVjayhldnROYW1lLCBjYik7XG4gIGNvbnRleHQgPSBjb250ZXh0IHx8IG51bGw7XG5cbiAgdGhpcy5vbihldnROYW1lLCByZXNwb25zZUxpc3RlbmVyKTtcblxuICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICB0aGF0Lm9mZihldnROYW1lLCByZXNwb25zZUxpc3RlbmVyKTtcblx0XHQvLyBpZ25vcmUgZXZlbnRzIGlmIGFkIGlzIGZpbmlzaGVkXG5cdFx0aWYgKHdpbmRvdy5fdGltZW91dElkcy5pbmRleE9mKHRpbWVvdXRJZCkgPj0gMCkge1xuICAgICAgaWYgKHRoYXQub3B0aW9ucyAmJiB0aGF0Lm9wdGlvbnMucGxheWVyKSB7XG4gICAgICAgIHRoYXQub3B0aW9ucy5wbGF5ZXIudHJpZ2dlcih7dHlwZTogJ3RyYWNlLm1lc3NhZ2UnLCBkYXRhOiB7bWVzc2FnZTogJ1RpbWVvdXQgd2hpbGUgd2FpdGluZyBmb3IgZXZlbnQgJyArIGV2dE5hbWV9fSk7XG4gICAgICB9XG5cdFx0XHRjYihuZXcgVkFTVEVycm9yKFwib24gVlBBSURBZFVuaXRXcmFwcGVyLndhaXRGb3JFdmVudCwgdGltZW91dCB3aGlsZSB3YWl0aW5nIGZvciBldmVudCAnXCIgKyBldnROYW1lICsgXCInXCIpKTtcblx0XHR9XG4gICAgdGltZW91dElkID0gbnVsbDtcbiAgICBjYiA9IHV0aWxpdGllcy5ub29wO1xuICB9LCB0aGlzLm9wdGlvbnMucmVzcG9uc2VUaW1lb3V0KTtcblxuICAvLyBFTlxuICB3aW5kb3cuX3RpbWVvdXRJZHMucHVzaCh0aW1lb3V0SWQpO1xuXG4gIC8qKiogTG9jYWwgZnVuY3Rpb25zICoqKi9cbiAgZnVuY3Rpb24gc2FuaXR5Q2hlY2soZXZ0TmFtZSwgY2IpIHtcbiAgICBpZiAoIXV0aWxpdGllcy5pc1N0cmluZyhldnROYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFZBU1RFcnJvcihcIm9uIFZQQUlEQWRVbml0V3JhcHBlci53YWl0Rm9yRXZlbnQsIG1pc3NpbmcgZXZ0IG5hbWVcIik7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsaXRpZXMuaXNGdW5jdGlvbihjYikpIHtcbiAgICAgIHRocm93IG5ldyBWQVNURXJyb3IoXCJvbiBWUEFJREFkVW5pdFdyYXBwZXIud2FpdEZvckV2ZW50LCBtaXNzaW5nIGNhbGxiYWNrXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3BvbnNlTGlzdGVuZXIoKSB7XG4gICAgaWYgKHRoYXQub3B0aW9ucyAmJiB0aGF0Lm9wdGlvbnMucGxheWVyKSB7XG4gICAgICB0aGF0Lm9wdGlvbnMucGxheWVyLnRyaWdnZXIoe3R5cGU6ICd0cmFjZS5ldmVudCcsIGRhdGE6IHtldmVudDogZXZ0TmFtZX19KTtcbiAgICB9XG5cdCAgdGhhdC5vZmYoZXZ0TmFtZSwgcmVzcG9uc2VMaXN0ZW5lcik7XG4gICAgdmFyIGFyZ3MgPSB1dGlsaXRpZXMuYXJyYXlMaWtlT2JqVG9BcnJheShhcmd1bWVudHMpO1xuXG4gICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB0aW1lb3V0SWQgPSBudWxsO1xuICAgIH1cblxuICAgIGFyZ3MudW5zaGlmdChudWxsKTtcbiAgICBjYi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgfVxufTtcblxuLy8gVlBBSUQgTUVUSE9EU1xuVlBBSURBZFVuaXRXcmFwcGVyLnByb3RvdHlwZS5oYW5kc2hha2VWZXJzaW9uID0gZnVuY3Rpb24gKHZlcnNpb24sIGNiKSB7XG4gIHRoaXMuYWRVbml0QXN5bmNDYWxsKCdoYW5kc2hha2VWZXJzaW9uJywgdmVyc2lvbiwgY2IpO1xufTtcblxuLyoganNoaW50IG1heHBhcmFtczo2ICovXG5WUEFJREFkVW5pdFdyYXBwZXIucHJvdG90eXBlLmluaXRBZCA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCB2aWV3TW9kZSwgZGVzaXJlZEJpdHJhdGUsIGFkVW5pdERhdGEsIGNiKSB7XG5cdGNvbnNvbGUubG9nKCdbQkMtTU9MXSBWUEFJREFkVW5pdFdyYXBwZXItPkNhbGxpbmcgaW5pdEFkIG9uIGNyZWF0aXZlJyk7XG5cdHRoaXMud2FpdEZvckV2ZW50KCdBZExvYWRlZCcsIGNiKTtcbiAgdGhpcy5fYWRVbml0LmluaXRBZCh3aWR0aCwgaGVpZ2h0LCB2aWV3TW9kZSwgZGVzaXJlZEJpdHJhdGUsIGFkVW5pdERhdGEpO1xufTtcblxuVlBBSURBZFVuaXRXcmFwcGVyLnByb3RvdHlwZS5yZXNpemVBZCA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCB2aWV3TW9kZSwgY2IpIHtcbiAgLy8gTk9URTogQWRTaXplQ2hhbmdlIGV2ZW50IGlzIG9ubHkgc3VwcG9ydGVkIG9uIFZQQUlEIDIuMCBzbyBmb3IgdGhlIG1vbWVudCB3ZSBhcmUgbm90IGdvaW5nIHRvIHVzZSBpdFxuICAvLyBhbmQgd2lsbCBhc3N1bWUgdGhhdCBldmVyeXRoaW5nIGlzIGZpbmUgYWZ0ZXIgdGhlIGFzeW5jIGNhbGxcblx0Y29uc29sZS5sb2coJ1tCQy1NT0xdIFZQQUlEQWRVbml0V3JhcHBlci0+Q2FsbGluZyByZXNpemVBZCBvbiBjcmVhdGl2ZScpO1xuICB0aGlzLmFkVW5pdEFzeW5jQ2FsbCgncmVzaXplQWQnLCB3aWR0aCwgaGVpZ2h0LCB2aWV3TW9kZSwgY2IpO1xuICBpZiAod2luZG93Lk1vYXRBcGlSZWZlcmVuY2UpIHtcbiAgXHR3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZS5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnQWRTaXplQ2hhbmdlJywgYWRWb2x1bWU6IHRoaXMub3B0aW9ucy5wbGF5ZXIudm9sdW1lKCl9KTtcbiAgfVxufTtcblxuVlBBSURBZFVuaXRXcmFwcGVyLnByb3RvdHlwZS5zdGFydEFkID0gZnVuY3Rpb24gKGNiKSB7XG5cdGNvbnNvbGUubG9nKCdbQkMtTU9MXSBWUEFJREFkVW5pdFdyYXBwZXItPkNhbGxpbmcgc3RhcnRBZCBvbiBjcmVhdGl2ZScpO1xuXHRpZiAoIXRoaXMuYWRTdGFydGVkKSB7XG5cdFx0dGhpcy53YWl0Rm9yRXZlbnQoJ0FkU3RhcnRlZCcsIGNiKTtcblx0fVxuICB0aGlzLl9hZFVuaXQuc3RhcnRBZCgpO1xuICBpZiAodGhpcy5hZFN0YXJ0ZWQpIHtcbiAgICBjYihudWxsKTtcbiAgfVxufTtcblxuVlBBSURBZFVuaXRXcmFwcGVyLnByb3RvdHlwZS5zdG9wQWQgPSBmdW5jdGlvbiAoY2IpIHtcblx0Y29uc29sZS5sb2coJ1tCQy1NT0xdIFZQQUlEQWRVbml0V3JhcHBlci0+Q2FsbGluZyBzdG9wQWQgb24gY3JlYXRpdmUnKTtcbiAgdGhpcy53YWl0Rm9yRXZlbnQoJ0FkU3RvcHBlZCcsIGNiKTtcbiAgdGhpcy5fYWRVbml0LnN0b3BBZCgpO1xufTtcblxuVlBBSURBZFVuaXRXcmFwcGVyLnByb3RvdHlwZS5wYXVzZUFkID0gZnVuY3Rpb24gKGNiKSB7XG5cdGNvbnNvbGUubG9nKCdbQkMtTU9MXSBWUEFJREFkVW5pdFdyYXBwZXItPkNhbGxpbmcgcGF1c2VBZCBvbiBjcmVhdGl2ZScpO1xuICB0aGlzLndhaXRGb3JFdmVudCgnQWRQYXVzZWQnLCBjYik7XG4gIHRoaXMuX2FkVW5pdC5wYXVzZUFkKCk7XG59O1xuXG5WUEFJREFkVW5pdFdyYXBwZXIucHJvdG90eXBlLnJlc3VtZUFkID0gZnVuY3Rpb24gKGNiKSB7XG5cdGNvbnNvbGUubG9nKCdbQkMtTU9MXSBWUEFJREFkVW5pdFdyYXBwZXItPkNhbGxpbmcgcmVzdW1lQWQgb24gY3JlYXRpdmUnKTtcbiAgdGhpcy53YWl0Rm9yRXZlbnQoJ0FkUGxheWluZycsIGNiKTtcbiAgdGhpcy5fYWRVbml0LnJlc3VtZUFkKCk7XG59O1xuXG5WUEFJREFkVW5pdFdyYXBwZXIucHJvdG90eXBlLmV4cGFuZEFkID0gZnVuY3Rpb24gKGNiKSB7XG5cdGNvbnNvbGUubG9nKCdbQkMtTU9MXSBWUEFJREFkVW5pdFdyYXBwZXItPkNhbGxpbmcgZXhwYW5kQWQgb24gY3JlYXRpdmUnKTtcbiAgdGhpcy53YWl0Rm9yRXZlbnQoJ0FkRXhwYW5kZWRDaGFuZ2UnLCBjYik7XG4gIHRoaXMuX2FkVW5pdC5leHBhbmRBZCgpO1xufTtcblxuVlBBSURBZFVuaXRXcmFwcGVyLnByb3RvdHlwZS5jb2xsYXBzZUFkID0gZnVuY3Rpb24gKGNiKSB7XG5cdGNvbnNvbGUubG9nKCdbQkMtTU9MXSBWUEFJREFkVW5pdFdyYXBwZXItPkNhbGxpbmcgY29sbGFwc2VBZCBvbiBjcmVhdGl2ZScpO1xuICB0aGlzLndhaXRGb3JFdmVudCgnQWRFeHBhbmRlZENoYW5nZScsIGNiKTtcbiAgdGhpcy5fYWRVbml0LmNvbGxhcHNlQWQoKTtcbn07XG5cblZQQUlEQWRVbml0V3JhcHBlci5wcm90b3R5cGUuc2tpcEFkID0gZnVuY3Rpb24gKGNiKSB7XG5cdGNvbnNvbGUubG9nKCdbQkMtTU9MXSBWUEFJREFkVW5pdFdyYXBwZXItPkNhbGxpbmcgc2tpcEFkIG9uIGNyZWF0aXZlJyk7XG4gIHRoaXMud2FpdEZvckV2ZW50KCdBZFNraXBwZWQnLCBjYik7XG4gIHRoaXMuX2FkVW5pdC5za2lwQWQoKTtcbn07XG5cbi8vVlBBSUQgcHJvcGVydHkgZ2V0dGVyc1xuW1xuICAnYWRMaW5lYXInLFxuICAnYWRXaWR0aCcsXG4gICdhZEhlaWdodCcsXG4gICdhZEV4cGFuZGVkJyxcbiAgJ2FkU2tpcHBhYmxlU3RhdGUnLFxuICAnYWRSZW1haW5pbmdUaW1lJyxcbiAgJ2FkRHVyYXRpb24nLFxuICAnYWRWb2x1bWUnLFxuICAnYWRDb21wYW5pb25zJyxcbiAgJ2FkSWNvbnMnXG5dLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gIHZhciBnZXR0ZXJOYW1lID0gJ2dldCcgKyB1dGlsaXRpZXMuY2FwaXRhbGl6ZShwcm9wZXJ0eSk7XG5cbiAgVlBBSURBZFVuaXRXcmFwcGVyLnByb3RvdHlwZVtnZXR0ZXJOYW1lXSA9IGZ1bmN0aW9uIChjYikge1xuICAgIHRoaXMuYWRVbml0QXN5bmNDYWxsKGdldHRlck5hbWUsIGNiKTtcbiAgfTtcbn0pO1xuXG4vL1ZQQUlEIHByb3BlcnR5IHNldHRlcnNcblZQQUlEQWRVbml0V3JhcHBlci5wcm90b3R5cGUuc2V0QWRWb2x1bWUgPSBmdW5jdGlvbih2b2x1bWUsIGNiKXtcbiAgdGhpcy5hZFVuaXRBc3luY0NhbGwoJ3NldEFkVm9sdW1lJyx2b2x1bWUsIGNiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVlBBSURBZFVuaXRXcmFwcGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTWltZVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbWltZXR5cGVzJyk7XG5cbnZhciBWQVNURXJyb3IgPSByZXF1aXJlKCcuLi92YXN0L1ZBU1RFcnJvcicpO1xuXG52YXIgVlBBSURIVE1MNUNsaWVudCA9IHJlcXVpcmUoJ1ZQQUlESFRNTDVDbGllbnQvanMvVlBBSURIVE1MNUNsaWVudCcpO1xuXG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXRpbGl0eUZ1bmN0aW9ucycpO1xudmFyIGRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2RvbScpO1xuXG52YXIgbG9nZ2VyID0gcmVxdWlyZSAoJy4uLy4uL3V0aWxzL2NvbnNvbGVMb2dnZXInKTtcblxuZnVuY3Rpb24gVlBBSURIVE1MNVRlY2gobWVkaWFGaWxlKSB7XG5cbiAgaWYoISh0aGlzIGluc3RhbmNlb2YgVlBBSURIVE1MNVRlY2gpKSB7XG4gICAgcmV0dXJuIG5ldyBWUEFJREhUTUw1VGVjaChtZWRpYUZpbGUpO1xuICB9XG5cbiAgc2FuaXR5Q2hlY2sobWVkaWFGaWxlKTtcblxuICB0aGlzLm5hbWUgPSAndnBhaWQtaHRtbDUnO1xuICB0aGlzLmNvbnRhaW5lckVsID0gbnVsbDtcbiAgdGhpcy52aWRlb0VsID0gbnVsbDtcbiAgdGhpcy52cGFpZEhUTUxDbGllbnQgPSBudWxsO1xuXG4gIHRoaXMubWVkaWFGaWxlID0gbWVkaWFGaWxlO1xuXG4gIGZ1bmN0aW9uIHNhbml0eUNoZWNrKG1lZGlhRmlsZSkge1xuICAgICAgaWYgKCFtZWRpYUZpbGUgfHwgIXV0aWxpdGllcy5pc1N0cmluZyhtZWRpYUZpbGUuc3JjKSkge1xuICAgICAgICB0aHJvdyBuZXcgVkFTVEVycm9yKFZQQUlESFRNTDVUZWNoLklOVkFMSURfTUVESUFfRklMRSk7XG4gICAgICB9XG4gIH1cbn1cblxuVlBBSURIVE1MNVRlY2guVlBBSURIVE1MNUNsaWVudCA9IFZQQUlESFRNTDVDbGllbnQ7XG5cblZQQUlESFRNTDVUZWNoLnN1cHBvcnRzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgcmV0dXJuICF1dGlsaXRpZXMuaXNPbGRJRSgpICYmIE1pbWVUeXBlcy5odG1sNS5pbmRleE9mKHR5cGUpID4gLTE7XG59O1xuXG5WUEFJREhUTUw1VGVjaC5wcm90b3R5cGUubG9hZEFkVW5pdCA9IGZ1bmN0aW9uIGxvYWRBZFVuaXQoY29udGFpbmVyRWwsIHZpZGVvRWwsIGNhbGxiYWNrKSB7XG4gIHNhbml0eUNoZWNrKGNvbnRhaW5lckVsLCB2aWRlb0VsLCBjYWxsYmFjayk7XG5cbiAgdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xuICB0aGlzLnZpZGVvRWwgPSB2aWRlb0VsO1xuICB0aGlzLnZwYWlkSFRNTENsaWVudCA9IG5ldyBWUEFJREhUTUw1VGVjaC5WUEFJREhUTUw1Q2xpZW50KGNvbnRhaW5lckVsLCB2aWRlb0VsLCB7fSk7XG4gIHRoaXMudnBhaWRIVE1MQ2xpZW50LmxvYWRBZFVuaXQodGhpcy5tZWRpYUZpbGUuc3JjLCBjYWxsYmFjayk7XG5cbiAgZnVuY3Rpb24gc2FuaXR5Q2hlY2soY29udGFpbmVyLCB2aWRlbywgY2IpIHtcbiAgICBpZiAoIWRvbS5pc0RvbUVsZW1lbnQoY29udGFpbmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFZBU1RFcnJvcihWUEFJREhUTUw1VGVjaC5JTlZBTElEX0RPTV9DT05UQUlORVJfRUwpO1xuICAgIH1cblxuICAgIGlmICghZG9tLmlzRG9tRWxlbWVudCh2aWRlbykgfHwgdmlkZW8udGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAndmlkZW8nKSB7XG4gICAgICB0aHJvdyBuZXcgVkFTVEVycm9yKFZQQUlESFRNTDVUZWNoLklOVkFMSURfRE9NX0NPTlRBSU5FUl9FTCk7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsaXRpZXMuaXNGdW5jdGlvbihjYikpIHtcbiAgICAgIHRocm93IG5ldyBWQVNURXJyb3IoVlBBSURIVE1MNVRlY2guTUlTU0lOR19DQUxMQkFDSyk7XG4gICAgfVxuICB9XG59O1xuXG5WUEFJREhUTUw1VGVjaC5wcm90b3R5cGUudW5sb2FkQWRVbml0ID0gZnVuY3Rpb24gdW5sb2FkQWRVbml0KCkge1xuICBpZiAodGhpcy52cGFpZEhUTUxDbGllbnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy52cGFpZEhUTUxDbGllbnQuZGVzdHJveSgpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgbG9nZ2VyLmVycm9yICgnVkFTVCBFUlJPUjogdHJ5aW5nIHRvIHVubG9hZCB0aGUgVlBBSUQgYWR1bml0Jyk7XG4gICAgfVxuXG4gICAgdGhpcy52cGFpZEhUTUxDbGllbnQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuY29udGFpbmVyRWwpIHtcbiAgICBkb20ucmVtb3ZlKHRoaXMuY29udGFpbmVyRWwpO1xuICAgIHRoaXMuY29udGFpbmVyRWwgPSBudWxsO1xuICB9XG59O1xuXG52YXIgUFJFRklYID0gJ29uIFZQQUlESFRNTDVUZWNoJztcblZQQUlESFRNTDVUZWNoLklOVkFMSURfTUVESUFfRklMRSA9IFBSRUZJWCArICcsIGludmFsaWQgTWVkaWFGaWxlJztcblZQQUlESFRNTDVUZWNoLklOVkFMSURfRE9NX0NPTlRBSU5FUl9FTCA9IFBSRUZJWCArICcsIGludmFsaWQgY29udGFpbmVyIEh0bWxFbGVtZW50JztcblZQQUlESFRNTDVUZWNoLklOVkFMSURfRE9NX1ZJREVPX0VMID0gUFJFRklYICsgJywgaW52YWxpZCBIVE1MVmlkZW9FbGVtZW50JztcblZQQUlESFRNTDVUZWNoLk1JU1NJTkdfQ0FMTEJBQ0sgPSBQUkVGSVggKyAnLCBtaXNzaW5nIHZhbGlkIGNhbGxiYWNrJztcblxubW9kdWxlLmV4cG9ydHMgPSBWUEFJREhUTUw1VGVjaDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE1pbWVUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL21pbWV0eXBlcycpO1xudmFyIFZBU1RFcnJvciA9IHJlcXVpcmUoJy4uL3Zhc3QvVkFTVEVycm9yJyk7XG52YXIgVkFTVFJlc3BvbnNlID0gcmVxdWlyZSgnLi4vdmFzdC9WQVNUUmVzcG9uc2UnKTtcbnZhciBWQVNUVHJhY2tlciA9IHJlcXVpcmUoJy4uL3Zhc3QvVkFTVFRyYWNrZXInKTtcbnZhciB2YXN0VXRpbCA9IHJlcXVpcmUoJy4uL3Zhc3QvdmFzdFV0aWwnKTtcblxudmFyIFZQQUlEQWRVbml0V3JhcHBlciA9IHJlcXVpcmUoJy4vVlBBSURBZFVuaXRXcmFwcGVyJyk7XG5cbnZhciBhc3luYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FzeW5jJyk7XG52YXIgZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZG9tJyk7XG52YXIgcGxheWVyVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9wbGF5ZXJVdGlscycpO1xudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3V0aWxpdHlGdW5jdGlvbnMnKTtcblxudmFyIGxvZ2dlciA9IHJlcXVpcmUgKCcuLi8uLi91dGlscy9jb25zb2xlTG9nZ2VyJyk7XG5cbmZ1bmN0aW9uIFZQQUlESW50ZWdyYXRvcihwbGF5ZXIsIHNldHRpbmdzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBWUEFJREludGVncmF0b3IpKSB7XG4gICAgcmV0dXJuIG5ldyBWUEFJREludGVncmF0b3IocGxheWVyKTtcbiAgfVxuXG4gIHRoaXMuVklFV19NT0RFID0ge1xuICAgIE5PUk1BTDogJ25vcm1hbCcsXG4gICAgRlVMTFNDUkVFTjogXCJmdWxsc2NyZWVuXCIsXG4gICAgVEhVTUJOQUlMOiBcInRodW1ibmFpbFwiXG4gIH07XG4gIHRoaXMucGxheWVyID0gcGxheWVyO1xuICB0aGlzLmNvbnRhaW5lckVsID0gY3JlYXRlVlBBSURDb250YWluZXJFbChwbGF5ZXIpO1xuICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgcmVzcG9uc2VUaW1lb3V0OiA1MDAwLFxuICAgIFZQQUlEX1ZFUlNJT046ICcyLjAnXG4gIH07XG4gIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgXG4gIHRoaXMuY29udGVudFNvdXJjZSA9IHBsYXllci50ZWNoXy5lbF8uc3JjO1xuICB0aGlzLm5lZWRzU2hvd1BsYXllciA9IGZhbHNlO1xuICBcbiAgdGhpcy5lcnJvckhhc0JlZW5UcmFja2VkID0gZmFsc2U7XG4gIHRoaXMuYWRGaW5pc2hlZCA9IGZhbHNlO1xuICBcbiAgdGhpcy50aW1lVXBkYXRlVGltZXIgPSBudWxsO1xuICBcbiAgLyoqKiBMb2NhbCBmdW5jdGlvbnMgKioqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVZQQUlEQ29udGFpbmVyRWwoKSB7XG4gICAgdmFyIGNvbnRhaW5lckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyRWwuaWQgPSAnQkMtVlBBSUQtY29udGFpbmVyJztcbiAgICBkb20uYWRkQ2xhc3MoY29udGFpbmVyRWwsICdWUEFJRC1jb250YWluZXInKTtcbiAgICBwbGF5ZXIuZWwoKS5pbnNlcnRCZWZvcmUoY29udGFpbmVyRWwsIHBsYXllci5jb250cm9sQmFyLmVsKCkpO1xuICAgIHJldHVybiBjb250YWluZXJFbDtcbiAgfVxufVxuXG5WUEFJREludGVncmF0b3IucHJvdG90eXBlLnBsYXlBZCA9IGZ1bmN0aW9uIHBsYXlWUGFpZEFkKHZhc3RSZXNwb25zZSwgY2FsbGJhY2spIHtcbiAgaWYgKCEodmFzdFJlc3BvbnNlIGluc3RhbmNlb2YgVkFTVFJlc3BvbnNlKSkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgVkFTVEVycm9yKCdvbiBWQVNUSW50ZWdyYXRvci5wbGF5QWQsIG1pc3NpbmcgcmVxdWlyZWQgVkFTVFJlc3BvbnNlJykpO1xuICB9XG5cbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIgcGxheWVyID0gdGhpcy5wbGF5ZXI7XG4gIGxvZ2dlci5kZWJ1ZyAoXCI8VlBBSURJbnRlZ3JhdG9yLnBsYXlBZD4gbG9va2luZyBmb3Igc3VwcG9ydGVkIHRlY2guLi5cIik7XG4gIHZhciB0ZWNoID0gdGhpcy5fZmluZFN1cHBvcnRlZFRlY2godmFzdFJlc3BvbnNlLCB0aGlzLnNldHRpbmdzKTtcblxuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IHV0aWxpdGllcy5ub29wO1xuXG4gIHRoaXMuX2FkVW5pdCA9IG51bGw7XG5cbiAgZG9tLmFkZENsYXNzKHBsYXllci5lbCgpLCAndmpzLXZwYWlkLWFkJyk7XG4gIFxuICBwbGF5ZXIub24oJ3Zhc3QuYWRzQ2FuY2VsJywgdHJpZ2dlclZwYWlkQWRFbmQpO1xuICBwbGF5ZXIub25lKCd2cGFpZC5hZEVuZCcsIGZ1bmN0aW9uKCl7XG4gICAgcGxheWVyLm9mZigndmFzdC5hZHNDYW5jZWwnLCB0cmlnZ2VyVnBhaWRBZEVuZCk7XG4gICAgcmVtb3ZlQWRVbml0KCk7XG4gIH0pO1xuXG4gIGlmICh0ZWNoKSB7XG4gICAgbG9nZ2VyLmluZm8gKFwiPFZQQUlESW50ZWdyYXRvci5wbGF5QWQ+IGZvdW5kIHRlY2g6IFwiLCB0ZWNoKTtcblxuICAgIGFzeW5jLndhdGVyZmFsbChbXG4gICAgICBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICBuZXh0KG51bGwsIHRlY2gsIHZhc3RSZXNwb25zZSk7XG4gICAgICB9LFxuICAgICAgdGhpcy5fbG9hZEFkVW5pdC5iaW5kKHRoaXMpLFxuICAgICAgdGhpcy5fcGxheUFkVW5pdC5iaW5kKHRoaXMpLFxuICAgICAgdGhpcy5fZmluaXNoUGxheWluZy5iaW5kKHRoaXMpXG5cbiAgICBdLCBhZENvbXBsZXRlKTtcblxuICAgIHRoaXMuX2FkVW5pdCA9IHtcbiAgICAgIF9wYXVzZWQ6IHRydWUsXG4gICAgICB0eXBlOiAnVlBBSUQnLFxuICAgICAgcGF1c2VBZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHBsYXllci50cmlnZ2VyKCd2cGFpZC5wYXVzZUFkJyk7XG4gICAgICAgIHBsYXllci5wYXVzZSh0cnVlKTsvL3dlIG1ha2Ugc3VyZSB0aGF0IHRoZSB2aWRlbyBjb250ZW50IGdldHMgc3RvcHBlZC5cbiAgICAgIH0sXG4gICAgICByZXN1bWVBZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcGxheWVyLnRyaWdnZXIoJ3ZwYWlkLnJlc3VtZUFkJyk7XG4gICAgICB9LFxuICAgICAgaXNQYXVzZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xuICAgICAgfSxcbiAgICAgIGdldFNyYzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0ZWNoLm1lZGlhRmlsZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyLmRlYnVnIChcIjxWUEFJREludGVncmF0b3IucGxheUFkPiBjb3VsZCBub3QgZmluZCBzdWl0YWJsZSB0ZWNoXCIpO1xuICAgIHZhciBlcnJvciA9IG5ldyBWQVNURXJyb3IoJ29uIFZQQUlESW50ZWdyYXRvci5wbGF5QWQsIGNvdWxkIG5vdCBmaW5kIGEgc3VwcG9ydGVkIG1lZGlhRmlsZScsIDQwMyk7XG4gICAgYWRDb21wbGV0ZShlcnJvciwgdGhpcy5fYWRVbml0LCB2YXN0UmVzcG9uc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2FkVW5pdDtcblxuICAvKioqIExvY2FsIGZ1bmN0aW9ucyAqKiovXG4gIGZ1bmN0aW9uIGFkQ29tcGxldGUoZXJyb3IsIGFkVW5pdCwgdmFzdFJlc3BvbnNlKSB7XG4gICAgaWYgKGVycm9yICYmIHZhc3RSZXNwb25zZSkge1xuICAgICAgdGhhdC5fdHJhY2tFcnJvcih2YXN0UmVzcG9uc2UsIGVycm9yLmNvZGUpO1xuICAgIH1cbiAgICBwbGF5ZXIudHJpZ2dlcigndnBhaWQuYWRFbmQnKTtcbiAgICBjYWxsYmFjayhlcnJvciwgdmFzdFJlc3BvbnNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaWdnZXJWcGFpZEFkRW5kKCl7XG5cdCAgICAvL3BsYXllci50cmlnZ2VyKCdzdG9wQWQnKTtcbiAgICBwbGF5ZXIudHJpZ2dlcigndnBhaWQuYWRFbmQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFkVW5pdCgpIHtcbiAgICBpZiAodGVjaCkge1xuICAgIFx0Y29uc29sZS5sb2coJ1tCQy1NT0xdIFZQQUlESW50ZWdyYXRvci0+Q2FsbGluZyB1bmxvYWRBZFVuaXQgKGltcGxpY2l0bHkgaW52b2tlcyBzdG9wQWQgYW5kIHVuc3Vic2NyaWJlcyBWUEFJRCBldmVudHMpJyk7XG4gICAgICB0ZWNoLnVubG9hZEFkVW5pdCgpO1xuICAgIH1cbiAgICBkb20ucmVtb3ZlQ2xhc3MocGxheWVyLmVsKCksICd2anMtdnBhaWQtYWQnKTtcbiAgfVxufTtcblxuVlBBSURJbnRlZ3JhdG9yLnByb3RvdHlwZS5fZmluZFN1cHBvcnRlZFRlY2ggPSBmdW5jdGlvbiAodmFzdFJlc3BvbnNlLCBzZXR0aW5ncykge1xuICBpZiAoISh2YXN0UmVzcG9uc2UgaW5zdGFuY2VvZiBWQVNUUmVzcG9uc2UpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgdnBhaWRNZWRpYUZpbGVzID0gdmFzdFJlc3BvbnNlLm1lZGlhRmlsZXMuZmlsdGVyKHZhc3RVdGlsLmlzVlBBSUQpO1xuICB2YXIgcHJlZmVycmVkVGVjaCA9IHNldHRpbmdzICYmIHNldHRpbmdzLnByZWZlcnJlZFRlY2g7XG4gIHZhciBza2lwcGVkU3VwcG9ydFRlY2hzID0gW107XG4gIHZhciBpLCBsZW4sIG1lZGlhRmlsZSwgVlBBSURUZWNoLCBpc1ByZWZlcmVkVGVjaDtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSB2cGFpZE1lZGlhRmlsZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBtZWRpYUZpbGUgPSB2cGFpZE1lZGlhRmlsZXNbaV07XG4gICAgVlBBSURUZWNoID0gdmFzdFV0aWwuZmluZFN1cHBvcnRlZFZQQUlEVGVjaChtZWRpYUZpbGUudHlwZSk7XG5cbiAgICAvLyBubyBzdXBwb3J0ZWQgVlBBSUQgdGVjaCBmb3VuZCwgc2tpcCBtZWRpYWZpbGVcbiAgICBpZiAoIVZQQUlEVGVjaCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gZG8gd2UgaGF2ZSBhIHByZWZlcmVkIHRlY2gsIGRvZXMgaXQgcGxheSB0aGlzIG1lZGlhIGZpbGUgP1xuICAgIGlzUHJlZmVyZWRUZWNoID0gcHJlZmVycmVkVGVjaCA/XG4gICAgICAobWVkaWFGaWxlLnR5cGUgPT09IHByZWZlcnJlZFRlY2ggfHwgKE1pbWVUeXBlc1twcmVmZXJyZWRUZWNoXSAmJiBNaW1lVHlwZXNbcHJlZmVycmVkVGVjaF0uaW5kZXhPZihtZWRpYUZpbGUudHlwZSkgPiAtMSApKSA6XG4gICAgICBmYWxzZTtcblxuICAgIC8vIG91ciBwcmVmZXJlZCB0ZWNoIGNhbiByZWFkIHRoaXMgbWVkaWFmaWxlLCBkZWZhdWx0aW5nIHRvIGl0LlxuICAgIGlmIChpc1ByZWZlcmVkVGVjaCkge1xuICAgICAgcmV0dXJuIG5ldyBWUEFJRFRlY2gobWVkaWFGaWxlLCBzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgc2tpcHBlZFN1cHBvcnRUZWNocy5wdXNoKHsgbWVkaWFGaWxlOiBtZWRpYUZpbGUsIHRlY2g6IFZQQUlEVGVjaCB9KTtcbiAgfVxuXG4gIGlmIChza2lwcGVkU3VwcG9ydFRlY2hzLmxlbmd0aCkge1xuICAgIHZhciBmaXJzdFRlY2ggPSBza2lwcGVkU3VwcG9ydFRlY2hzWzBdO1xuICAgIHJldHVybiBuZXcgZmlyc3RUZWNoLnRlY2goZmlyc3RUZWNoLm1lZGlhRmlsZSwgc2V0dGluZ3MpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5WUEFJREludGVncmF0b3IucHJvdG90eXBlLl9jcmVhdGVWUEFJREFkVW5pdFdyYXBwZXIgPSBmdW5jdGlvbihhZFVuaXQsIHNyYywgcmVzcG9uc2VUaW1lb3V0LCBwbGF5ZXIpIHtcblx0cmV0dXJuIG5ldyBWUEFJREFkVW5pdFdyYXBwZXIoYWRVbml0LCB7c3JjOiBzcmMsIHJlc3BvbnNlVGltZW91dDogcmVzcG9uc2VUaW1lb3V0LCBwbGF5ZXI6IHBsYXllcn0pO1xufTtcblxuVlBBSURJbnRlZ3JhdG9yLnByb3RvdHlwZS5fbG9hZEFkVW5pdCA9IGZ1bmN0aW9uICh0ZWNoLCB2YXN0UmVzcG9uc2UsIG5leHQpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIgcGxheWVyID0gdGhpcy5wbGF5ZXI7XG4gIHZhciB2anNUZWNoRWwgPSBwbGF5ZXIuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLXRlY2gnKTtcbiAgLy92YXIgcmVzcG9uc2VUaW1lb3V0ID0gdGhpcy5zZXR0aW5ncy5yZXNwb25zZVRpbWVvdXQgfHwgdGhpcy5vcHRpb25zLnJlc3BvbnNlVGltZW91dDtcbiAgdmFyIHJlc3BvbnNlVGltZW91dCA9IHRoaXMuc2V0dGluZ3MuYWRDYW5jZWxUaW1lb3V0IHx8IHRoaXMub3B0aW9ucy5yZXNwb25zZVRpbWVvdXQ7XG4gIHRlY2gubG9hZEFkVW5pdCh0aGlzLmNvbnRhaW5lckVsLCB2anNUZWNoRWwsIGZ1bmN0aW9uIChlcnJvciwgYWRVbml0KSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gbmV4dChlcnJvciwgYWRVbml0LCB2YXN0UmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgZnJtcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdJRlJBTUUnKTtcbiAgICAgIGlmIChmcm1zICYmIGZybXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmcm1zWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vY29uc29sZS5sb2coXCIqKioqKiogdXNlciBhY3Rpdml0eVwiKTtcbiAgICAgICAgICAgIHBsYXllci51c2VyQWN0aXZlKHRydWUpO1xuICAgICAgICAgICAgaWYgKCFkb20uaGFzQ2xhc3MocGxheWVyLmVsKCksICd2anMtaGFzLXN0YXJ0ZWQnKSkge1xuICAgICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhwbGF5ZXIuZWwoKSwgJ3Zqcy1oYXMtc3RhcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBsYXllci50cmlnZ2VyKHt0eXBlOiAndHJhY2UubWVzc2FnZScsIGRhdGE6IHttZXNzYWdlOiAnUGxheWluZyAnICsgdGVjaC5tZWRpYUZpbGUuc3JjICsgJyAodHlwZSA9ICcgKyB0ZWNoLm1lZGlhRmlsZS50eXBlICsgXG4gICAgICBcdCAgJywgYXBpRnJhbWV3b3JrID0gJyArIHRlY2gubWVkaWFGaWxlLmFwaUZyYW1ld29yayArICcpJ319KTtcbiAgICAgIHZhciBXcmFwcGVkQWRVbml0ID0gdGhhdC5fY3JlYXRlVlBBSURBZFVuaXRXcmFwcGVyKGFkVW5pdCwgdGVjaC5tZWRpYUZpbGUuc3JjLCByZXNwb25zZVRpbWVvdXQsIHBsYXllcik7XG4gICAgICB2YXIgdGVjaENsYXNzID0gJ3Zqcy0nICsgdGVjaC5uYW1lICsgJy1hZCc7XG4gICAgICBkb20uYWRkQ2xhc3MocGxheWVyLmVsKCksIHRlY2hDbGFzcyk7XG4gICAgICBwbGF5ZXIub25lKCd2cGFpZC5hZEVuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3MocGxheWVyLmVsKCksdGVjaENsYXNzKTtcbiAgICAgIH0pO1xuICAgICAgbmV4dChudWxsLCBXcmFwcGVkQWRVbml0LCB2YXN0UmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5leHQoZSwgYWRVbml0LCB2YXN0UmVzcG9uc2UpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5WUEFJREludGVncmF0b3IucHJvdG90eXBlLl9wbGF5QWRVbml0ID0gZnVuY3Rpb24gKGFkVW5pdCwgdmFzdFJlc3BvbnNlLCBjYWxsYmFjaykge1xuICBhc3luYy53YXRlcmZhbGwoW1xuICAgIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICBuZXh0KG51bGwsIGFkVW5pdCwgdmFzdFJlc3BvbnNlKTtcbiAgICB9LFxuICAgIHRoaXMuX2hhbmRzaGFrZS5iaW5kKHRoaXMpLFxuICAgIHRoaXMuX3NldHVwRXZlbnRzLmJpbmQodGhpcyksXG4gICAgdGhpcy5faW5pdEFkLmJpbmQodGhpcyksXG4gICAgLy90aGlzLl9zZXR1cEV2ZW50cy5iaW5kKHRoaXMpLFxuICAgIHRoaXMuX2FkZFNraXBCdXR0b24uYmluZCh0aGlzKSxcbiAgICB0aGlzLl9saW5rUGxheWVyQ29udHJvbHMuYmluZCh0aGlzKSxcbiAgICB0aGlzLl9zdGFydEFkLmJpbmQodGhpcylcbiAgXSwgY2FsbGJhY2spO1xufTtcblxuVlBBSURJbnRlZ3JhdG9yLnByb3RvdHlwZS5faGFuZHNoYWtlID0gZnVuY3Rpb24gaGFuZHNoYWtlKGFkVW5pdCwgdmFzdFJlc3BvbnNlLCBuZXh0KSB7XG4gIGFkVW5pdC5oYW5kc2hha2VWZXJzaW9uKHRoaXMub3B0aW9ucy5WUEFJRF9WRVJTSU9OLCBmdW5jdGlvbiAoZXJyb3IsIHZlcnNpb24pIHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBuZXh0KGVycm9yLCBhZFVuaXQsIHZhc3RSZXNwb25zZSk7XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gJiYgaXNTdXBwb3J0ZWRWZXJzaW9uKHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gbmV4dChudWxsLCBhZFVuaXQsIHZhc3RSZXNwb25zZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQobmV3IFZBU1RFcnJvcignb24gVlBBSURJbnRlZ3JhdG9yLl9oYW5kc2hha2UsIHVuc3VwcG9ydGVkIHZlcnNpb24gXCInICsgdmVyc2lvbiArICdcIicpLCBhZFVuaXQsIHZhc3RSZXNwb25zZSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGlzU3VwcG9ydGVkVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgdmFyIG1ham9yTnVtID0gbWFqb3IodmVyc2lvbik7XG4gICAgcmV0dXJuIG1ham9yTnVtID49IDEgJiYgbWFqb3JOdW0gPD0gMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ham9yKHZlcnNpb24pIHtcbiAgICB2YXIgcGFydHMgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XG4gICAgcmV0dXJuIHBhcnNlSW50KHBhcnRzWzBdLCAxMCk7XG4gIH1cbn07XG5cblZQQUlESW50ZWdyYXRvci5wcm90b3R5cGUuX2luaXRBZCA9IGZ1bmN0aW9uIChhZFVuaXQsIHZhc3RSZXNwb25zZSwgbmV4dCkge1xuICB2YXIgdGVjaCA9IHRoaXMucGxheWVyLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy10ZWNoJyk7XG4gIHZhciBkaW1lbnNpb24gPSBkb20uZ2V0RGltZW5zaW9uKHRlY2gpO1xuICBhZFVuaXQuaW5pdEFkKGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCwgdGhpcy5WSUVXX01PREUuTk9STUFMLCAtMSwge0FkUGFyYW1ldGVyczogdmFzdFJlc3BvbnNlLmFkUGFyYW1ldGVycyB8fCAnJ30sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgIG5leHQoZXJyb3IsIGFkVW5pdCwgdmFzdFJlc3BvbnNlKTtcbiAgfSk7XG59O1xuXG5WUEFJREludGVncmF0b3IucHJvdG90eXBlLl9jcmVhdGVWQVNUVHJhY2tlciA9IGZ1bmN0aW9uKGFkVW5pdFNyYywgdmFzdFJlc3BvbnNlKSB7XG4gIHJldHVybiBuZXcgVkFTVFRyYWNrZXIoYWRVbml0U3JjLCB2YXN0UmVzcG9uc2UpO1xufTtcblxuVlBBSURJbnRlZ3JhdG9yLnByb3RvdHlwZS5fc2V0dXBFdmVudHMgPSBmdW5jdGlvbiAoYWRVbml0LCB2YXN0UmVzcG9uc2UsIG5leHQpIHtcbiAgdmFyIGFkVW5pdFNyYyA9IGFkVW5pdC5vcHRpb25zLnNyYztcbiAgdmFyIHRyYWNrZXIgPSB0aGlzLl9jcmVhdGVWQVNUVHJhY2tlcihhZFVuaXRTcmMsIHZhc3RSZXNwb25zZSk7XG4gIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllcjtcbiAgdmFyIGNvbnRlbnRTb3VyY2UgPSB0aGlzLmNvbnRlbnRTb3VyY2U7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgXG4gIHRoaXMudHJhY2tlciA9IHRyYWNrZXI7XG4gIFxuICB0aGlzLmltcHJlc3Npb25UcmlnZ2VyZWQgPSBmYWxzZTtcblxuICBhZFVuaXQub24oJ0FkU2tpcHBlZCcsIGZ1bmN0aW9uICgpIHtcblx0ICBcdHBsYXllci50cmlnZ2VyKHt0eXBlOiAndHJhY2UuZXZlbnQnLCBkYXRhOiB7ZXZlbnQ6ICd2cGFpZC5BZFNraXBwZWQnfX0pO1xuXHQgICAgICBpZiAod2luZG93Lk1vYXRBcGlSZWZlcmVuY2UpIHtcblx0ICAgIFx0ICB3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZS5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnQWRTa2lwcGVkJywgYWRWb2x1bWU6IHBsYXllci52b2x1bWUoKX0pO1xuXHQgICAgICB9XG4gICAgcGxheWVyLnRyaWdnZXIoJ3ZwYWlkLkFkU2tpcHBlZCcpO1xuICAgIHRyYWNrZXIudHJhY2tTa2lwKCk7XG4gICAgcGxheWVyVXRpbHMuc2hvd0JpZ1BsYXlCdXR0b24ocGxheWVyLCBmYWxzZSk7XG4gICAgXG4gICAgYWRVbml0LnN0b3BBZCh1dGlsaXRpZXMubm9vcCk7XG4gICAgLy8gVklETEEtMjY3NiAtIGZvcmNlIHBsYXllciB0byBjbGVhbiByZXNvdXJjZXNcbiAgXHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBwbGF5ZXIudHJpZ2dlcigndmFzdC5hZHNDYW5jZWwnKTtcbiAgXHR9LCAxKTtcbiAgICAvL3BsYXllci50cmlnZ2VyKCdhZFN0b3AnKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdHJpZ2dlckltcHJlc3Npb24oKSB7XG5cdCAgaWYgKCF0aGF0LmltcHJlc3Npb25UcmlnZ2VyZWQpIHtcblx0XHQgIHRoYXQuaW1wcmVzc2lvblRyaWdnZXJlZCA9IHRydWU7XG5cdCAgICAgIGlmICh3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZSkge1xuXHQgICAgXHQgIHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlLmRpc3BhdGNoRXZlbnQoe3R5cGU6ICdBZEltcHJlc3Npb24nLCBhZFZvbHVtZTogcGxheWVyLnZvbHVtZSgpfSk7XG5cdCAgICAgIH1cblx0XHQgIHBsYXllci50cmlnZ2VyKHt0eXBlOiAndHJhY2UuZXZlbnQnLCBkYXRhOiB7ZXZlbnQ6ICd2cGFpZC5BZEltcHJlc3Npb24nfX0pO1xuXHRcdCAgcGxheWVyLnRyaWdnZXIoJ3ZwYWlkLkFkSW1wcmVzc2lvbicpO1xuXHRcdCAgdHJhY2tlci50cmFja0ltcHJlc3Npb25zKCk7XG5cdCAgfVxuICB9XG4gIGFkVW5pdC5vbignQWRJbXByZXNzaW9uJywgZnVuY3Rpb24gKCkge1xuXHQgIHRyaWdnZXJJbXByZXNzaW9uKCk7XG4gIH0pO1xuXG4gIGFkVW5pdC5vbignQWRTdGFydGVkJywgZnVuY3Rpb24gKCkge1xuXHQgIGlmIChhZFVuaXQuYWRTdGFydGVkKSB7XG5cdFx0ICAvLyBpZ25vcmUgc2Vjb25kIEFkU3RhcnRlZCBldmVudFxuXHRcdCAgcmV0dXJuO1xuXHQgIH1cbiAgICBpZiAod2luZG93Ll9tb2xTZXR0aW5ncy52aWV3YWJpbGl0eVRyYWNraW5nKSB7XG4gICAgICB3aW5kb3cuX21vbFNldHRpbmdzLnZpZXdhYmlsaXR5VHJhY2tpbmcuaW5pdCh3aW5kb3cuX21vbFNldHRpbmdzLnZpZXdhYmlsaXR5LmNvbnRleHRJZCwgXG4gICAgICAgICAgcGxheWVyLmR1cmF0aW9uKCksIHBsYXllci5lbF8ub2Zmc2V0V2lkdGgsIHBsYXllci5lbF8ub2Zmc2V0SGVpZ2h0KTtcbiAgICB9XG4gICAgYWRVbml0LmFkU3RhcnRlZCA9IHRydWU7XG4gICAgaWYgKCFkb20uaGFzQ2xhc3MocGxheWVyLmVsKCksICd2anMtaGFzLXN0YXJ0ZWQnKSkge1xuICAgICAgZG9tLmFkZENsYXNzKHBsYXllci5lbCgpLCAndmpzLWhhcy1zdGFydGVkJyk7XG4gICAgfVxuICAgIHBsYXllci50cmlnZ2VyKCd2cGFpZC5BZFN0YXJ0ZWQnKTtcbiAgICB0cmFja2VyLnRyYWNrQ3JlYXRpdmVWaWV3KCk7XG4gICAgaWYgKCF3aW5kb3cuX21vbFNldHRpbmdzLnBsYXlzSW5CcmVhayAmJiBhZFVuaXQuZ2V0QWREdXJhdGlvbikge1xuICAgICAgYWRVbml0LmdldEFkRHVyYXRpb24oZnVuY3Rpb24odGhhdCwgZHVyKSB7XG4gICAgICAgIGlmIChkdXIgPiAwKSB7XG4gICAgICAgICAgcGxheWVyLmR1cmF0aW9uKGR1cik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgXHR0cmlnZ2VySW1wcmVzc2lvbigpO1xuICAgIG5vdGlmeVBsYXlUb1BsYXllcigpO1xuICAgIHBsYXllci5vbmUoJ2FkU3RvcCcsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGFkVW5pdC5zdG9wQWQpIHtcbiAgICAgICAgYWRVbml0LnN0b3BBZCh1dGlsaXRpZXMubm9vcCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKHV0aWxpdGllcy5pc0lEZXZpY2UoKSkge1xuICAgIFx0Ly8gVklETEEtMjgzNiAoQWQgY2xpY2sgdGhydSBkb2VzIG5vdCBsYW5kaW5nIGNsaWNrIHRocnUgdXJsKVxuICAgIFx0Ly8gaVBob25lIGFuZCBpUGFkXG4gICAgXHR2YXIgZWxlbXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd2anMtcmVzaXplLW1hbmFnZXInKTtcbiAgICBcdGlmIChlbGVtcyAmJiBlbGVtcy5sZW5ndGggPiAwKSB7XG4gICAgXHRcdHZhciBwYXJlbnQgPSBlbGVtc1swXS5wYXJlbnRFbGVtZW50O1xuICAgIFx0XHRpZiAocGFyZW50KSB7XG4gICAgXHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsZW1zWzBdKTtcbiAgICBcdFx0fVxuICAgIFx0fVxuICAgIH1cblxuICB9KTtcblxuICBmdW5jdGlvbiB1cGRhdGVUaW1lQ29udHJvbHMoKSB7XG5cdCAgXHR2YXIgY29udmVydFRpbWVUb1N0ciA9IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRcdHZhciBzZWNzID0gcGFyc2VJbnQodGltZSArIDAuNSk7XG5cdFx0XHR2YXIgbWlucyA9IHBhcnNlSW50KHNlY3MgLyA2MCk7XG5cdFx0XHRzZWNzIC09IChtaW5zICogNjApO1xuXHRcdFx0dmFyIHN0ciA9IG1pbnMudG9TdHJpbmcoKSArICc6JyArIChzZWNzID4gOSA/ICcnICA6ICcwJykgKyBzZWNzLnRvU3RyaW5nKCk7XG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGJjVGltZURpc3BsYXkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmNfdGltZV9kaXNwbGF5Jyk7XG5cdFx0aWYgKCFiY1RpbWVEaXNwbGF5KSB7XG5cdFx0XHRiY1RpbWVEaXNwbGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRwbGF5ZXIuY29udHJvbEJhci5nZXRDaGlsZCgnY3VycmVudFRpbWVEaXNwbGF5JykuZWxfLmFwcGVuZENoaWxkKGJjVGltZURpc3BsYXkpO1xuXHRcdFx0YmNUaW1lRGlzcGxheS5pZCA9ICdiY190aW1lX2Rpc3BsYXknO1xuXHRcdFx0YmNUaW1lRGlzcGxheS5jbGFzcyA9ICd2anMtY3VycmVudC10aW1lLWRpc3BsYXknO1xuXHRcdFx0YmNUaW1lRGlzcGxheVsnYXJpYS1saXZlJ10gPSAnb2ZmJztcblx0XHRcdGJjVGltZURpc3BsYXkuaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPjwvc3Bhbj4wOjAwJztcbiAgICAgIHNob3dPcmlnaW5hbFRpbWVEaXNwbGF5KHBsYXllciwgZmFsc2UpO1xuXHRcdH1cblx0XHRlbHNlIHtcbiAgICAgIHNob3dPcmlnaW5hbFRpbWVEaXNwbGF5KHBsYXllciwgZmFsc2UpO1xuXHRcdFx0YmNUaW1lRGlzcGxheS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0XHR9XG5cdFx0YWRVbml0LmdldEFkUmVtYWluaW5nVGltZShmdW5jdGlvbih0aGF0LCB0aW1lKSB7XG5cdFx0XHRpZiAodGltZSA+PSAwKSB7XG5cdFx0XHRcdHZhciBjdXJUaW1lID0gcGxheWVyLmR1cmF0aW9uKCkgLSB0aW1lO1xuXHRcdFx0XHRpZiAoY3VyVGltZSA+PSAwKSB7XG5cdFx0XHRcdFx0YmNUaW1lRGlzcGxheS5jaGlsZE5vZGVzWzFdLm5vZGVWYWx1ZSA9IGNvbnZlcnRUaW1lVG9TdHIoY3VyVGltZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcbiAgfVxuXHQgIFxuICBhZFVuaXQub24oJ0FkVmlkZW9TdGFydCcsIGZ1bmN0aW9uICgpIHtcblx0ICBwbGF5ZXIudHJpZ2dlcih7dHlwZTogJ3RyYWNlLmV2ZW50JywgZGF0YToge2V2ZW50OiAnQWRWaWRlb1N0YXJ0J319KTtcbiAgICAgIGlmICh3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZSkge1xuICAgIFx0ICB3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZS5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnQWRWaWRlb1N0YXJ0JywgYWRWb2x1bWU6IHBsYXllci52b2x1bWUoKX0pO1xuICAgICAgfVxuXG4gICAgcGxheWVyLnRyaWdnZXIoJ3ZwYWlkLkFkVmlkZW9TdGFydCcpO1xuICAgIHRyYWNrZXIudHJhY2tTdGFydCgpO1xuXHRpZiAoIXdpbmRvdy5fbW9sU2V0dGluZ3MucGxheXNJbkJyZWFrICYmIGFkVW5pdC5nZXRBZER1cmF0aW9uKSB7XG5cdFx0YWRVbml0LmdldEFkRHVyYXRpb24oZnVuY3Rpb24odGhhdCwgZHVyKSB7XG5cdFx0XHRpZiAoZHVyID4gMCkge1xuXHRcdFx0XHRwbGF5ZXIuZHVyYXRpb24oZHVyKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuICAgIG5vdGlmeVBsYXlUb1BsYXllcigpO1xuICAgIHBsYXllclV0aWxzLnNob3dCaWdQbGF5QnV0dG9uKHBsYXllciwgZmFsc2UpO1xuICAgIGlmICh1dGlsaXRpZXMuaXNNb2JpbGUoKSkge1xuICAgICAgICAvLyBWSURMQS0yMzM2IChzaW11bGF0ZSB1c2VyIGFjdGl2aXR5IHRvIG1ha2Ugc3VyZSBjb250cm9sIGJhciBpcyB2aXNpYmxlIG9uIG1vYmlsZSBkZXZpY2VzKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIFx0XHRkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnSUZSQU1FJylbMF0uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ21vdXNlb3ZlcicpKTtcbiAgICAgICAgXHR9LCBpICogMTAwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRlbnRTb3VyY2UgPT09IHBsYXllci50ZWNoXy5lbF8uc3JjKSB7XG4gICAgICAgIHBsYXllci50cmlnZ2VyKHt0eXBlOiAndHJhY2UubWVzc2FnZScsIGRhdGE6IHttZXNzYWdlOiAnVlBBSUQgY3JlYXRpdmUgdXNlcyBpdHMgb3duIHZpZGVvIHRhZyd9fSk7XG4gICAgICAgIC8vcGxheWVyLnRlY2hfLmVsXy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAvL3BsYXllci5jb250cm9sQmFyLmhpZGUoKTtcbiAgICAgICAgdGhhdC5uZWVkc1Nob3dQbGF5ZXIgPSB0cnVlO1xuICAgIFx0aWYgKCF3aW5kb3cuX21vbFNldHRpbmdzLnBsYXlzSW5CcmVhaykge1xuICAgIFx0XHR0aGF0LnRpbWVVcGRhdGVUaW1lciA9IHNldEludGVydmFsKHVwZGF0ZVRpbWVDb250cm9scywgNTAwKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwbGF5ZXIuY29udHJvbEJhci5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBhZFVuaXQub24oJ0FkUGxheWluZycsIGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhhdC5hZEZpbmlzaGVkKSB7XG5cdFx0ICByZXR1cm47XG5cdCAgfVxuICAgICAgaWYgKHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlKSB7XG4gICAgXHQgIHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlLmRpc3BhdGNoRXZlbnQoe3R5cGU6ICdBZFBsYXlpbmcnLCBhZFZvbHVtZTogcGxheWVyLnZvbHVtZSgpfSk7XG4gICAgICB9XG4gICAgcGxheWVyLnRyaWdnZXIoJ3ZwYWlkLkFkUGxheWluZycpO1xuICAgIHRyYWNrZXIudHJhY2tSZXN1bWUoKTtcbiAgICBub3RpZnlQbGF5VG9QbGF5ZXIoKTtcbiAgICBwbGF5ZXJVdGlscy5zaG93QmlnUGxheUJ1dHRvbihwbGF5ZXIsIGZhbHNlKTtcbiAgfSk7XG5cbiAgYWRVbml0Lm9uKCdBZFBhdXNlZCcsIGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhhdC5hZEZpbmlzaGVkKSB7XG5cdFx0ICByZXR1cm47XG5cdCAgfVxuICAgICAgaWYgKHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlKSB7XG4gICAgXHQgIHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlLmRpc3BhdGNoRXZlbnQoe3R5cGU6ICdBZFBhdXNlZCcsIGFkVm9sdW1lOiBwbGF5ZXIudm9sdW1lKCl9KTtcbiAgICAgIH1cbiAgICBwbGF5ZXIudHJpZ2dlcigndnBhaWQuQWRQYXVzZWQnKTtcbiAgICB0cmFja2VyLnRyYWNrUGF1c2UoKTtcbiAgICBub3RpZnlQYXVzZVRvUGxheWVyKCk7XG5cdCAgdmFyIGlmcmFtZUJhY2tCdXR0b24gPSB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lmcmFtZUJhY2tCdXR0b24nKTtcblx0ICBpZiAoaWZyYW1lQmFja0J1dHRvbikge1xuXHRcdCAgcGxheWVyVXRpbHMuc2hvd0JpZ1BsYXlCdXR0b24ocGxheWVyLCBmYWxzZSk7XG5cdFx0ICByZXR1cm47XG5cdCAgfVxuICAgIHBsYXllclV0aWxzLnNob3dCaWdQbGF5QnV0dG9uKHBsYXllciwgdHJ1ZSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIG5vdGlmeVBsYXlUb1BsYXllcigpe1xuICAgIGlmKHRoYXQuX2FkVW5pdCAmJiB0aGF0Ll9hZFVuaXQuaXNQYXVzZWQoKSl7XG4gICAgICB0aGF0Ll9hZFVuaXQuX3BhdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBwbGF5ZXIudHJpZ2dlcigncGxheScpO1xuXG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlQYXVzZVRvUGxheWVyKCkge1xuICAgIGlmKHRoYXQuX2FkVW5pdCl7XG4gICAgICB0aGF0Ll9hZFVuaXQuX3BhdXNlZCA9IHRydWU7XG4gICAgfVxuICAgIHBsYXllci50cmlnZ2VyKCdwYXVzZScpO1xuICB9XG5cbiAgYWRVbml0Lm9uKCdBZFZpZGVvRmlyc3RRdWFydGlsZScsIGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhhdC5hZEZpbmlzaGVkKSB7XG5cdFx0ICByZXR1cm47XG5cdCAgfVxuXHRcdHBsYXllci50cmlnZ2VyKHt0eXBlOiAndHJhY2UuZXZlbnQnLCBkYXRhOiB7ZXZlbnQ6ICd2cGFpZC5BZFZpZGVvRmlyc3RRdWFydGlsZSd9fSk7XG4gICAgaWYgKHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlKSB7XG4gICAgXHR3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZS5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnQWRWaWRlb0ZpcnN0UXVhcnRpbGUnLCBhZFZvbHVtZTogcGxheWVyLnZvbHVtZSgpfSk7XG4gICAgfVxuICAgIHBsYXllci50cmlnZ2VyKCd2cGFpZC5BZFZpZGVvRmlyc3RRdWFydGlsZScpO1xuICAgIHRyYWNrZXIudHJhY2tGaXJzdFF1YXJ0aWxlKCk7XG4gIH0pO1xuXG4gIGFkVW5pdC5vbignQWRWaWRlb01pZHBvaW50JywgZnVuY3Rpb24gKCkge1xuXHQgIGlmICh0aGF0LmFkRmluaXNoZWQpIHtcblx0XHQgIHJldHVybjtcblx0ICB9XG5cdFx0cGxheWVyLnRyaWdnZXIoe3R5cGU6ICd0cmFjZS5ldmVudCcsIGRhdGE6IHtldmVudDogJ3ZwYWlkLkFkVmlkZW9NaWRwb2ludCd9fSk7XG4gICAgaWYgKHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlKSB7XG4gICAgXHR3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZS5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnQWRWaWRlb01pZHBvaW50JywgYWRWb2x1bWU6IHBsYXllci52b2x1bWUoKX0pO1xuICAgIH1cbiAgICBwbGF5ZXIudHJpZ2dlcigndnBhaWQuQWRWaWRlb01pZHBvaW50Jyk7XG4gICAgdHJhY2tlci50cmFja01pZHBvaW50KCk7XG4gIH0pO1xuXG4gIGFkVW5pdC5vbignQWRWaWRlb1RoaXJkUXVhcnRpbGUnLCBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHRoYXQuYWRGaW5pc2hlZCkge1xuXHRcdCAgcmV0dXJuO1xuXHQgIH1cblx0XHRwbGF5ZXIudHJpZ2dlcih7dHlwZTogJ3RyYWNlLmV2ZW50JywgZGF0YToge2V2ZW50OiAndnBhaWQuQWRWaWRlb1RoaXJkUXVhcnRpbGUnfX0pO1xuICAgIGlmICh3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZSkge1xuICAgIFx0d2luZG93Lk1vYXRBcGlSZWZlcmVuY2UuZGlzcGF0Y2hFdmVudCh7dHlwZTogJ0FkVmlkZW9UaGlyZFF1YXJ0aWxlJywgYWRWb2x1bWU6IHBsYXllci52b2x1bWUoKX0pO1xuICAgIH1cbiAgICBwbGF5ZXIudHJpZ2dlcigndnBhaWQuQWRWaWRlb1RoaXJkUXVhcnRpbGUnKTtcbiAgICB0cmFja2VyLnRyYWNrVGhpcmRRdWFydGlsZSgpO1xuICB9KTtcblxuICBhZFVuaXQub24oJ0FkVmlkZW9Db21wbGV0ZScsIGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhhdC5hZEZpbmlzaGVkKSB7XG5cdFx0ICByZXR1cm47XG5cdCAgfVxuXHRcdHBsYXllci50cmlnZ2VyKHt0eXBlOiAndHJhY2UuZXZlbnQnLCBkYXRhOiB7ZXZlbnQ6ICd2cGFpZC5BZFZpZGVvQ29tcGxldGUnfX0pO1xuICAgIHBsYXllci50cmlnZ2VyKCd2cGFpZC5BZFZpZGVvQ29tcGxldGUnKTtcbiAgICB0cmFja2VyLnRyYWNrQ29tcGxldGUoKTtcbiAgICBwbGF5ZXJVdGlscy5zaG93QmlnUGxheUJ1dHRvbihwbGF5ZXIsIGZhbHNlKTtcbiAgICBpZiAod2luZG93Lk1vYXRBcGlSZWZlcmVuY2UpIHtcbiAgXHQgIHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlLmRpc3BhdGNoRXZlbnQoe3R5cGU6ICdBZFZpZGVvQ29tcGxldGUnLCBhZFZvbHVtZTogcGxheWVyLnZvbHVtZSgpfSk7XG4gICAgfVxuICAgIC8vIFZJRExBLTI0MDYgZm9yc2UgYWQgdG8gc3RvcFxuICAgIGlmIChhZFVuaXQuc3RvcEFkKSB7XG4gICAgICBhZFVuaXQuc3RvcEFkKHV0aWxpdGllcy5ub29wKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFkVW5pdC5vbignQWRDbGlja1RocnUnLCBmdW5jdGlvbiAoZGF0YSkge1xuXHQgIGlmICh0aGF0LmFkRmluaXNoZWQpIHtcblx0XHQgIHJldHVybjtcblx0ICB9XG5cdCAgdmFyIGVuYWJsZUZ1bGxzY3JlZW5DbGlja0lGcmFtZSA9IGZhbHNlO1xuXHRwbGF5ZXIudHJpZ2dlcih7dHlwZTogJ3RyYWNlLmV2ZW50JywgZGF0YToge2V2ZW50OiAndnBhaWQuQWRDbGlja1RocnUnfX0pO1xuICAgICAgaWYgKHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlKSB7XG4gICAgXHQgIHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlLmRpc3BhdGNoRXZlbnQoe3R5cGU6ICdBZENsaWNrVGhydScsIGFkVm9sdW1lOiBwbGF5ZXIudm9sdW1lKCl9KTtcbiAgICAgIH1cbiAgICBwbGF5ZXIudHJpZ2dlcigndnBhaWQuQWRDbGlja1RocnUnKTtcbiAgICB2YXIgdXJsID0gZGF0YS51cmw7XG4gICAgdmFyIHBsYXllckhhbmRsZXMgPSBkYXRhLnBsYXllckhhbmRsZXM7XG4gICAgdmFyIGNsaWNrVGhydVVybCA9IHV0aWxpdGllcy5pc05vdEVtcHR5U3RyaW5nKHVybCkgPyB1cmwgOiBnZW5lcmF0ZUNsaWNrVGhyb3VnaFVSTCh2YXN0UmVzcG9uc2UuY2xpY2tUaHJvdWdoKTtcblxuXHRpZiAocGxheWVySGFuZGxlcyAmJiB3aW5kb3cuX21vbFNldHRpbmdzLmRpc2FibGVDbGlja1RocnUpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0XG4gICAgdHJhY2tlci50cmFja0NsaWNrKCk7XG4gICAgaWYgKHBsYXllckhhbmRsZXMgJiYgY2xpY2tUaHJ1VXJsKSB7XG4gICAgXHRpZiAocGxheWVyLmlzRnVsbHNjcmVlbigpICYmIGVuYWJsZUZ1bGxzY3JlZW5DbGlja0lGcmFtZSkge1xuICAgIFx0XHRhZGRDbGlja1Rocm91Z2hEaXZCbG9ja2VyKGNsaWNrVGhydVVybCk7XG4gICAgXHR9XG4gICAgXHRlbHNlIHtcbiAgICBcdFx0d2luZG93Lm9wZW4oY2xpY2tUaHJ1VXJsLCAnX2JsYW5rJyk7XG4gICAgXHR9XG4gICAgfVxuICAgIFxuICAgIC8vIFZJRExBLTIyNjkgKEFkIGRvZXMgbm90IHBhdXNlIHdoZW4gYnJvd3Npbmcgb3V0IHRvIGEgY2xpY2sgdXJsIGZyb20gYSB2cGFpZCBhZClcbiAgICBhZFVuaXQucGF1c2VBZCh1dGlsaXRpZXMubm9vcCk7XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNsaWNrVGhyb3VnaFVSTChjbGlja1Rocm91Z2hNYWNybykge1xuICAgICAgdmFyIHZhcmlhYmxlcyA9IHtcbiAgICAgICAgQVNTRVRVUkk6IGFkVW5pdC5vcHRpb25zLnNyYyxcbiAgICAgICAgQ09OVEVOVFBMQVlIRUFEOiAwIC8vSW4gVlBBSUQgdGhlcmUgaXMgbm8gbWV0aG9kIHRvIGtub3cgdGhlIGN1cnJlbnQgdGltZSBmcm9tIHRoZSBhZFVuaXRcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBjbGlja1Rocm91Z2hNYWNybyA/IHZhc3RVdGlsLnBhcnNlVVJMTWFjcm8oY2xpY2tUaHJvdWdoTWFjcm8sIHZhcmlhYmxlcykgOiBudWxsO1xuICAgIH1cbiAgfSk7XG5cbiAgYWRVbml0Lm9uKCdBZFVzZXJBY2NlcHRJbnZpdGF0aW9uJywgZnVuY3Rpb24gKCkge1xuXHRcdHBsYXllci50cmlnZ2VyKHt0eXBlOiAndHJhY2UuZXZlbnQnLCBkYXRhOiB7ZXZlbnQ6ICd2cGFpZC5BZFVzZXJBY2NlcHRJbnZpdGF0aW9uJ319KTtcbiAgICBwbGF5ZXIudHJpZ2dlcigndnBhaWQuQWRVc2VyQWNjZXB0SW52aXRhdGlvbicpO1xuICAgIHRyYWNrZXIudHJhY2tBY2NlcHRJbnZpdGF0aW9uKCk7XG4gICAgdHJhY2tlci50cmFja0FjY2VwdEludml0YXRpb25MaW5lYXIoKTtcbiAgfSk7XG5cbiAgYWRVbml0Lm9uKCdBZFVzZXJDbG9zZScsIGZ1bmN0aW9uICgpIHtcblx0XHRwbGF5ZXIudHJpZ2dlcih7dHlwZTogJ3RyYWNlLmV2ZW50JywgZGF0YToge2V2ZW50OiAndnBhaWQuQWRVc2VyQ2xvc2UnfX0pO1xuXHQgICAgICBpZiAod2luZG93Lk1vYXRBcGlSZWZlcmVuY2UpIHtcblx0ICAgIFx0ICB3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZS5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnQWRVc2VyQ2xvc2UnLCBhZFZvbHVtZTogcGxheWVyLnZvbHVtZSgpfSk7XG5cdCAgICAgIH1cbiAgICBwbGF5ZXIudHJpZ2dlcigndnBhaWQuQWRVc2VyQ2xvc2UnKTtcbiAgICB0cmFja2VyLnRyYWNrQ2xvc2UoKTtcbiAgICB0cmFja2VyLnRyYWNrQ2xvc2VMaW5lYXIoKTtcbiAgfSk7XG5cbiAgYWRVbml0Lm9uKCdBZFVzZXJNaW5pbWl6ZScsIGZ1bmN0aW9uICgpIHtcblx0XHRwbGF5ZXIudHJpZ2dlcih7dHlwZTogJ3RyYWNlLmV2ZW50JywgZGF0YToge2V2ZW50OiAndnBhaWQuQWRVc2VyTWluaW1pemUnfX0pO1xuICAgIHBsYXllci50cmlnZ2VyKCd2cGFpZC5BZFVzZXJNaW5pbWl6ZScpO1xuICAgIHRyYWNrZXIudHJhY2tDb2xsYXBzZSgpO1xuICB9KTtcblxuICBhZFVuaXQub24oJ0FkRXJyb3InLCBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHRoYXQuYWRGaW5pc2hlZCkge1xuXHRcdCAgcmV0dXJuO1xuXHQgIH1cblx0ICAvLyBWSURMQS0yMzg5IHN1cHByZXNzIGVyb3IgdHJhY2tpbmcgYWZ0ZXIgYWQgaW1wcmVzc2lvbiBoYXMgYmVlbiByZXBvcnRlZFxuXHQgIGlmICghdGhhdC5pbXByZXNzaW9uVHJpZ2dlcmVkICYmICF0aGF0LmVycm9ySGFzQmVlblRyYWNrZWQpIHtcblx0XHQgIHBsYXllci50cmlnZ2VyKHt0eXBlOiAndHJhY2UuZXZlbnQnLCBkYXRhOiB7ZXZlbnQ6ICd2cGFpZC5BZEVycm9yJ319KTtcblx0ICAgICAgaWYgKHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlKSB7XG5cdCAgICBcdCAgd2luZG93Lk1vYXRBcGlSZWZlcmVuY2UuZGlzcGF0Y2hFdmVudCh7dHlwZTogJ0FkRXJyb3InLCBhZFZvbHVtZTogcGxheWVyLnZvbHVtZSgpfSk7XG5cdCAgICAgIH1cblx0ICAgICAgcGxheWVyLnRyaWdnZXIoJ3ZwYWlkLkFkRXJyb3InKTtcblx0ICAgIC8vTk9URTogd2UgdHJhY2sgZXJyb3JzIGNvZGUgOTAxLCBhcyBub3RlZCBpbiBWQVNUIDMuMFxuXHQgICAgdHJhY2tlci50cmFja0Vycm9yV2l0aENvZGUoOTAxKTtcblx0ICAgIHRoYXQuZXJyb3JIYXNCZWVuVHJhY2tlZCA9IHRydWU7XG5cdCAgfVxuXHQgIHBsYXllclV0aWxzLnNob3dCaWdQbGF5QnV0dG9uKHBsYXllciwgZmFsc2UpO1xuICB9KTtcblxuICBhZFVuaXQub24oJ0FkVm9sdW1lQ2hhbmdlJywgZnVuY3Rpb24gKCkge1xuXHRcdHBsYXllci50cmlnZ2VyKHt0eXBlOiAndHJhY2UuZXZlbnQnLCBkYXRhOiB7ZXZlbnQ6ICd2cGFpZC5BZFZvbHVtZUNoYW5nZSd9fSk7XG4gICAgcGxheWVyLnRyaWdnZXIoJ3ZwYWlkLkFkVm9sdW1lQ2hhbmdlJyk7XG4gICAgdmFyIGxhc3RWb2x1bWUgPSBwbGF5ZXIudm9sdW1lKCk7XG4gICAgYWRVbml0LmdldEFkVm9sdW1lKGZ1bmN0aW9uIChlcnJvciwgY3VycmVudFZvbHVtZSkge1xuICAgICAgaWYgKGxhc3RWb2x1bWUgIT09IGN1cnJlbnRWb2x1bWUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRWb2x1bWUgPT09IDAgJiYgbGFzdFZvbHVtZSA+IDApIHtcbiAgICAgICAgICB0cmFja2VyLnRyYWNrTXV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRWb2x1bWUgPiAwICYmIGxhc3RWb2x1bWUgPT09IDApIHtcbiAgICAgICAgICB0cmFja2VyLnRyYWNrVW5tdXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwbGF5ZXIudm9sdW1lKGN1cnJlbnRWb2x1bWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBhZFVuaXQub24oJ0FkU2l6ZUNoYW5nZScsIGZ1bmN0aW9uICgpIHtcblx0ICBpZiAocGxheWVyLnZhc3QgJiYgcGxheWVyLnZhc3QubmVlZFN5bmNQbGF5KSB7XG5cdFx0ICBpZiAocGxheWVyLnBhdXNlZCgpICE9PSBwbGF5ZXIudGVjaF8uZWxfLnBhdXNlZCkge1xuICAgICAgICAvLyBhZCB1c2VzIG1haW4gY29udGVudCB0YWdcbiAgICAgICAgaWYgKGNvbnRlbnRTb3VyY2UgIT0gcGxheWVyLnRlY2hfLmVsXy5zcmMpIHtcbiAgICAgICAgICBpZiAocGxheWVyLnRlY2hfLmVsXy5wYXVzZWQpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlLmRpc3BhdGNoRXZlbnQoe3R5cGU6ICdBZFBhdXNlZCcsIGFkVm9sdW1lOiBwbGF5ZXIudm9sdW1lKCl9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vdGlmeVBhdXNlVG9QbGF5ZXIoKTtcbiAgICAgICAgICAgIHBsYXllclV0aWxzLnNob3dCaWdQbGF5QnV0dG9uKHBsYXllciwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgd2luZG93Lk1vYXRBcGlSZWZlcmVuY2UuZGlzcGF0Y2hFdmVudCh7dHlwZTogJ0FkUGxheWluZycsIGFkVm9sdW1lOiBwbGF5ZXIudm9sdW1lKCl9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vdGlmeVBsYXlUb1BsYXllcigpO1xuICAgICAgICAgICAgcGxheWVyVXRpbHMuc2hvd0JpZ1BsYXlCdXR0b24ocGxheWVyLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cdFx0ICB9XG5cdFx0ICBwbGF5ZXIudmFzdC5uZWVkU3luY1BsYXkgPSBmYWxzZTtcblx0ICB9IFxuICB9KTtcblxuICBmdW5jdGlvbiBhZGRDbGlja1Rocm91Z2hEaXZCbG9ja2VyKGNsaWNrVGhydVVybCkge1xuXHQgIHZhciBibG9ja2VyID0gY3JlYXRlQ2xpY2tUaHJvdWdoRGl2KHBsYXllciwgY2xpY2tUaHJ1VXJsKTtcblx0ICB2YXIgaUZyYW1lO1xuXHQgIHZhciBpRnJhbWVCYWNrQnV0dG9uO1xuXG5cdCAgcGxheWVyLmVsKCkuaW5zZXJ0QmVmb3JlKGJsb2NrZXIsIHBsYXllci5jb250cm9sQmFyLmVsKCkpO1xuXG5cdCAgcGxheWVyLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgdXBkYXRlRGlzcGxheVN0eWxlKTtcblxuXHQgIGZ1bmN0aW9uIGNyZWF0ZUNsaWNrVGhyb3VnaERpdihwbGF5ZXIsIHVybCkge1xuXHQgICAgdmFyIGJsb2NrZXIgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHQgICAgZG9tLmFkZENsYXNzKGJsb2NrZXIsICd2YXN0LWJsb2NrZXInKTtcblxuXHQgICAgaWYgKHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlKSB7XG4gICAgXHQgIHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlLmRpc3BhdGNoRXZlbnQoe3R5cGU6ICdBZENsaWNrVGhydScsIGFkVm9sdW1lOiBwbGF5ZXIudm9sdW1lKCl9KTtcblx0ICAgIH1cbiAgICAgIFxuXHQgICAgLy8gY3JlYXRlIElGcmFtZSB3aXRoIGJhY2sgYnV0dG9uXG5cdCAgICBpRnJhbWUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcblx0ICAgIGRvbS5hZGRDbGFzcyhpRnJhbWUsICd2YXN0LWJsb2NrZXInKTtcblx0ICAgIGlGcmFtZS5zcmMgPSB1cmw7XG5cdCAgICBibG9ja2VyLmFwcGVuZENoaWxkKGlGcmFtZSk7XG5cdCAgXG5cdCAgICBpRnJhbWVCYWNrQnV0dG9uID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdCAgICBkb20uYWRkQ2xhc3MoaUZyYW1lQmFja0J1dHRvbiwgXCJ2YXN0LWJhY2stYnV0dG9uXCIpO1xuXHQgICAgZG9tLmFkZENsYXNzKGlGcmFtZUJhY2tCdXR0b24sICdlbmFibGVkJyk7XG5cdCAgICBpRnJhbWVCYWNrQnV0dG9uLmlubmVySFRNTCA9IFwiQmFja1wiO1xuXHQgICAgaUZyYW1lQmFja0J1dHRvbi5pZCA9ICdpZnJhbWVCYWNrQnV0dG9uJztcblx0ICAgIGJsb2NrZXIuYXBwZW5kQ2hpbGQoaUZyYW1lQmFja0J1dHRvbik7XG5cdCAgICBpRnJhbWVCYWNrQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIgKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuXHRcdCAgLy8gc2hvdyBjb250cm9sc1xuXHRcdCAgdmFyIHNraXBCdXR0b24gPSB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkU2tpcEJ1dHRvbicpO1xuXHRcdCAgaWYgKHNraXBCdXR0b24pIHtcblx0XHRcdCAgc2tpcEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsgXG5cdFx0ICB9XG5cdFx0ICBwbGF5ZXIuY29udHJvbHModHJ1ZSk7XG5cdFx0ICBcblx0XHQgIHBsYXllci5lbCgpLnJlbW92ZUNoaWxkKGJsb2NrZXIpO1xuXHRcdCAgcmVzdW1lQWRVbml0KCk7XG5cdFx0ICBcblx0XHQgIGlmICh3aW5kb3cuRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdCAgfVxuXHQgICAgfSk7XG5cdFx0ICBcblx0ICAgIC8vIGhpZGUgY29udHJvbHNcblx0ICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0ICBwbGF5ZXJVdGlscy5zaG93QmlnUGxheUJ1dHRvbihwbGF5ZXIsIGZhbHNlKTtcblx0ICAgIH0sIDEpO1xuXHQgICAgdmFyIHNraXBCdXR0b24gPSB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkU2tpcEJ1dHRvbicpO1xuXHQgICAgaWYgKHNraXBCdXR0b24pIHtcblx0XHQgIHNraXBCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJzsgXG5cdCAgICB9XG5cdCAgICBwbGF5ZXIuY29udHJvbHMoZmFsc2UpO1xuXG5cdCAgICByZXR1cm4gYmxvY2tlcjtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5U3R5bGUoKSB7XG5cdFx0ICBpZiAoIXBsYXllci5pc0Z1bGxzY3JlZW4oKSkge1x0XHRcdCAgXG5cdFx0XHQgIHBsYXllclV0aWxzLnNob3dCaWdQbGF5QnV0dG9uKHBsYXllciwgdHJ1ZSk7XG5cdFx0XHQgIHZhciBza2lwQnV0dG9uID0gd2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhZFNraXBCdXR0b24nKTtcblx0XHRcdCAgaWYgKHNraXBCdXR0b24pIHtcblx0XHRcdFx0ICBza2lwQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IFxuXHRcdFx0ICB9XG5cdFx0XHQgIHBsYXllci5jb250cm9scyh0cnVlKTtcblx0XHRcdCAgcGxheWVyLmVsKCkucmVtb3ZlQ2hpbGQoYmxvY2tlcik7XG5cdFx0XHQgIHJlc3VtZUFkVW5pdCgpO1xuXHRcdCAgfVxuXHQgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVWaWV3U2l6ZSA9IHJlc2l6ZUFkLmJpbmQodGhpcywgcGxheWVyLCBhZFVuaXQsIHRoaXMuVklFV19NT0RFKTtcbiAgdmFyIHVwZGF0ZVZpZXdTaXplVGhyb3R0bGVkID0gdXRpbGl0aWVzLnRocm90dGxlKHVwZGF0ZVZpZXdTaXplLCAxMDApO1xuICB2YXIgYXV0b1Jlc2l6ZSA9IHRoaXMuc2V0dGluZ3MuYXV0b1Jlc2l6ZTtcblxuICBpZiAoYXV0b1Jlc2l6ZSkge1xuICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIHVwZGF0ZVZpZXdTaXplVGhyb3R0bGVkKTtcbiAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdvcmllbnRhdGlvbmNoYW5nZScsIHVwZGF0ZVZpZXdTaXplVGhyb3R0bGVkKTtcbiAgfVxuXG4gIHBsYXllci5vbigndmFzdC5yZXNpemUnLCB1cGRhdGVWaWV3U2l6ZSk7XG4gIHBsYXllci5vbigndnBhaWQucGF1c2VBZCcsIHBhdXNlQWRVbml0KTtcbiAgcGxheWVyLm9uKCd2cGFpZC5yZXN1bWVBZCcsIHJlc3VtZUFkVW5pdCk7XG4gIHBsYXllci5vbignc3RvcEFkJywgc3RvcEFkVW5pdCk7XG5cbiAgcGxheWVyLm9uZSgndnBhaWQuYWRFbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgcGxheWVyLm9mZigndmFzdC5yZXNpemUnLCB1cGRhdGVWaWV3U2l6ZSk7XG4gICAgcGxheWVyLm9mZigndnBhaWQucGF1c2VBZCcsIHBhdXNlQWRVbml0KTtcbiAgICBwbGF5ZXIub2ZmKCd2cGFpZC5yZXN1bWVBZCcsIHJlc3VtZUFkVW5pdCk7XG4gICAgcGxheWVyLm9mZignc3RvcEFkJywgc3RvcEFkVW5pdCk7XG5cbiAgICBpZiAoYXV0b1Jlc2l6ZSkge1xuICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgdXBkYXRlVmlld1NpemVUaHJvdHRsZWQpO1xuICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAnb3JpZW50YXRpb25jaGFuZ2UnLCB1cGRhdGVWaWV3U2l6ZVRocm90dGxlZCk7XG4gICAgfVxuICB9KTtcblxuICBuZXh0KG51bGwsIGFkVW5pdCwgdmFzdFJlc3BvbnNlKTtcblxuICAvKioqIExvY2FsIEZ1bmN0aW9ucyAqKiovXG4gIGZ1bmN0aW9uIHBhdXNlQWRVbml0KCkge1xuICAgIGFkVW5pdC5wYXVzZUFkKHV0aWxpdGllcy5ub29wKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3VtZUFkVW5pdCgpIHtcbiAgICBhZFVuaXQucmVzdW1lQWQodXRpbGl0aWVzLm5vb3ApO1xuICB9XG4gIFxuICBmdW5jdGlvbiBzdG9wQWRVbml0KCkge1xuICAgIGlmIChhZFVuaXQuc3RvcEFkKSB7XG4gICAgICBhZFVuaXQuc3RvcEFkKHV0aWxpdGllcy5ub29wKTtcbiAgICB9XG4gIH1cbn07XG5cblZQQUlESW50ZWdyYXRvci5wcm90b3R5cGUuX2FkZFNraXBCdXR0b24gPSBmdW5jdGlvbiAoYWRVbml0LCB2YXN0UmVzcG9uc2UsIG5leHQpIHtcbiAgdmFyIHNraXBCdXR0b247XG4gIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllcjtcbiAgdmFyIHRyYWNrZXIgPSB0aGlzLnRyYWNrZXI7XG5cbiAgLy8gVklETEEtMjA4NCAocHVibGlzaGVyLXNwZWNpZmllZCBTS0lQIGJlaGF2aW9yIGZvciBWUEFJRCBjcmVhdGl2ZXMpXG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdmFyIHNraXBPZmZzZXRJblNlYztcbiAgdmFyIGR1cmF0aW9uO1xuICB2YXIgcmVtYWluaW5nVGltZTtcbiAgdmFyIHByb2dyZXNzSW50ZXJ2YWw7XG4gIGlmICghd2luZG93Ll9tb2xTZXR0aW5ncy5kaXNhYmxlU2tpcHBhYmlsaXR5KSB7XG5cdCAgaWYgKHZhc3RSZXNwb25zZS5za2lwb2Zmc2V0ICYmIHV0aWxpdGllcy5pc051bWJlcih2YXN0UmVzcG9uc2Uuc2tpcG9mZnNldCkpIHtcblx0XHQgIHNraXBPZmZzZXRJblNlYyA9IHZhc3RSZXNwb25zZS5za2lwb2Zmc2V0IC8gMTAwMDtcblx0XHQgIHB1YkFkZFNraXBCdXR0b25Ub1BsYXllcihwbGF5ZXIsIHNraXBPZmZzZXRJblNlYyk7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHRcdCAgLy8gY2hlY2sgaWYgcHVibGlzaGVyIGhhZCBleHBsaWNpdGx5IGRpc2FibGUgc2tpcHBhYmlsaXR5XG5cdFx0ICB2YXIgZGlzYWJsZVNraXBwYWJpbGl0eUJ5UHVibGlzaGVyID0gZmFsc2U7XG5cdFx0ICBpZiAod2luZG93Ll9tb2xTZXR0aW5ncyAmJiB3aW5kb3cuX21vbFNldHRpbmdzLnNraXBwYWJsZSkge1xuXHRcdFx0ICBpZiAod2luZG93Ll9tb2xTZXR0aW5ncy5za2lwcGFibGUuZW5hYmxlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0ICBkaXNhYmxlU2tpcHBhYmlsaXR5QnlQdWJsaXNoZXIgPSB0cnVlOyBcblx0XHRcdCAgfVxuXHRcdFx0ICBpZiAodmFzdFJlc3BvbnNlLmR1cmF0aW9uICYmIHdpbmRvdy5fbW9sU2V0dGluZ3Muc2tpcHBhYmxlLnZpZGVvVGhyZXNob2xkICYmIFxuXHRcdFx0XHQgIHZhc3RSZXNwb25zZS5kdXJhdGlvbiA8IHdpbmRvdy5fbW9sU2V0dGluZ3Muc2tpcHBhYmxlLnZpZGVvVGhyZXNob2xkKSB7XG5cdFx0XHRcdCAgZGlzYWJsZVNraXBwYWJpbGl0eUJ5UHVibGlzaGVyID0gdHJ1ZTsgXG5cdFx0XHQgIH1cblx0XHQgIH1cblx0XHQgIGlmICghZGlzYWJsZVNraXBwYWJpbGl0eUJ5UHVibGlzaGVyKSB7XG5cdFx0XHQgIGFkVW5pdC5vbignQWRTa2lwcGFibGVTdGF0ZUNoYW5nZScsIHVwZGF0ZVNraXBCdXR0b25TdGF0ZSk7XG5cdFx0XHQgIHBsYXllclV0aWxzLm9uY2UocGxheWVyLCBbJ3Zhc3QuYWRFbmQnLCAndmFzdC5hZHNDYW5jZWwnXSwgcmVtb3ZlU2tpcEJ1dHRvbik7XG5cdFx0ICB9XG5cdCAgfVxuICB9XG5cbiAgbmV4dChudWxsLCBhZFVuaXQsIHZhc3RSZXNwb25zZSk7XG5cbiAgLyoqKiBMb2NhbCBmdW5jdGlvbiAqKiovXG4gIGZ1bmN0aW9uIHVwZGF0ZVNraXBCdXR0b25TdGF0ZSgpIHtcbiAgICBwbGF5ZXIudHJpZ2dlcigndnBhaWQuQWRTa2lwcGFibGVTdGF0ZUNoYW5nZScpO1xuICAgIGFkVW5pdC5nZXRBZFNraXBwYWJsZVN0YXRlKGZ1bmN0aW9uIChlcnJvciwgaXNTa2lwcGFibGUpIHtcbiAgICAgIGlmIChpc1NraXBwYWJsZSkge1xuICAgICAgICBpZiAoIXNraXBCdXR0b24pIHtcbiAgICAgICAgICBhZGRTa2lwQnV0dG9uKHBsYXllcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZVNraXBCdXR0b24ocGxheWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFNraXBCdXR0b24ocGxheWVyKSB7XG4gICAgc2tpcEJ1dHRvbiA9IGNyZWF0ZVNraXBCdXR0b24ocGxheWVyKTtcbiAgICBwbGF5ZXIuZWwoKS5hcHBlbmRDaGlsZChza2lwQnV0dG9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVNraXBCdXR0b24oKSB7XG4gICAgZG9tLnJlbW92ZShza2lwQnV0dG9uKTtcbiAgICBza2lwQnV0dG9uID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNraXBCdXR0b24oKSB7XG4gICAgdmFyIHNraXBCdXR0b24gPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkb20uYWRkQ2xhc3Moc2tpcEJ1dHRvbiwgXCJ2YXN0LXNraXAtYnV0dG9uXCIpO1xuICAgIGRvbS5hZGRDbGFzcyhza2lwQnV0dG9uLCBcImVuYWJsZWRcIik7XG4gICAgLy9za2lwQnV0dG9uLmlubmVySFRNTCA9IFwiU2tpcCBhZFwiO1xuICAgIHNraXBCdXR0b24uaW5uZXJIVE1MID0gd2luZG93Ll9tb2xTZXR0aW5ncy5za2lwQnV0dG9uVGV4dDtcbiAgICBza2lwQnV0dG9uLmlkID0gJ2FkU2tpcEJ1dHRvbic7XG5cbiAgICBza2lwQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBhZFVuaXQuZ2V0QWRTa2lwcGFibGVTdGF0ZShmdW5jdGlvbiAoZXJyb3IsIGlzU2tpcHBhYmxlKSB7XG4gICAgICAgICAgICBpZiAoaXNTa2lwcGFibGUpIHtcbiAgICAgICAgICAgICAgICBhZFVuaXQuc2tpcEFkKHV0aWxpdGllcy5ub29wKTsvL1dlIHNraXAgdGhlIGFkVW5pdFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFx0dHJhY2tlci50cmFja1NraXAoKTtcbiAgICAgICAgICAgICAgICBhZFVuaXQuc3RvcEFkKHV0aWxpdGllcy5ub29wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIC8vYWRVbml0LnNraXBBZCh1dGlsaXRpZXMubm9vcCk7Ly9XZSBza2lwIHRoZSBhZFVuaXRcblxuICAgICAgLy9XZSBwcmV2ZW50IGV2ZW50IHByb3BhZ2F0aW9uIHRvIGF2b2lkIHByb2JsZW1zIHdpdGggdGhlIGNsaWNrVGhyb3VnaCBhbmQgc28gb25cbiAgICAgIGlmICh3aW5kb3cuRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBza2lwQnV0dG9uO1xuICB9XG5cdFxuXHQvLyBWSURMQS0yMDg0IChwdWJsaXNoZXItc3BlY2lmaWVkIFNLSVAgYmVoYXZpb3IgZm9yIFZQQUlEIGNyZWF0aXZlcylcblx0Ly8gRU4gLSBzdXBwb3J0IHB1Ymxpc2hlciBTS0lQIHNldHRpbmdzXG5cdC8qKiogTG9jYWwgZnVuY3Rpb24gKioqL1xuXHRmdW5jdGlvbiBwdWJBZGRTa2lwQnV0dG9uVG9QbGF5ZXIocGxheWVyLCBza2lwT2Zmc2V0KSB7XG5cdCAgdmFyIHNraXBCdXR0b24gPSBwdWJDcmVhdGVTa2lwQnV0dG9uKHBsYXllcik7XG5cdCAgdmFyIHVwZGF0ZVNraXBCdXR0b24gPSBwdWJVcGRhdGVTa2lwQnV0dG9uU3RhdGUuYmluZCh0aGF0LCBza2lwQnV0dG9uLCBza2lwT2Zmc2V0KTtcblx0XG5cdCAgcGxheWVyLmVsKCkuYXBwZW5kQ2hpbGQoc2tpcEJ1dHRvbik7XG5cdCAgLy9wbGF5ZXIub24oJ3RpbWV1cGRhdGUnLCB1cGRhdGVTa2lwQnV0dG9uKTtcblx0ICBwcm9ncmVzc0ludGVydmFsID0gc2V0SW50ZXJ2YWwodXBkYXRlU2tpcEJ1dHRvbiwgNTAwKTtcblx0XG5cdCAgcGxheWVyVXRpbHMub25jZShwbGF5ZXIsIFsndmFzdC5hZEVuZCcsICd2YXN0LmFkc0NhbmNlbCddLCBwdWJSZW1vdmVTa2lwQnV0dG9uKTtcblx0XG5cdCAgZnVuY3Rpb24gcmVtb3ZlU2tpcEJ1dHRvbigpIHtcblx0ICAgIC8vcGxheWVyLm9mZigndGltZXVwZGF0ZScsIHVwZGF0ZVNraXBCdXR0b24pO1xuXHQgICAgZG9tLnJlbW92ZShza2lwQnV0dG9uKTtcblx0ICAgIHNraXBCdXR0b24gPSBudWxsO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gcHViUmVtb3ZlU2tpcEJ1dHRvbigpIHtcblx0XHQgIGlmIChwcm9ncmVzc0ludGVydmFsKSB7XG5cdFx0XHQgIGNsZWFySW50ZXJ2YWwocHJvZ3Jlc3NJbnRlcnZhbCk7XG5cdFx0XHQgIHByb2dyZXNzSW50ZXJ2YWwgPSBudWxsO1xuXHRcdCAgfVxuXHRcdCAgcmVtb3ZlU2tpcEJ1dHRvbigpO1xuXHQgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gcHViQ3JlYXRlU2tpcEJ1dHRvbihwbGF5ZXIpIHtcblx0ICB2YXIgc2tpcEJ1dHRvbiA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHQgIGRvbS5hZGRDbGFzcyhza2lwQnV0dG9uLCBcInZhc3Qtc2tpcC1idXR0b25cIik7XG5cdCAgc2tpcEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHQgIHNraXBCdXR0b24uaWQgPSAnYWRTa2lwQnV0dG9uJztcblx0XG5cdCAgc2tpcEJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIGlmIChkb20uaGFzQ2xhc3Moc2tpcEJ1dHRvbiwgJ2VuYWJsZWQnKSkge1xuXHQgICAgICAgIGFkVW5pdC5nZXRBZFNraXBwYWJsZVN0YXRlKGZ1bmN0aW9uIChlcnJvciwgaXNTa2lwcGFibGUpIHtcbiAgICAgICAgICAgICAgICBhZFVuaXQuc2tpcEFkKHV0aWxpdGllcy5ub29wKTsvL1dlIHNraXAgdGhlIGFkVW5pdFxuXHQgICAgICAgICAgICBpZiAoIWlzU2tpcHBhYmxlKSB7XG5cdCAgICAgICAgICAgIFx0dHJhY2tlci50cmFja1NraXAoKTtcblx0ICAgICAgICAgICAgICAgIGFkVW5pdC5zdG9wQWQodXRpbGl0aWVzLm5vb3ApO1xuXHQgICAgICAgICAgICBcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHBsYXllci50cmlnZ2VyKCd2YXN0LmFkc0NhbmNlbCcpO1xuXHQgICAgICAgICAgICBcdH0sIDEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICAvL2FkVW5pdC5za2lwQWQodXRpbGl0aWVzLm5vb3ApOy8vV2Ugc2tpcCB0aGUgYWRVbml0XG5cdCAgICB9XG5cdCAgICBwbGF5ZXJVdGlscy5zaG93QmlnUGxheUJ1dHRvbihwbGF5ZXIsIGZhbHNlKTtcblx0XG5cdCAgICAvL1dlIHByZXZlbnQgZXZlbnQgcHJvcGFnYXRpb24gdG8gYXZvaWQgcHJvYmxlbXMgd2l0aCB0aGUgY2xpY2tUaHJvdWdoIGFuZCBzbyBvblxuXHQgICAgaWYgKHdpbmRvdy5FdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICByZXR1cm4gc2tpcEJ1dHRvbjtcblx0fVxuXHRcblx0ZnVuY3Rpb24gcHViVXBkYXRlU2tpcEJ1dHRvblN0YXRlKHNraXBCdXR0b24sIHNraXBPZmZzZXQpIHtcblx0XHQvL3ZhciB0aW1lTGVmdCA9IE1hdGguY2VpbChza2lwT2Zmc2V0IC0gcGxheWVyLmN1cnJlbnRUaW1lKCkpO1xuXHRcdGFkVW5pdC5nZXRBZER1cmF0aW9uKGZ1bmN0aW9uKHRoYXQsIGR1cikge1xuXHRcdFx0aWYgKGR1ciA+IDApIHtcblx0XHRcdFx0ZHVyYXRpb24gPSBkdXI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0YWRVbml0LmdldEFkUmVtYWluaW5nVGltZShmdW5jdGlvbih0aGF0LCB0aW1lKSB7XG5cdFx0XHRyZW1haW5pbmdUaW1lID0gdGltZTsgXG5cdFx0fSk7XG5cdFx0aWYgKCFkdXJhdGlvbiB8fCAhcmVtYWluaW5nVGltZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvL2NvbnNvbGUubG9nKFwiKioqKioqOiBza2lwT2Zmc2V0ID0gXCIgKyBza2lwT2Zmc2V0ICsgXCIsIGR1cmF0aW9uID0gXCIgKyBkdXJhdGlvbiArIFwiLCByZW1haW5pbmdUaW1lID0gXCIgKyByZW1haW5pbmdUaW1lKTtcblx0XHQvL3ZhciByZW1haW5pbmdUaW1lID0gYWRVbml0Ll9hZFVuaXQuZ2V0QWRSZW1haW5pbmdUaW1lKCk7XG5cdFx0dmFyIHRpbWVMZWZ0ID0gTWF0aC5jZWlsKHNraXBPZmZzZXQgLSAoZHVyYXRpb24gLSByZW1haW5pbmdUaW1lKSk7XG5cdCAgaWYgKHRpbWVMZWZ0ID4gMCkge1xuXHQgICAgICBza2lwQnV0dG9uLmlubmVySFRNTCA9ICc8cCBjbGFzcz1cInZhc3Qtc2tpcC1idXR0b24tdGV4dFwiPicgKyB3aW5kb3cuX21vbFNldHRpbmdzLnNraXBUZXh0LnJlcGxhY2UoJyUlVElNRSUlJywgdXRpbGl0aWVzLnRvRml4ZWREaWdpdHModGltZUxlZnQsIDIpKSArICc8L3A+Jztcblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKCFkb20uaGFzQ2xhc3Moc2tpcEJ1dHRvbiwgJ2VuYWJsZWQnKSkge1xuXHQgICAgICBkb20uYWRkQ2xhc3Moc2tpcEJ1dHRvbiwgJ2VuYWJsZWQnKTtcblx0ICAgICAgc2tpcEJ1dHRvbi5pbm5lckhUTUwgPSB3aW5kb3cuX21vbFNldHRpbmdzLnNraXBCdXR0b25UZXh0O1xuXHQgICAgfVxuXHQgIH1cblx0ICB2YXIgaWZyYW1lQmFja0J1dHRvbiA9IHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWZyYW1lQmFja0J1dHRvbicpO1xuXHQgIGlmICghaWZyYW1lQmFja0J1dHRvbikge1xuXHRcdCAgaWYgKHBsYXllci5pc0Z1bGxzY3JlZW4oKSAmJiB1dGlsaXRpZXMuaXNBbmRyb2lkKCkpIHtcblx0XHRcdCAgc2tpcEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0ICByZXR1cm47XG5cdFx0ICB9XG5cdFx0ICBza2lwQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHQgIH1cblx0ICAvL3NraXBCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdH1cbn07XG5cblZQQUlESW50ZWdyYXRvci5wcm90b3R5cGUuX2xpbmtQbGF5ZXJDb250cm9scyA9IGZ1bmN0aW9uIChhZFVuaXQsIHZhc3RSZXNwb25zZSwgbmV4dCkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIGxpbmtWb2x1bWVDb250cm9sKHRoaXMucGxheWVyLCBhZFVuaXQpO1xuICBsaW5rRnVsbFNjcmVlbkNvbnRyb2wodGhpcy5wbGF5ZXIsIGFkVW5pdCwgdGhpcy5WSUVXX01PREUpO1xuXG4gIG5leHQobnVsbCwgYWRVbml0LCB2YXN0UmVzcG9uc2UpO1xuXG4gIC8qKiogTG9jYWwgZnVuY3Rpb25zICoqKi9cbiAgZnVuY3Rpb24gbGlua1ZvbHVtZUNvbnRyb2wocGxheWVyLCBhZFVuaXQpIHtcbiAgICBwbGF5ZXIub24oJ3ZvbHVtZWNoYW5nZScsIHVwZGF0ZUFkVW5pdFZvbHVtZSk7XG4gICAgYWRVbml0Lm9uKCdBZFZvbHVtZUNoYW5nZScsIHVwZGF0ZVBsYXllclZvbHVtZSk7XG5cbiAgICBwbGF5ZXIub25lKCd2cGFpZC5hZEVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHBsYXllci5vZmYoJ3ZvbHVtZWNoYW5nZScsIHVwZGF0ZUFkVW5pdFZvbHVtZSk7XG4gICAgfSk7XG5cblxuICAgIC8qKiogbG9jYWwgZnVuY3Rpb25zICoqKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVBZFVuaXRWb2x1bWUoKSB7XG4gICAgICB2YXIgdm9sID0gcGxheWVyLm11dGVkKCkgPyAwIDogcGxheWVyLnZvbHVtZSgpO1xuICAgICAgYWRVbml0LnNldEFkVm9sdW1lKHZvbCwgbG9nRXJyb3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBsYXllclZvbHVtZSgpIHtcblx0ICBpZiAod2luZG93Lk1vYXRBcGlSZWZlcmVuY2UpIHtcblx0XHQgIFx0d2luZG93Lk1vYXRBcGlSZWZlcmVuY2UuZGlzcGF0Y2hFdmVudCh7dHlwZTogJ0FkVm9sdW1lQ2hhbmdlJywgYWRWb2x1bWU6IHBsYXllci52b2x1bWUoKX0pO1xuXHQgIH1cbiAgICAgIHBsYXllci50cmlnZ2VyKCd2cGFpZC5BZFZvbHVtZUNoYW5nZScpO1xuICAgICAgdmFyIGxhc3RWb2x1bWUgPSBwbGF5ZXIudm9sdW1lKCk7XG4gICAgICBhZFVuaXQuZ2V0QWRWb2x1bWUoZnVuY3Rpb24gKGVycm9yLCB2b2wpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgbG9nRXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsYXN0Vm9sdW1lICE9PSB2b2wpIHtcbiAgICAgICAgICAgIHBsYXllci52b2x1bWUodm9sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmtGdWxsU2NyZWVuQ29udHJvbChwbGF5ZXIsIGFkVW5pdCwgVklFV19NT0RFKSB7XG4gICAgdmFyIHVwZGF0ZVZpZXdTaXplID0gcmVzaXplQWQuYmluZCh0aGF0LCBwbGF5ZXIsIGFkVW5pdCwgVklFV19NT0RFKTtcblxuICAgIHBsYXllci5vbignZnVsbHNjcmVlbmNoYW5nZScsIHVwZGF0ZVZpZXdTaXplKTtcblxuICAgIHBsYXllci5vbmUoJ3ZwYWlkLmFkRW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgcGxheWVyLm9mZignZnVsbHNjcmVlbmNoYW5nZScsIHVwZGF0ZVZpZXdTaXplKTtcbiAgICB9KTtcbiAgfVxufTtcblxuVlBBSURJbnRlZ3JhdG9yLnByb3RvdHlwZS5fc3RhcnRBZCA9IGZ1bmN0aW9uIChhZFVuaXQsIHZhc3RSZXNwb25zZSwgbmV4dCkge1xuICB2YXIgcGxheWVyID0gdGhpcy5wbGF5ZXI7XG4gIHZhciBhbHJlYWR5R290QWRTdGFydGVkID0gYWRVbml0LmFkU3RhcnRlZDtcblxuICBpZiAoYWxyZWFkeUdvdEFkU3RhcnRlZCkge1xuXHQgIHBsYXllci50cmlnZ2VyKCd2YXN0LmFkU3RhcnQnKTtcblx0ICBwbGF5ZXIudHJpZ2dlcih7dHlwZTogJ3RyYWNlLmV2ZW50JywgZGF0YToge2V2ZW50OiAndnBhaWQuQWRTdGFydGVkJ319KTtcbiAgfVxuICBhZFVuaXQuc3RhcnRBZChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBpZiAoIWVycm9yICYmICFhbHJlYWR5R290QWRTdGFydGVkKSB7XG4gICAgICBwbGF5ZXIudHJpZ2dlcigndmFzdC5hZFN0YXJ0Jyk7XG4gICAgfVxuICAgIG5leHQoZXJyb3IsIGFkVW5pdCwgdmFzdFJlc3BvbnNlKTtcbiAgfSk7XG59O1xuXG5WUEFJREludGVncmF0b3IucHJvdG90eXBlLl9maW5pc2hQbGF5aW5nID0gZnVuY3Rpb24gKGFkVW5pdCwgdmFzdFJlc3BvbnNlLCBuZXh0KSB7XG4gIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllcjtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICBhZFVuaXQub24oJ0FkU3RvcHBlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod2luZG93Lk1vYXRBcGlSZWZlcmVuY2UpIHtcbiAgICBcdCAgd2luZG93Lk1vYXRBcGlSZWZlcmVuY2UuZGlzcGF0Y2hFdmVudCh7dHlwZTogJ0FkU3RvcHBlZCcsIGFkVm9sdW1lOiBwbGF5ZXIudm9sdW1lKCl9KTtcbiAgICAgfVxuICAgcGxheWVyLnRyaWdnZXIoJ3ZwYWlkLkFkU3RvcHBlZCcpO1xuICAgZmluaXNoUGxheWluZ0FkKG51bGwpO1xuICB9KTtcblxuICBhZFVuaXQub24oJ0FkRXJyb3InLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgaWYgKHRoYXQuaW1wcmVzc2lvblRyaWdnZXJlZCkge1xuICAgICAgICBmaW5pc2hQbGF5aW5nQWQobnVsbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgIFx0dmFyIGVyck1zZyA9IGVycm9yPyBlcnJvci5tZXNzYWdlIDogJ29uIFZQQUlESW50ZWdyYXRvciwgZXJyb3Igd2hpbGUgd2FpdGluZyBmb3IgdGhlIGFkVW5pdCB0byBmaW5pc2ggcGxheWluZyc7XG4gICAgICAgIGZpbmlzaFBsYXlpbmdBZChuZXcgVkFTVEVycm9yKGVyck1zZykpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqKiBsb2NhbCBmdW5jdGlvbnMgKioqL1xuICB2YXIgbmVlZHNTaG93UGxheWVyID0gdGhpcy5uZWVkc1Nob3dQbGF5ZXI7XG4gIGZ1bmN0aW9uIGZpbmlzaFBsYXlpbmdBZChlcnJvcikge1xuXHQgIHRoYXQuYWRGaW5pc2hlZCA9IHRydWU7XG5cdFx0cGxheWVyVXRpbHMuc2hvd0JpZ1BsYXlCdXR0b24ocGxheWVyLCBmYWxzZSk7XG5cdFx0aWYgKG5lZWRzU2hvd1BsYXllcikge1xuXHRcdFx0aWYgKHRoYXQudGltZVVwZGF0ZVRpbWVyKSB7XG5cdFx0XHRcdGNsZWFySW50ZXJ2YWwodGhhdC50aW1lVXBkYXRlVGltZXIpO1xuXHRcdFx0XHR0aGF0LnRpbWVVcGRhdGVUaW1lciA9IG51bGw7XG5cdFx0XHRcdHZhciBiY1RpbWVEaXNwbGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JjX3RpbWVfZGlzcGxheScpO1xuXHRcdFx0XHRpZiAoYmNUaW1lRGlzcGxheSkge1xuXHRcdFx0XHRcdHBsYXllci5jb250cm9sQmFyLmdldENoaWxkKCdjdXJyZW50VGltZURpc3BsYXknKS5lbF8ucmVtb3ZlQ2hpbGQoYmNUaW1lRGlzcGxheSk7XG5cdFx0XHRcdH1cbiAgICAgICAgc2hvd09yaWdpbmFsVGltZURpc3BsYXkocGxheWVyLCB0cnVlKTtcbiAgICAgIH1cblx0ICAgIHBsYXllci5jb250cm9sQmFyLnNob3coKTtcblx0XHRcdHBsYXllci50ZWNoXy5lbF8uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0fVxuICAgIG5leHQoZXJyb3IsIGFkVW5pdCwgdmFzdFJlc3BvbnNlKTtcbiAgfVxufTtcblxuVlBBSURJbnRlZ3JhdG9yLnByb3RvdHlwZS5fdHJhY2tFcnJvciA9IGZ1bmN0aW9uIHRyYWNrRXJyb3IocmVzcG9uc2UsIGVycm9yQ29kZSkge1xuXHRpZiAoIXRoaXMuZXJyb3JIYXNCZWVuVHJhY2tlZCkge1xuXHRcdHRoaXMuZXJyb3JIYXNCZWVuVHJhY2tlZCA9IHRydWU7XG5cdFx0dmFzdFV0aWwudHJhY2socmVzcG9uc2UuZXJyb3JVUkxNYWNyb3MsIHtFUlJPUkNPREU6IGVycm9yQ29kZSB8fCA5MDF9KTtcblx0fVxufTtcblxuZnVuY3Rpb24gc2hvd09yaWdpbmFsVGltZURpc3BsYXkocGxheWVyLCBzaG93KSB7XG4gIHZhciBjaGlsZHJlbiA9IHBsYXllci5jb250cm9sQmFyLmdldENoaWxkKCdjdXJyZW50VGltZURpc3BsYXknKS5lbF8uY2hpbGRyZW47XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY2hpbGRyZW5baV0uaWQgIT0gJ2JjX3RpbWVfZGlzcGxheScpIHtcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gJycgOiAnbm9uZSc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZUFkKHBsYXllciwgYWRVbml0LCBWSUVXX01PREUpIHtcblx0dmFyIHNraXBCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWRTa2lwQnV0dG9uJyk7XG4gIHZhciB0ZWNoID0gcGxheWVyLmVsKCkucXVlcnlTZWxlY3RvcignLnZqcy10ZWNoJyk7XG4gIHZhciBkaW1lbnNpb24gPSBkb20uZ2V0RGltZW5zaW9uKHRlY2gpO1xuICB2YXIgTU9ERSA9IHBsYXllci5pc0Z1bGxzY3JlZW4oKSA/IFZJRVdfTU9ERS5GVUxMU0NSRUVOIDogVklFV19NT0RFLk5PUk1BTDtcbiAgaWYgKE1PREUgPT09IFZJRVdfTU9ERS5OT1JNQUwpIHtcbiAgICBpZiAocGxheWVyLnZhc3QpIHtcbiAgICAgIHBsYXllci52YXN0Lm5lZWRTeW5jUGxheSA9IHRydWU7XG4gICAgfVxuXHQgIGRpbWVuc2lvbi53aWR0aCA9IHBsYXllci5lbF8ub2Zmc2V0V2lkdGg7XG5cdCAgZGltZW5zaW9uLmhlaWdodCA9IHBsYXllci5lbF8ub2Zmc2V0SGVpZ2h0O1xuXHQgIGlmICh1dGlsaXRpZXMuaXNBbmRyb2lkKCkgJiYgc2tpcEJ1dHRvbikge1xuXHRcdCAgc2tpcEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0ICB9XG4gIH1cbiAgaWYgKE1PREUgPT09IFZJRVdfTU9ERS5GVUxMU0NSRUVOKSB7XG5cdCAgY29uc29sZS5sb2coJyoqKioqKiB0byBmdWxsc2NyZWVuIGRpbWVuc2lvbiA9ICcgKyBkaW1lbnNpb24ud2lkdGggKyAnLCcgKyBkaW1lbnNpb24uaGVpZ2h0KTtcblx0ICBpZiAodXRpbGl0aWVzLmlzQW5kcm9pZCgpICYmIHNraXBCdXR0b24pIHtcblx0XHQgIHNraXBCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0ICB9XG4gIH1cbiAgYWRVbml0LnJlc2l6ZUFkKGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCwgTU9ERSwgbG9nRXJyb3IpO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvcihlcnJvcikge1xuICBpZiAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IgKCdFUlJPUjogJyArIGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZQQUlESW50ZWdyYXRvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2RvbScpO1xuXG52YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuZWxlbWVudC5jbGFzc05hbWUgPSAndmpzLWFkcy1sYWJlbCB2anMtY29udHJvbCB2anMtbGFiZWwtaGlkZGVuJztcbmVsZW1lbnQuaW5uZXJIVE1MID0gJ0FkdmVydGlzZW1lbnQnO1xuXG52YXIgQWRzTGFiZWxGYWN0b3J5ID0gZnVuY3Rpb24oYmFzZUNvbXBvbmVudCkge1xuICByZXR1cm4ge1xuICAgIC8qKiBAY29uc3RydWN0b3IgKi9cbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KHBsYXllciwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucy5lbCA9IGVsZW1lbnQ7XG4gICAgICBiYXNlQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcblxuICAgICAgLy8gV2UgYXN5bmNocm9ub3VzbHkgcmVwb3NpdGlvbiB0aGUgYWRzIGxhYmVsIGVsZW1lbnRcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudFRpbWVDb21wID0gcGxheWVyLmNvbnRyb2xCYXIgJiYoIHBsYXllci5jb250cm9sQmFyLmdldENoaWxkKFwidGltZXJDb250cm9sc1wiKSB8fCBwbGF5ZXIuY29udHJvbEJhci5nZXRDaGlsZChcImN1cnJlbnRUaW1lRGlzcGxheVwiKSApO1xuICAgICAgICBpZihjdXJyZW50VGltZUNvbXApIHtcbiAgICAgICAgICBwbGF5ZXIuY29udHJvbEJhci5lbCgpLmluc2VydEJlZm9yZShlbGVtZW50LCBjdXJyZW50VGltZUNvbXAuZWwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGVsZW1lbnQsICd2anMtbGFiZWwtaGlkZGVuJyk7XG4gICAgICB9LCAwKTtcbiAgICB9LFxuXG4gICAgZWw6IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFkc0xhYmVsRmFjdG9yeTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBiYXNlVmlkZW9Kc0NvbXBvbmVudCA9IHZpZGVvanMuZ2V0Q29tcG9uZW50KCdDb21wb25lbnQnKTtcblxudmFyIEFkc0xhYmVsID0gcmVxdWlyZSgnLi9hZHMtbGFiZWwnKShiYXNlVmlkZW9Kc0NvbXBvbmVudCk7XG5cbnZpZGVvanMucmVnaXN0ZXJDb21wb25lbnQoJ0Fkc0xhYmVsJywgdmlkZW9qcy5leHRlbmQoYmFzZVZpZGVvSnNDb21wb25lbnQsIEFkc0xhYmVsKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIGNvbXBvbmVudCB0aGF0IHNob3dzIGEgYmxhY2sgc2NyZWVuIHVudGlsIHRoZSBhZHMgcGx1Z2luIGhhcyBkZWNpZGVkIGlmIGl0IGNhbiBvciBpdCBjYW4gbm90IHBsYXkgdGhlIGFkLlxuICpcbiAqIE5vdGU6IEluIGNhc2UgeW91IHdvbmRlciB3aHkgaW5zdGVhZCBvZiB0aGlzIGJsYWNrIHBvc3RlciB3ZSBkb24ndCBqdXN0IHNob3cgdGhlIHNwaW5uZXIgbG9hZGVyLlxuICogICAgICAgSU9TIGRldmljZXMgZG8gbm90IHdvcmsgd2VsbCB3aXRoIGFuaW1hdGlvbnMgYW5kIHRoZSBicm93c2VyIGNocmFzaGVzIGZyb20gdGltZSB0byB0aW1lIFRoYXQgaXMgd2h5IHdlIGNob3NlIHRvXG4gKiAgICAgICBoYXZlIGEgc2Vjb25kYXJ5IGJsYWNrIHBvc3Rlci5cbiAqXG4gKiAgICAgICBJdCBhbHNvIG1ha2VzIGl0IG11Y2ggbW9yZSBlYXNpZXIgZm9yIHRoZSB1c2VycyBvZiB0aGUgcGx1Z2luIHNpbmNlIGl0IGRvZXMgbm90IGNoYW5nZSB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhlXG4gKiAgICAgICBzcGlubmVyIGFuZCB0aGUgcGxheWVyIHdvcmtzIHRoZSBzYW1lIHdheSB3aXRoIGFuZCB3aXRob3V0IHRoZSBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHt2anMuUGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG52YXIgQmxhY2tQb3N0ZXJGYWN0b3J5ID0gZnVuY3Rpb24oYmFzZUNvbXBvbmVudCkge1xuICByZXR1cm4ge1xuICAgIC8qKiBAY29uc3RydWN0b3IgKi9cbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KHBsYXllciwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucy5lbCA9IGVsZW1lbnQ7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9ICd2anMtYmxhY2stcG9zdGVyJztcbiAgICAgIGJhc2VDb21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgcG9zdGVySW1nID0gcGxheWVyLmdldENoaWxkKCdwb3N0ZXJJbWFnZScpO1xuXG4gICAgICAvL1dlIG5lZWQgdG8gZG8gaXQgYXN5bmNocm9ub3VzbHkgdG8gYmUgc3VyZSB0aGF0IHRoZSBibGFjayBwb3N0ZXIgZWwgaXMgb24gdGhlIGRvbS5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKHBvc3RlckltZyAmJiBwbGF5ZXIgJiYgcGxheWVyLmVsKCkpIHtcbiAgICAgICAgICBwbGF5ZXIuZWwoKS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgcG9zdGVySW1nLmVsKCkpO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9LFxuICAgIGVsOiBmdW5jdGlvbiBnZXRFbGVtZW50KCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCbGFja1Bvc3RlckZhY3Rvcnk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmFzZVZpZGVvSnNDb21wb25lbnQgPSB2aWRlb2pzLmdldENvbXBvbmVudCgnQ29tcG9uZW50Jyk7XG5cbnZhciBCbGFja1Bvc3RlciA9IHJlcXVpcmUoJy4vYmxhY2stcG9zdGVyJykoYmFzZVZpZGVvSnNDb21wb25lbnQpO1xuXG52aWRlb2pzLnJlZ2lzdGVyQ29tcG9uZW50KCdCbGFja1Bvc3RlcicsIHZpZGVvanMuZXh0ZW5kKGJhc2VWaWRlb0pzQ29tcG9uZW50LCBCbGFja1Bvc3RlcikpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVkFTVENsaWVudCA9IHJlcXVpcmUoJy4uL2Fkcy92YXN0L1ZBU1RDbGllbnQnKTtcbnZhciBWQVNURXJyb3IgPSByZXF1aXJlKCcuLi9hZHMvdmFzdC9WQVNURXJyb3InKTtcbnZhciB2YXN0VXRpbCA9IHJlcXVpcmUoJy4uL2Fkcy92YXN0L3Zhc3RVdGlsJyk7XG5cbnZhciBWQVNUSW50ZWdyYXRvciA9IHJlcXVpcmUoJy4uL2Fkcy92YXN0L1ZBU1RJbnRlZ3JhdG9yJyk7XG52YXIgVlBBSURJbnRlZ3JhdG9yID0gcmVxdWlyZSgnLi4vYWRzL3ZwYWlkL1ZQQUlESW50ZWdyYXRvcicpO1xudmFyIEljb25JbnRlZ3JhdG9yID0gcmVxdWlyZSgnLi4vYWRzL2ljb24vSWNvbkludGVncmF0b3InKTtcblxudmFyIGFzeW5jID0gcmVxdWlyZSgnLi4vdXRpbHMvYXN5bmMnKTtcbnZhciBkb20gPSByZXF1aXJlKCcuLi91dGlscy9kb20nKTtcbnZhciBwbGF5ZXJVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3BsYXllclV0aWxzJyk7XG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbGl0eUZ1bmN0aW9ucycpO1xudmFyIFZpZXdhYmlsaXR5VHJhY2tpbmcgPSByZXF1aXJlKFwiLi4vdXRpbHMvYW5WaWRlb1ZpZXdhYmlsaXR5XCIpO1xuXG52YXIgbG9nZ2VyID0gcmVxdWlyZSAoJy4uL3V0aWxzL2NvbnNvbGVMb2dnZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBWQVNUUGx1Z2luKG9wdGlvbnMpIHtcbiAgdmFyIHNuYXBzaG90O1xuICB2YXIgcGxheWVyID0gdGhpcztcbiAgdmFyIHZhc3QgPSBuZXcgVkFTVENsaWVudCh7d3JhcHBlckxpbWl0OiBvcHRpb25zLndyYXBwZXJMaW1pdH0pO1xuICB2YXIgYWRzQ2FuY2VsZWQgPSBmYWxzZTtcbiAgdmFyIHBsYXlsaXN0TmV4dEJ1dHRvbjtcbiAgdmFyIGRlZmF1bHRPcHRzID0ge1xuICAgIC8vIG1heGltdW0gYW1vdW50IG9mIHRpbWUgaW4gbXMgdG8gd2FpdCB0byByZWNlaXZlIGBhZHNyZWFkeWAgZnJvbSB0aGUgYWRcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBhZnRlciBwbGF5IGhhcyBiZWVuIHJlcXVlc3RlZC4gQWQgaW1wbGVtZW50YXRpb25zIGFyZVxuICAgIC8vIGV4cGVjdGVkIHRvIGxvYWQgYW55IGR5bmFtaWMgbGlicmFyaWVzIGFuZCBtYWtlIGFueSByZXF1ZXN0cyB0byBkZXRlcm1pbmVcbiAgICAvLyBhZCBwb2xpY2llcyBmb3IgYSB2aWRlbyBkdXJpbmcgdGhpcyB0aW1lLlxuICAgIHRpbWVvdXQ6IDUwMCxcblxuICAgIC8vVE9ETzpmaW5pc2ggdGhpcyBJT1MgRklYXG4gICAgLy9XaGVuZXZlciB5b3UgcGxheSBhbiBhZGQgb24gSU9TLCB0aGUgbmF0aXZlIHBsYXllciBraWNrcyBpbiBhbmQgd2UgbG9vc2UgY29udHJvbCBvZiBpdC4gT24gdmVyeSBoZWF2eSBwYWdlcyB0aGUgJ3BsYXknIGV2ZW50XG4gICAgLy8gTWF5IG9jY3VyIGFmdGVyIHRoZSB2aWRlbyBjb250ZW50IGhhcyBhbHJlYWR5IHN0YXJ0ZWQuIFRoaXMgaXMgd3JvbmcgaWYgeW91IHdhbnQgdG8gcGxheSBhIHByZXJvbGwgYWQgdGhhdCBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSB1c2VyXG4gICAgLy8gc3RhcnRzIHdhdGNoaW5nIHRoZSBjb250ZW50LiBUbyBwcmV2ZW50IHRoaXMgdXNlY1xuICAgIGlvc1ByZXJvbGxDYW5jZWxUaW1lb3V0OiAyMDAwLFxuXG4gICAgLy8gbWF4aW11biBhbW91bnQgb2YgdGltZSBmb3IgdGhlIGFkIHRvIGFjdHVhbGx5IHN0YXJ0IHBsYXlpbmcuIElmIHRoaXMgdGltZW91dCBnZXRzXG4gICAgLy8gdHJpZ2dlcmVkIHRoZSBhZHMgd2lsbCBiZSBjYW5jZWxsZWRcbiAgICBhZENhbmNlbFRpbWVvdXQ6IDMwMDAsXG5cbiAgICAvLyBCb29sZWFuIGZsYWcgdGhhdCBjb25maWd1cmVzIHRoZSBwbGF5ZXIgdG8gcGxheSBhIG5ldyBhZCBiZWZvcmUgdGhlIHVzZXIgc2VlcyB0aGUgdmlkZW8gYWdhaW5cbiAgICAvLyB0aGUgY3VycmVudCB2aWRlb1xuICAgIHBsYXlBZEFsd2F5czogZmFsc2UsXG5cbiAgICAvLyBGbGFnIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBhZHMgYnkgZGVmYXVsdC5cbiAgICBhZHNFbmFibGVkOiB0cnVlLFxuXG4gICAgLy8gQm9vbGVhbiBmbGFnIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSByZXNpemUgd2l0aCB3aW5kb3cucmVzaXplIG9yIG9yaWVudGF0aW9uY2hhbmdlXG4gICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcblxuICAgIC8vIHZlcmJvc2l0eSBvZiBjb25zb2xlIGxvZ2dpbmc6XG4gICAgLy8gMCAtIGVycm9yXG4gICAgLy8gMSAtIGVycm9yLCB3YXJuXG4gICAgLy8gMiAtIGVycm9yLCB3YXJuLCBpbmZvXG4gICAgLy8gMyAtIGVycm9yLCB3YXJuLCBpbmZvLCBsb2dcbiAgICAvLyA0IC0gZXJyb3IsIHdhcm4sIGluZm8sIGxvZywgZGVidWdcbiAgICB2ZXJib3NpdHk6IDAsXG4gICAgXG4gICAgLy8gcGx1Z2luIG9wdGlvbnNcbiAgICBwbGF5c0luQnJlYWs6IGZhbHNlLFxuICAgIHNraXBUZXh0OiAnU2tpcCBpbiAlJVRJTUUlJSBzZWNvbmRzJyxcbiAgICBza2lwQnV0dG9uVGV4dDogJ1NraXAgYWQnLFxuICAgIGluaXRpYWxQbGF5YmFjazogXCJhdXRvXCIsXG4gICAgaW5pdGlhbEF1ZGlvOiBcIm9uXCIsXG4gICAgZGlzYWJsZUNsaWNrVGhydTogZmFsc2UsXG4gICAgXG4gICAgZmlyc3RQbGF5OiB0cnVlXG4gIH07XG5cbiAgdmFyIHNldHRpbmdzID0gdXRpbGl0aWVzLmV4dGVuZCh7fSwgZGVmYXVsdE9wdHMsIG9wdGlvbnMgfHwge30pO1xuICBcbiAgaWYodXRpbGl0aWVzLmlzVW5kZWZpbmVkKHNldHRpbmdzLmFkVGFnVXJsKSAmJiB1dGlsaXRpZXMuaXNEZWZpbmVkKHNldHRpbmdzLnVybCkpe1xuICAgIHNldHRpbmdzLmFkVGFnVXJsID0gc2V0dGluZ3MudXJsO1xuICB9XG5cbiAgaWYgKHV0aWxpdGllcy5pc1N0cmluZyhzZXR0aW5ncy5hZFRhZ1VybCkpIHtcbiAgICBzZXR0aW5ncy5hZFRhZ1VybCA9IHV0aWxpdGllcy5lY2hvRm4oc2V0dGluZ3MuYWRUYWdVcmwpO1xuICB9XG4gIFxuICBpZiAoc2V0dGluZ3Mudmlld2FiaWxpdHkgJiYgc2V0dGluZ3Mudmlld2FiaWxpdHkuY29uZmlnKSB7XG5cdCAgc2V0dGluZ3Mudmlld2FiaWxpdHlUcmFja2luZyA9IG5ldyBWaWV3YWJpbGl0eVRyYWNraW5nKHBsYXllcik7XG4gIH1cbiAgXG4gIHdpbmRvdy5fbW9sU2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgd2luZG93Ll90aW1lb3V0SWRzID0gW107XG4gIFxuICB3aW5kb3cuTW9hdEFwaVJlZmVyZW5jZSA9IG51bGw7XG5cbiAgaWYgKHV0aWxpdGllcy5pc0RlZmluZWQoc2V0dGluZ3MuYWRUYWdYTUwpICYmICF1dGlsaXRpZXMuaXNGdW5jdGlvbihzZXR0aW5ncy5hZFRhZ1hNTCkpIHtcbiAgICByZXR1cm4gdHJhY2tBZEVycm9yKG5ldyBWQVNURXJyb3IoJ29uIFZpZGVvSlMgVkFTVCBwbHVnaW4sIHRoZSBwYXNzZWQgYWRUYWdYTUwgb3B0aW9uIGRvZXMgbm90IGNvbnRhaW4gYSBmdW5jdGlvbicpKTtcbiAgfVxuXG4gIGlmICghdXRpbGl0aWVzLmlzRGVmaW5lZChzZXR0aW5ncy5hZFRhZ1VybCkgJiYgIXV0aWxpdGllcy5pc0Z1bmN0aW9uKHNldHRpbmdzLmFkVGFnWE1MKSkge1xuICAgIHJldHVybiB0cmFja0FkRXJyb3IobmV3IFZBU1RFcnJvcignb24gVmlkZW9KUyBWQVNUIHBsdWdpbiwgbWlzc2luZyBhZFRhZ1VybCBvbiBvcHRpb25zIG9iamVjdCcpKTtcbiAgfVxuXG4gIGxvZ2dlci5zZXRWZXJib3NpdHkgKHNldHRpbmdzLnZlcmJvc2l0eSk7XG5cbiAgaWYgKCFzZXR0aW5ncy5wbGF5c0luQnJlYWspIHtcblx0ICBzbmFwc2hvdCA9IHBsYXllclV0aWxzLmdldFBsYXllclNuYXBzaG90KHBsYXllcik7XG5cdCAgc25hcHNob3QucGxheWluZyA9IHRydWU7XHQvLyBmb3JjZSB0byBwbGF5IGNvbnRlbnQgYWZ0ZXIgYWQgZW5kZWRcbiAgfVxuICBcbiAgaWYgKHNldHRpbmdzLmluaXRpYWxQbGF5YmFjayA9PT0gJ2NsaWNrJykge1xuXHQgIHBsYXllclV0aWxzLnNob3dCaWdQbGF5QnV0dG9uKHBsYXllciwgdHJ1ZSk7XG4gIH1cblxuICBwbGF5ZXJVdGlscy5wcmVwYXJlRm9yQWRzKHBsYXllcik7XG5cbiAgaWYgKHNldHRpbmdzLnBsYXlBZEFsd2F5cykge1xuICAgIC8vIE5vIG1hdHRlciB3aGF0IGhhcHBlbnMgd2UgcGxheSBhIG5ldyBhZCBiZWZvcmUgdGhlIHVzZXIgc2VlcyB0aGUgdmlkZW8gYWdhaW4uXG4gICAgcGxheWVyLm9uKCd2YXN0LmNvbnRlbnRFbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGxheWVyLnRyaWdnZXIoJ3Zhc3QucmVzZXQnKTtcbiAgICAgIH0sIDApO1xuICAgIH0pO1xuICB9XG5cbiAgcGxheWVyLm9uKCd2YXN0LmZpcnN0UGxheScsIHRyeVRvUGxheVByZXJvbGxBZCk7XG5cbiAgcGxheWVyLm9uKCd2YXN0LnJlc2V0JywgZnVuY3Rpb24gKCkge1xuICAgIC8vSWYgd2UgYXJlIHJlc2V0aW5nIHRoZSBwbHVnaW4sIHdlIGRvbid0IHdhbnQgdG8gcmVzdG9yZSB0aGUgY29udGVudFxuICAgIHNuYXBzaG90ID0gbnVsbDtcbiAgICBjYW5jZWxBZHMoKTtcbiAgfSk7XG5cbiAgcGxheWVyLnZhc3QgPSB7XG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2V0dGluZ3MuYWRzRW5hYmxlZDtcbiAgICB9LFxuXG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXR0aW5ncy5hZHNFbmFibGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgc2V0dGluZ3MuYWRzRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gcGxheWVyLnZhc3Q7XG5cbiAgLyoqKiogTG9jYWwgZnVuY3Rpb25zICoqKiovXG4gIGZ1bmN0aW9uIHRyeVRvUGxheVByZXJvbGxBZCgpIHtcblx0Ly8gbWFrZSBzdXJlIHdlIGFyZSBnb2luZyB0byB1c2Ugc2FtZSBwbHVnaW4gaW5zdGFuY2UgdHdpY2Vcblx0cGxheWVyLm9mZigndmFzdC5maXJzdFBsYXknLCB0cnlUb1BsYXlQcmVyb2xsQWQpO1xuXHRcblx0cGxheWVyVXRpbHMuc2hvd0JpZ1BsYXlCdXR0b24ocGxheWVyLCBmYWxzZSk7XG5cblx0aWYgKHNldHRpbmdzLmluaXRpYWxBdWRpbyA9PT0gJ29mZicpIHtcblx0XHRzZXR0aW5ncy5jb250ZW50Vm9sdW1lID0ge211dGVkOiBwbGF5ZXIubXV0ZWQoKSwgdm9sdW1lOiBwbGF5ZXIudm9sdW1lKCl9O1xuXHRcdHBsYXllci5tdXRlZCh0cnVlKTtcblx0fVxuXG4gICAgLy9XZSByZW1vdmUgdGhlIHBvc3RlciB0byBwcmV2ZW50IGZsaWNrZXJpbmcgd2hlbmV2ZXIgdGhlIGNvbnRlbnQgc3RhcnRzIHBsYXlpbmdcbiAgICBwbGF5ZXJVdGlscy5yZW1vdmVOYXRpdmVQb3N0ZXIocGxheWVyKTtcblxuICAgIHBsYXllclV0aWxzLm9uY2UocGxheWVyLCBbJ3Zhc3QuYWRzQ2FuY2VsJywgJ3Zhc3QuYWRFbmQnXSwgZnVuY3Rpb24gKCkge1xuICAgIFx0cGxheWVyVXRpbHMuc2hvd0JpZ1BsYXlCdXR0b24ocGxheWVyLCBmYWxzZSk7XG4gICAgICByZW1vdmVBZFVuaXQoKTtcbiAgICAgIHJlc3RvcmVWaWRlb0NvbnRlbnQoKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBsYXllci50cmlnZ2VyKCdhZEZpbmlzaGVkJyk7XG4gICAgICB9LCAwKTtcbiAgICB9KTtcblxuICAgIGFzeW5jLndhdGVyZmFsbChbXG4gICAgICBjaGVja0Fkc0VuYWJsZWQsXG4gICAgICBwcmVwYXJlUGxheWVyRm9yQWQsXG4gICAgICBzdGFydEFkQ2FuY2VsVGltZW91dCxcbiAgICAgIHBsYXlQcmVyb2xsQWRcbiAgICBdLCBmdW5jdGlvbiAoZXJyb3IsIHJlc3BvbnNlKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdHJhY2tBZEVycm9yKGVycm9yLCByZXNwb25zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwbGF5ZXIudHJpZ2dlcigndmFzdC5hZEVuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqKiBMb2NhbCBmdW5jdGlvbnMgKioqL1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQWRVbml0KCkge1xuICAgICAgaWYgKHBsYXllci52YXN0ICYmIHBsYXllci52YXN0LmFkVW5pdCkge1xuICAgICAgICBwbGF5ZXIudmFzdC5hZFVuaXQgPSBudWxsOyAvL1dlIHJlbW92ZSB0aGUgYWRVbml0XG4gICAgICAgIHBsYXllci52YXN0LlZQQUlEID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5fbW9sU2V0dGluZ3MuZmlyc3RQbGF5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdG9yZVZpZGVvQ29udGVudCgpIHtcbiAgICAgIHNldHVwQ29udGVudEV2ZW50cygpO1xuICAgICAgaWYgKHNuYXBzaG90KSB7XG4gICAgICAgIHBsYXllclV0aWxzLnJlc3RvcmVQbGF5ZXJTbmFwc2hvdChwbGF5ZXIsIHNuYXBzaG90KTtcbiAgICAgICAgc25hcHNob3QgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwQ29udGVudEV2ZW50cygpIHtcbiAgICAgIHBsYXllclV0aWxzLm9uY2UocGxheWVyLCBbJ3BsYXlpbmcnLCAndmFzdC5yZXNldCcsICd2YXN0LmZpcnN0UGxheSddLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGlmIChldnQudHlwZSAhPT0gJ3BsYXlpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcGxheWVyLnRyaWdnZXIoJ3Zhc3QuY29udGVudFN0YXJ0Jyk7XG5cbiAgICAgICAgcGxheWVyVXRpbHMub25jZShwbGF5ZXIsIFsnZW5kZWQnLCAndmFzdC5yZXNldCcsICd2YXN0LmZpcnN0UGxheSddLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgaWYgKGV2dC50eXBlID09PSAnZW5kZWQnKSB7XG4gICAgICAgICAgICBwbGF5ZXIudHJpZ2dlcigndmFzdC5jb250ZW50RW5kJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrQWRzRW5hYmxlZChuZXh0KSB7XG4gICAgICBpZiAoc2V0dGluZ3MuYWRzRW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gbmV4dChudWxsKTtcbiAgICAgIH1cbiAgICAgIG5leHQobmV3IFZBU1RFcnJvcignQWRzIGFyZSBub3QgZW5hYmxlZCcpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlUGxheWVyRm9yQWQobmV4dCkge1xuICAgICAgaWYgKGNhblBsYXlQcmVyb2xsQWQoKSkge1xuICAgICAgICAvL3NuYXBzaG90ID0gcGxheWVyVXRpbHMuZ2V0UGxheWVyU25hcHNob3QocGxheWVyKTtcbiAgICAgICAgcGxheWVyLnBhdXNlKCk7XG4gICAgICAgIGFkZFNwaW5uZXJJY29uKCk7XG5cbiAgICAgICAgaWYocGxheWVyLnBhdXNlZCgpKSB7XG4gICAgICAgICAgbmV4dChudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwbGF5ZXJVdGlscy5vbmNlKHBsYXllciwgWydwbGF5aW5nJ10sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcGxheWVyLnBhdXNlKCk7XG4gICAgICAgICAgICBuZXh0KG51bGwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0KG5ldyBWQVNURXJyb3IoJ3ZpZGVvIGNvbnRlbnQgaGFzIGJlZW4gcGxheWluZyBiZWZvcmUgcHJlcm9sbCBhZCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5QbGF5UHJlcm9sbEFkKCkge1xuICAgICAgcmV0dXJuICF1dGlsaXRpZXMuaXNJUGhvbmUoKSB8fCBwbGF5ZXIuY3VycmVudFRpbWUoKSA8PSBzZXR0aW5ncy5pb3NQcmVyb2xsQ2FuY2VsVGltZW91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydEFkQ2FuY2VsVGltZW91dChuZXh0KSB7XG4gICAgICB2YXIgYWRDYW5jZWxUaW1lb3V0SWQ7XG4gICAgICBhZHNDYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgICBhZENhbmNlbFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgIFx0ICBhZENhbmNlbFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIHRyYWNrQWRFcnJvcihuZXcgVkFTVEVycm9yKCd0aW1lb3V0IHdoaWxlIHdhaXRpbmcgZm9yIHRoZSB2aWRlbyB0byBzdGFydCBwbGF5aW5nJywgNDAyKSk7XG4gICAgICAgIHBsYXllclV0aWxzLnNob3dCaWdQbGF5QnV0dG9uKHBsYXllciwgZmFsc2UpO1xuICAgICAgICBpZiAocGxheWVyLnZhc3QuVlBBSUQpIHtcbiAgICAgICAgXHRwbGF5ZXIudHJpZ2dlcigndnBhaWQuYWRFbmQnKTtcbiAgICAgICAgfVxuICAgICAgfSwgc2V0dGluZ3MuYWRDYW5jZWxUaW1lb3V0KTtcblxuICAgICAgcGxheWVyVXRpbHMub25jZShwbGF5ZXIsIFsndmFzdC5hZFN0YXJ0JywgJ3Zhc3QuYWRzQ2FuY2VsJywgJ2NsZWFyQWRDYW5jZWxUaW1lb3V0J10sIGNsZWFyQWRDYW5jZWxUaW1lb3V0KTtcbiAgICAgIHBsYXllclV0aWxzLm9uY2UocGxheWVyLCBbJ3Zhc3QuYWRFcnJvcicsICd2cGFpZC5hZEVuZCcsICd2cGFpZC5hZEVycm9yJ10sIGZ1bmN0aW9uKCkge1xuICAgIFx0ICBjbGVhckFkQ2FuY2VsVGltZW91dCgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8qKiogbG9jYWwgZnVuY3Rpb25zICoqKi9cbiAgICAgIGZ1bmN0aW9uIGNsZWFyQWRDYW5jZWxUaW1lb3V0KCkge1xuICAgICAgICBpZiAoYWRDYW5jZWxUaW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoYWRDYW5jZWxUaW1lb3V0SWQpO1xuICAgICAgICAgIGFkQ2FuY2VsVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0KG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFNwaW5uZXJJY29uKCkge1xuICAgICAgZG9tLmFkZENsYXNzKHBsYXllci5lbCgpLCAndmpzLXZhc3QtYWQtbG9hZGluZycpO1xuICAgICAgcGxheWVyVXRpbHMub25jZShwbGF5ZXIsIFsndmFzdC5hZFN0YXJ0JywgJ3Zhc3QuYWRzQ2FuY2VsJ10sIHJlbW92ZVNwaW5uZXJJY29uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVTcGlubmVySWNvbigpIHtcbiAgICAgIC8vSU1QT1JUQU5UIE5PVEU6IFdlIHJlbW92ZSB0aGUgc3Bpbm5lckljb24gYXN5bmNocm9ub3VzbHkgdG8gZ2l2ZSB0aW1lIHRvIHRoZSBicm93c2VyIHRvIHN0YXJ0IHRoZSB2aWRlby5cbiAgICAgIC8vIElmIHdlIHJlbW92ZSBpdCBzeW5jaHJvbm91c2x5IHdlIHNlZSBhIGZsYXNoIG9mIHRoZSBjb250ZW50IHZpZGVvIGJlZm9yZSB0aGUgYWQgc3RhcnRzIHBsYXlpbmcuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKHBsYXllci5lbCgpLCAndmpzLXZhc3QtYWQtbG9hZGluZycpO1xuICAgICAgICAvLyBWSURMQS0yMjY4IChTYWZhcmkgMTEgb24gTWFjIC0gU3Bpbm5lciBrZWVwcyBnb2luZyBvbiBmaXJzdCBmcmFtZSBvZiBhZClcblx0XHRwbGF5ZXIubG9hZGluZ1NwaW5uZXIuZWxfLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9LCAxMDApO1xuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsQWRzKCkge1xuICAgIHBsYXllci50cmlnZ2VyKCd2YXN0LmFkc0NhbmNlbCcpO1xuICAgIGFkc0NhbmNlbGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYXlQcmVyb2xsQWQoY2FsbGJhY2spIHtcbiAgICBhc3luYy53YXRlcmZhbGwoW1xuICAgICAgZ2V0VmFzdFJlc3BvbnNlLFxuICAgICAgcGxheUFkXG4gICAgXSwgY2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VmFzdFJlc3BvbnNlKGNhbGxiYWNrKSB7XG4gICAgdmFzdC5nZXRWQVNUUmVzcG9uc2Uoc2V0dGluZ3MuYWRUYWdVcmwgPyBzZXR0aW5ncy5hZFRhZ1VybCgpIDogc2V0dGluZ3MuYWRUYWdYTUwsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYXlBZCh2YXN0UmVzcG9uc2UsIGNhbGxiYWNrKSB7XG4gICAgLy9UT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byBzdG9wIHRoZSBwbGF5LiBUaGUgJ3BsYXlQcmVyb2xsV2F0ZXJmYWxsJyBlbmRzIGluIGFuIGluY29uc2lzdGVudCBzaXR1YXRpb25cbiAgICAvL0lmIHRoZSBzdGF0ZSBpcyBub3QgJ3ByZXJvbGw/JyBpdCBtZWFucyB0aGUgYWRzIHdlcmUgY2FuY2VsZWQgdGhlcmVmb3JlLCB3ZSBicmVhayB0aGUgd2F0ZXJmYWxsXG4gICAgaWYgKGFkc0NhbmNlbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLypDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNiBNb2F0IEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC4qL1xuICAgIGZ1bmN0aW9uIGluaXRNb2F0VHJhY2tpbmcoYSxjLGQsaCxrKXt2YXIgZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpLGI9W107Yz17YWREYXRhOntpZHM6YyxkdXJhdGlvbjpkLHVybDprfSxkaXNwYXRjaEV2ZW50OmZ1bmN0aW9uKGEpe3RoaXMuc2VuZEV2ZW50PyhiJiYoYi5wdXNoKGEpLGE9YixiPSExKSx0aGlzLnNlbmRFdmVudChhKSk6Yi5wdXNoKGEpfX07ZD1cIl9tb2F0QXBpXCIrTWF0aC5mbG9vcigxRTgqTWF0aC5yYW5kb20oKSk7dmFyIGUsZzt0cnl7ZT1hLm93bmVyRG9jdW1lbnQsZz1lLmRlZmF1bHRWaWV3fHxlLnBhcmVudFdpbmRvd31jYXRjaChsKXtlPWRvY3VtZW50LGc9d2luZG93fWdbZF09YztmLnR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIjthJiZhLmluc2VydEJlZm9yZShmLGEuY2hpbGROb2Rlc1swXXx8bnVsbCk7Zi5zcmM9XCJodHRwczovL3oubW9hdGFkcy5jb20vXCIraCtcIi9tb2F0dmlkZW8uanMjXCIrZDtyZXR1cm4gY307XG4gICAgd2luZG93Lk1vYXRBcGlSZWZlcmVuY2UgPSBudWxsO1xuICAgIGlmICh2YXN0UmVzcG9uc2UuYWRzICYmIHZhc3RSZXNwb25zZS5hZHMubGVuZ3RoID4gMCAmJiB2YXN0UmVzcG9uc2UuYWRzWzBdLmluTGluZSAmJiB2YXN0UmVzcG9uc2UuYWRzWzBdLmluTGluZS5tb2F0KSB7XG4gIFx0ICB2YXIgaWRzID0ge2xldmVsMTogdmFzdFJlc3BvbnNlLmFkc1swXS5pbkxpbmUubW9hdC5hZHZpZCxcbiAgXHRcdFx0ICAgICBsZXZlbDI6IHZhc3RSZXNwb25zZS5hZHNbMF0uaW5MaW5lLm1vYXQuY3BnaWQsXG4gIFx0XHRcdCAgICAgbGV2ZWwzOiB2YXN0UmVzcG9uc2UuYWRzWzBdLmluTGluZS5tb2F0LmNwaWQsXG4gIFx0XHRcdCAgICAgbGV2ZWw0OiB2YXN0UmVzcG9uc2UuYWRzWzBdLmluTGluZS5tb2F0LmNyaWR9O1xuICBcdCAgaWYgKHZhc3RSZXNwb25zZS5hZHNbMF0uaW5MaW5lLm1vYXQuc2l0ZV9pZCkge1xuICBcdFx0ICBpZHMuc2xpY2VyMSA9IHZhc3RSZXNwb25zZS5hZHNbMF0uaW5MaW5lLm1vYXQuc2l0ZV9pZDtcbiAgXHQgIH1cbiAgXHQgIC8vd2luZG93Lk1vYXRBcGlSZWZlcmVuY2UgPSBpbml0TW9hdFRyYWNraW5nKHBsYXllci5lbF8sIGlkcywgcGxheWVyLmR1cmF0aW9uKCksIHZhc3RSZXNwb25zZS5hZHNbMF0uaW5MaW5lLm1vYXQucGFydG5lcmNvZGUsIHBsYXllci5jdXJyZW50U291cmNlKCkuc3JjKTtcbiAgXHQgIHdpbmRvdy5Nb2F0QXBpUmVmZXJlbmNlID0gaW5pdE1vYXRUcmFja2luZyhwbGF5ZXIuZWxfLCBpZHMsIHBsYXllci5kdXJhdGlvbigpLCAnbmluZW1lZGlhdnBhaWQ3ODk2MTE2NCcsIHBsYXllci5jdXJyZW50U291cmNlKCkuc3JjKTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5fbW9sU2V0dGluZ3Mudmlld2FiaWxpdHlUcmFja2luZykge1xuICBcdCAgd2luZG93Ll9tb2xTZXR0aW5ncy52aWV3YWJpbGl0eVRyYWNraW5nLmluaXQod2luZG93Ll9tb2xTZXR0aW5ncy52aWV3YWJpbGl0eS5jb250ZXh0SWQsIFxuICBcdFx0XHQgIHBsYXllci5kdXJhdGlvbigpLCBwbGF5ZXIuZWxfLm9mZnNldFdpZHRoLCBwbGF5ZXIuZWxfLm9mZnNldEhlaWdodCk7XG4gICAgfVxuXG4gICAgdmFyIGlzQWRWUEFJRCAgPSBpc1ZQQUlEKHZhc3RSZXNwb25zZSk7XG4gICAgdmFyIGFkSW50ZWdyYXRvciA9IGlzQWRWUEFJRCA/IG5ldyBWUEFJREludGVncmF0b3IocGxheWVyLCBzZXR0aW5ncykgOiBuZXcgVkFTVEludGVncmF0b3IocGxheWVyKTtcbiAgICB2YXIgYWRGaW5pc2hlZCA9IGZhbHNlO1xuICAgIGlmIChpc0FkVlBBSUQpIHtcbiAgICBcdHBsYXllci50cmlnZ2VyKCdjbGVhckFkQ2FuY2VsVGltZW91dCcpO1xuICAgIH1cblxuICAgIHBsYXllclV0aWxzLm9uY2UocGxheWVyLCBbJ3Zhc3QuYWRTdGFydCcsICd2YXN0LmFkc0NhbmNlbCddLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoZXZ0LnR5cGUgPT09ICd2YXN0LmFkU3RhcnQnKSB7XG4gICAgICAgIGFkZEFkc0xhYmVsKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwbGF5ZXJVdGlscy5vbmNlKHBsYXllciwgWyd2YXN0LmFkRW5kJywgJ3Zhc3QuYWRzQ2FuY2VsJ10sIHJlbW92ZUFkc0xhYmVsKTtcblxuICAgIGlmICh1dGlsaXRpZXMuaXNJRGV2aWNlKCkpIHtcbiAgICAgIHByZXZlbnRNYW51YWxQcm9ncmVzcygpO1xuICAgIH1cblxuICAgIHBsYXllci52YXN0LnZhc3RSZXNwb25zZSA9IHZhc3RSZXNwb25zZTtcbiAgICBsb2dnZXIuZGVidWcgKFwiY2FsbGluZyBhZEludGVncmF0b3IucGxheUFkKCkgd2l0aCB2YXN0UmVzcG9uc2U6XCIsIHZhc3RSZXNwb25zZSk7XG4gICAgcGxheWVyLnZhc3QuYWRVbml0ID0gYWRJbnRlZ3JhdG9yLnBsYXlBZCh2YXN0UmVzcG9uc2UsIGNhbGxiYWNrKTtcbiAgICBwbGF5ZXIudmFzdC5WUEFJRCA9IGlzQWRWUEFJRDtcblxuICAgIHZhciBhZEljb25JbnRlZ3JhdG9yO1xuXG4gICAgLyoqKiBMb2NhbCBmdW5jdGlvbnMgKioqKi9cbiAgICBmdW5jdGlvbiBhZGRBZHNMYWJlbCgpIHtcbiAgICBcdGlmICh3aW5kb3cuX21vbFNldHRpbmdzLnBsYXlzSW5CcmVhaykge1xuICAgIFx0XHRwbGF5ZXIub24oJ3RpbWV1cGRhdGUnLCB1cGRhdGVUaW1lQ29udHJvbHMpO1xuICAgIFx0fVxuICAgICAgaWYgKGFkRmluaXNoZWQgfHwgcGxheWVyLmNvbnRyb2xCYXIuZ2V0Q2hpbGQoJ0Fkc0xhYmVsJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwbGF5ZXIuY29udHJvbEJhci5hZGRDaGlsZCgnQWRzTGFiZWwnKTtcbiAgICAgIGlmICh2YXN0UmVzcG9uc2UuaWNvbnMgJiYgdmFzdFJlc3BvbnNlLmljb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWRJY29uSW50ZWdyYXRvciA9IG5ldyBJY29uSW50ZWdyYXRvcihwbGF5ZXIpO1xuICAgICAgICBhZEljb25JbnRlZ3JhdG9yLnJlbmRlckljb25zKHZhc3RSZXNwb25zZS5pY29ucywgY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd2anMtbmV4dC1idXR0b24nKTtcbiAgICAgIGlmIChlbGVtcyAmJiBlbGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBsYXlsaXN0TmV4dEJ1dHRvbiA9IGVsZW1zWzBdO1xuICAgICAgICBwbGF5bGlzdE5leHRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVBZHNMYWJlbCgpIHtcbiAgICBcdGlmICh3aW5kb3cuX21vbFNldHRpbmdzLnBsYXlzSW5CcmVhaykge1xuICAgIFx0XHRwbGF5ZXIub2ZmKCd0aW1ldXBkYXRlJywgdXBkYXRlVGltZUNvbnRyb2xzKTtcbiAgICBcdFx0aWYgKHdpbmRvdy5fbW9sU2V0dGluZ3MudGltZU9mZnNldCkge1xuICAgICAgICBzaG93T3JpZ2luYWxUaW1lRGlzcGxheSh0cnVlKTtcblx0XHRcdFx0dmFyIGJjVGltZURpc3BsYXkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmNfdGltZV9kaXNwbGF5Jyk7XG5cdFx0XHRcdGlmIChiY1RpbWVEaXNwbGF5KSB7XG5cdFx0XHRcdFx0YmNUaW1lRGlzcGxheS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0XHR9XG4gICAgXHRcdH1cbiAgICBcdH1cbiAgICAgIHBsYXllci5jb250cm9sQmFyLnJlbW92ZUNoaWxkKCdBZHNMYWJlbCcpO1xuICAgICAgaWYgKHBsYXlsaXN0TmV4dEJ1dHRvbikge1xuICAgICAgICBwbGF5bGlzdE5leHRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICBwbGF5bGlzdE5leHRCdXR0b24gPSBudWxsO1xuICAgICAgfVxuICAgICAgYWRGaW5pc2hlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvd09yaWdpbmFsVGltZURpc3BsYXkoc2hvdykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcGxheWVyLmNvbnRyb2xCYXIuZ2V0Q2hpbGQoJ2N1cnJlbnRUaW1lRGlzcGxheScpLmVsXy5jaGlsZHJlbjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLmlkICE9ICdiY190aW1lX2Rpc3BsYXknKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUuZGlzcGxheSA9IHNob3cgPyAnJyA6ICdub25lJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRpbWVDb250cm9scygpIHtcbiAgICBcdHZhciBjb252ZXJ0VGltZVRvU3RyID0gZnVuY3Rpb24odGltZSkge1xuICAgIFx0XHR2YXIgc2VjcyA9IHBhcnNlSW50KHRpbWUgKyAwLjUpO1xuICAgIFx0XHR2YXIgbWlucyA9IHBhcnNlSW50KHNlY3MgLyA2MCk7XG4gICAgXHRcdHNlY3MgLT0gKG1pbnMgKiA2MCk7XG4gICAgXHRcdHZhciBzdHIgPSBtaW5zLnRvU3RyaW5nKCkgKyAnOicgKyAoc2VjcyA+IDkgPyAnJyAgOiAnMCcpICsgc2Vjcy50b1N0cmluZygpO1xuICAgIFx0XHRyZXR1cm4gc3RyO1xuICAgIFx0fTtcbiAgICBcdFxuICAgICAgaWYgKHdpbmRvdy5fbW9sU2V0dGluZ3MuYnJlYWtEdXJhdGlvbikge1xuICAgICAgICBpZiAocGxheWVyLmR1cmF0aW9uKCkgIT0gd2luZG93Ll9tb2xTZXR0aW5ncy5icmVha0R1cmF0aW9uKSB7XG4gICAgICAgICAgaWYgKHBsYXllci5kdXJhdGlvbigpKSB7XG4gICAgICAgICAgICB3aW5kb3cuX21vbFNldHRpbmdzLnJlYWxWaWRlb0R1cmF0aW9uID0gcGxheWVyLmR1cmF0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBsYXllci5kdXJhdGlvbih3aW5kb3cuX21vbFNldHRpbmdzLmJyZWFrRHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAod2luZG93Ll9tb2xTZXR0aW5ncy50aW1lT2Zmc2V0KSB7XG4gICAgICAgIHZhciBiY1RpbWVEaXNwbGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JjX3RpbWVfZGlzcGxheScpO1xuICAgICAgICBpZiAoIWJjVGltZURpc3BsYXkpIHtcbiAgICAgICAgICBiY1RpbWVEaXNwbGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgcGxheWVyLmNvbnRyb2xCYXIuZ2V0Q2hpbGQoJ2N1cnJlbnRUaW1lRGlzcGxheScpLmVsXy5hcHBlbmRDaGlsZChiY1RpbWVEaXNwbGF5KTtcbiAgICAgICAgICBiY1RpbWVEaXNwbGF5LmlkID0gJ2JjX3RpbWVfZGlzcGxheSc7XG4gICAgICAgICAgYmNUaW1lRGlzcGxheS5jbGFzcyA9ICd2anMtY3VycmVudC10aW1lLWRpc3BsYXknO1xuICAgICAgICAgIGJjVGltZURpc3BsYXlbJ2FyaWEtbGl2ZSddID0gJ29mZic7XG4gICAgICAgICAgYmNUaW1lRGlzcGxheS5pbm5lckhUTUwgPSAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PC9zcGFuPjA6MDAnO1xuICAgICAgICAgIHNob3dPcmlnaW5hbFRpbWVEaXNwbGF5KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzaG93T3JpZ2luYWxUaW1lRGlzcGxheShmYWxzZSk7XG4gICAgICAgICAgYmNUaW1lRGlzcGxheS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGltZSA9IHBsYXllci5jdXJyZW50VGltZSgpICsgd2luZG93Ll9tb2xTZXR0aW5ncy50aW1lT2Zmc2V0O1xuICAgICAgICBiY1RpbWVEaXNwbGF5LmNoaWxkTm9kZXNbMV0ubm9kZVZhbHVlID0gY29udmVydFRpbWVUb1N0cih0aW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmV2ZW50TWFudWFsUHJvZ3Jlc3MoKSB7XG4gICAgICAvL0lPUyB2aWRlbyBjbG9jayBpcyB2ZXJ5IHVucmVsaWFibGUgYW5kIHdlIG5lZWQgYSAzIHNlY29uZHMgdGhyZXNob2xkIHRvIGVuc3VyZSB0aGF0IHRoZSB1c2VyIGZvcndhcmRlZC9yZXdvdW5kIHRoZSBhZFxuICAgICAgdmFyIFBST0dSRVNTX1RIUkVTSE9MRCA9IDM7XG4gICAgICB2YXIgcHJldmlvdXNUaW1lID0gMDtcbiAgICAgIHZhciBza2lwYWRfYXR0ZW1wdHMgPSAwO1xuXG4gICAgICBwbGF5ZXIub24oJ3RpbWV1cGRhdGUnLCBwcmV2ZW50QWRTZWVrKTtcbiAgICAgIHBsYXllci5vbignZW5kZWQnLCBwcmV2ZW50QWRTa2lwKTtcblxuICAgICAgcGxheWVyVXRpbHMub25jZShwbGF5ZXIsIFsndmFzdC5hZEVuZCcsICd2YXN0LmFkc0NhbmNlbCcsICd2YXN0LmFkRXJyb3InXSwgc3RvcFByZXZlbnRNYW51YWxQcm9ncmVzcyk7XG5cbiAgICAgIC8qKiogTG9jYWwgZnVuY3Rpb25zICoqKi9cbiAgICAgIGZ1bmN0aW9uIHByZXZlbnRBZFNraXAoKSB7XG4gICAgICAgIC8vIElnbm9yZSBlbmRlZCBldmVudCBpZiB0aGUgQWQgdGltZSB3YXMgbm90ICduZWFyJyB0aGUgZW5kXG4gICAgICAgIC8vIGFuZCByZXZlcnQgdGltZSB0byB0aGUgcHJldmlvdXMgJ3ZhbGlkJyB0aW1lXG4gICAgICAgIGlmICgocGxheWVyLmR1cmF0aW9uKCkgLSBwcmV2aW91c1RpbWUpID4gUFJPR1JFU1NfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgcGxheWVyLnBhdXNlKHRydWUpOyAvLyB0aGlzIHJlZHVjZSB0aGUgdmlkZW8gaml0dGVyIGlmIHRoZSBJT1Mgc2tpcCBidXR0b24gaXMgcHJlc3NlZFxuICAgICAgICAgIHBsYXllci5wbGF5KHRydWUpOyAvLyB3ZSBuZWVkIHRvIHRyaWdnZXIgdGhlIHBsYXkgdG8gcHV0IHRoZSB2aWRlbyBlbGVtZW50IGJhY2sgaW4gYSB2YWxpZCBzdGF0ZVxuICAgICAgICAgIHBsYXllci5jdXJyZW50VGltZShwcmV2aW91c1RpbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByZXZlbnRBZFNlZWsoKSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IHBsYXllci5jdXJyZW50VGltZSgpO1xuICAgICAgICB2YXIgcHJvZ3Jlc3NEZWx0YSA9IE1hdGguYWJzKGN1cnJlbnRUaW1lIC0gcHJldmlvdXNUaW1lKTtcbiAgICAgICAgaWYgKHByb2dyZXNzRGVsdGEgPiBQUk9HUkVTU19USFJFU0hPTEQpIHtcbiAgICAgICAgICBza2lwYWRfYXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgICBpZiAoc2tpcGFkX2F0dGVtcHRzID49IDIpIHtcbiAgICAgICAgICAgIHBsYXllci5wYXVzZSh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGxheWVyLmN1cnJlbnRUaW1lKHByZXZpb3VzVGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3RvcFByZXZlbnRNYW51YWxQcm9ncmVzcygpIHtcbiAgICAgICAgcGxheWVyLm9mZigndGltZXVwZGF0ZScsIHByZXZlbnRBZFNlZWspO1xuICAgICAgICBwbGF5ZXIub2ZmKCdlbmRlZCcsIHByZXZlbnRBZFNraXApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWNrQWRFcnJvcihlcnJvciwgdmFzdFJlc3BvbnNlKSB7XG4gICAgcGxheWVyLnRyaWdnZXIoe3R5cGU6ICd2YXN0LmFkRXJyb3InLCBlcnJvcjogZXJyb3J9KTtcbiAgICBjYW5jZWxBZHMoKTtcbiAgICBsb2dnZXIuZXJyb3IgKCdBRCBFUlJPUjonLCBlcnJvci5tZXNzYWdlLCBlcnJvciwgdmFzdFJlc3BvbnNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVlBBSUQodmFzdFJlc3BvbnNlKSB7XG4gICAgdmFyIGksIGxlbjtcbiAgICB2YXIgbWVkaWFGaWxlcyA9IHZhc3RSZXNwb25zZS5tZWRpYUZpbGVzO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IG1lZGlhRmlsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh2YXN0VXRpbC5pc1ZQQUlEKG1lZGlhRmlsZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG4iLCIvKipcbiAqIFZpZXdhYmlsaXR5IFdyYXBwZXJcbiAqL1xuXG4vL3ZhciBBTlZpZGVvVmlld2FiaWxpdHlUcmFja2VyID0gcmVxdWlyZShcImFuLXZpZGVvLXZpZXdhYmlsaXR5XCIpOy8vdmlld2FiaWxpdHkgbGlicmFyeVxudmFyIEFOVmlkZW9WaWV3YWJpbGl0eVRyYWNrZXIgPSBudWxsO1xudmFyIGxvZ2dlciA9IHJlcXVpcmUoXCIuL2NvbnNvbGVMb2dnZXJcIik7XG52YXIgZGVidWcgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhtZXNzYWdlKTtcbn07XG52YXIgaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgbG9nZ2VyLmluZm8obWVzc2FnZSk7XG59O1xuXG52YXIgaHRtbDVWaWRlb1ZpZXdhYmlsaXR5ID0gZnVuY3Rpb24gKHBsYXllcl8pIHtcblxuXHR2YXIgcGxheWVyID0gcGxheWVyXztcbiAgICB2YXIgdHJhY2tlciA9IG51bGw7XG4gICAgdmFyIG1hcHBlZEFjdGlvbnMgPSB7XG4gICAgICAgIFwic3RhcnRcIjogXCJzdGFydFwiLFxuICAgICAgICBcImV4cGFuZFwiOiBcImV4cGFuZFwiLFxuICAgICAgICBcImNvbGxhcHNlXCI6IFwiY29sbGFwc2VcIixcbiAgICAgICAgXCJ1bm11dGVcIjogXCJzb3VuZF9vblwiLFxuICAgICAgICBcIm11dGVcIjogXCJzb3VuZF9vZmZcIixcbiAgICAgICAgXCJwYXVzZVwiOiBcInBhdXNlXCIsXG4gICAgICAgIFwicmVzdW1lXCI6IFwicmVzdW1lXCIsXG4gICAgICAgIFwiYWQtY2xpY2tcIjogXCJjbGlja1wiLFxuICAgICAgICBcInNraXBcIjogXCJzdG9wXCIsXG4gICAgICAgIFwiY29tcGxldGVcIjogXCJzdG9wXCIsXG4gICAgICAgIFwiZnVsbHNjcmVlblwiOiBcImZ1bGxzY3JlZW5cIixcbiAgICAgICAgXCJleGl0RnVsbHNjcmVlblwiOiBcImV4aXRGdWxsc2NyZWVuXCJcbiAgICB9O1xuXG4gICAgdmFyIGZpcmVPbmNlRXZlbnRzID0ge1xuICAgICAgICBcInN0YXJ0XCI6IGZhbHNlLFxuICAgICAgICBcInNraXBcIjogZmFsc2UsXG4gICAgICAgIFwiY29tcGxldGVcIjogZmFsc2VcbiAgICB9O1xuXG4gICAgdmFyIGdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5fbW9sU2V0dGluZ3Mudmlld2FiaWxpdHkgJiYgd2luZG93Ll9tb2xTZXR0aW5ncy52aWV3YWJpbGl0eS5jb25maWc7XG4gICAgfTtcblxuICAgIHZhciBnZXRQbGF5ZXJET01FbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGxheWVyLmVsXztcbiAgICB9O1xuXG4gICAgdmFyIGdldFZpZGVvSW5mbyA9IGZ1bmN0aW9uIChkdXJhdGlvbiwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4ge2R1cmF0aW9uOiBkdXJhdGlvbiwgdzogd2lkdGgsIGg6IGhlaWdodH07XG4gICAgfTtcblxuXHQvLyBVc2luZyBjYWxsYmFjayBmb3IgbG9ncyBoZWxwcyBnZXR0aW5nIGEgcmlnaHQgbG9nZ2VyIGluIGVhY2ggYXBwXG5cdHZhciBsb2dnZXJDYWxsYmFjayA9IGZ1bmN0aW9uIChfbGV2ZWwsIF9tZXNzYWdlKSB7XG5cdFx0aWYgKF9sZXZlbCAmJiBfbGV2ZWwgPT09IFwiZGVidWdcIikge1xuXHRcdFx0ZGVidWcoX21lc3NhZ2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbmZvKF9tZXNzYWdlKTtcblx0XHR9XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uIChjb250ZXh0SWQsIGR1cmF0aW9uLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICghQU5WaWRlb1ZpZXdhYmlsaXR5VHJhY2tlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9ICAgXG4gICAgICAgIGluZm8oXCJpbml0aWFsaXplIHdpdGggZHVyYXRpb246IFwiICsgZHVyYXRpb24gKyBcIiwgd2lkdGg6IFwiICsgd2lkdGggKyBcIiwgaGVpZ2h0OiBcIiArIGhlaWdodCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0cmFja2VyID0gbmV3IEFOVmlkZW9WaWV3YWJpbGl0eVRyYWNrZXIoXG5cdFx0XHRcdGdldENvbmZpZygpLFxuICAgICAgICAgICAgICAgIGdldFBsYXllckRPTUVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBnZXRWaWRlb0luZm8oZHVyYXRpb24sIHdpZHRoLCBoZWlnaHQpLCAvLyBUaGUgZHVyYXRpb24gb2YgdGhlIHZpZGVvIGFkXG4gICAgICAgICAgICAgICAgY29udGV4dElkLFxuXHRcdFx0XHRsb2dnZXJDYWxsYmFja1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImVycm9yIG9uIHZpZXdhYmlsaXR5IGxpYnJhcnk6IFwiKTtcbiAgICAgICAgICAgIGRlYnVnKGV4KTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuaW52b2tlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRfKSB7XG4gICAgICAgIGlmICghQU5WaWRlb1ZpZXdhYmlsaXR5VHJhY2tlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzUmVhZHkgJiYgZXZlbnRfICYmIG1hcHBlZEFjdGlvbnNbZXZlbnRfXSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZihmaXJlT25jZUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudF8pKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoZmlyZU9uY2VFdmVudHNbZXZlbnRfXSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvKFwic3VwcmVzc2luZyBmaXJlT25jZUV2ZW50cyBldmVudCBhcyBpdCBpcyBhbHJlYWR5IGZpcmVkIG9uY2UgYnkgdmlld2FiaWxpdHkgbGlicmFyeTogXCIgKyBtYXBwZWRBY3Rpb25zW2V2ZW50X10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJlT25jZUV2ZW50c1tldmVudF9dID0gdHJ1ZTsgLy8gbWFyayB0aGF0IHRoZSBldmVudCBoYXMgYmVlbiBmaXJlZC5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmZvKFwiZXZlbnQgaW52b2tlZCBieSB2aWV3YWJpbGl0eSBsaWJyYXJ5OiBcIiArIG1hcHBlZEFjdGlvbnNbZXZlbnRfXSk7XG4gICAgICAgICAgICAgICAgdHJhY2tlci5ub3RpZnlFdmVudChtYXBwZWRBY3Rpb25zW2V2ZW50X10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImVycm9yIG9uIHZpZXdhYmlsaXR5IGxpYnJhcnk6IFwiKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG5cblxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGh0bWw1VmlkZW9WaWV3YWJpbGl0eTsiLCIvL1NtYWxsIHN1YnNldCBvZiBhc3luY1xuXG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXR5RnVuY3Rpb25zJyk7XG5cbnZhciBhc3luYyA9IHt9O1xuXG5hc3luYy5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgc2V0VGltZW91dChmbiwgMCk7XG59O1xuXG5hc3luYy5pdGVyYXRvciA9IGZ1bmN0aW9uICh0YXNrcykge1xuICB2YXIgbWFrZUNhbGxiYWNrID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRhc2tzLmxlbmd0aCkge1xuICAgICAgICB0YXNrc1tpbmRleF0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmbi5uZXh0KCk7XG4gICAgfTtcbiAgICBmbi5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChpbmRleCA8IHRhc2tzLmxlbmd0aCAtIDEpID8gbWFrZUNhbGxiYWNrKGluZGV4ICsgMSkgOiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIGZuO1xuICB9O1xuICByZXR1cm4gbWFrZUNhbGxiYWNrKDApO1xufTtcblxuXG5hc3luYy53YXRlcmZhbGwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkgeyB9O1xuICBpZiAoIXV0aWxpdGllcy5pc0FycmF5KHRhc2tzKSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpO1xuICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICB9XG4gIGlmICghdGFza3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cbiAgdmFyIHdyYXBJdGVyYXRvciA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdmFyIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgYXJncy5wdXNoKHdyYXBJdGVyYXRvcihuZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGl0ZXJhdG9yLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICB3cmFwSXRlcmF0b3IoYXN5bmMuaXRlcmF0b3IodGFza3MpKSgpO1xufTtcblxuYXN5bmMud2hlbiA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGNhbGxiYWNrKSB7XG4gIGlmICghdXRpbGl0aWVzLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMud2hlbiBlcnJvcjogbWlzc2luZyBjYWxsYmFjayBhcmd1bWVudFwiKTtcbiAgfVxuXG4gIHZhciBpc0FsbG93ZWQgPSB1dGlsaXRpZXMuaXNGdW5jdGlvbihjb25kaXRpb24pID8gY29uZGl0aW9uIDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIWNvbmRpdGlvbjtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gdXRpbGl0aWVzLmFycmF5TGlrZU9ialRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICB2YXIgbmV4dCA9IGFyZ3MucG9wKCk7XG5cbiAgICBpZiAoaXNBbGxvd2VkLmFwcGx5KG51bGwsIGFyZ3MpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBhcmdzLnVuc2hpZnQobnVsbCk7XG4gICAgcmV0dXJuIG5leHQuYXBwbHkobnVsbCwgYXJncyk7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jO1xuXG4iLCIvKmpzaGludCB1bnVzZWQ6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX3ZlcmJvc2l0eSA9IDA7XG52YXIgX3ByZWZpeCA9IFwiW3ZpZGVvanMtdmFzdC12cGFpZF0gXCI7XG5cbmZ1bmN0aW9uIHNldFZlcmJvc2l0eSAodilcbntcbiAgICBfdmVyYm9zaXR5ID0gdjtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTXNnIChtZXRob2QsIGFyZ3MpXG57XG4gICAgaWYgKChhcmdzLmxlbmd0aCkgPiAwICYmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpKVxuICAgIHtcbiAgICAgICAgYXJnc1swXSA9IF9wcmVmaXggKyBhcmdzWzBdO1xuICAgIH1cblxuICAgIGlmIChtZXRob2QuYXBwbHkpXG4gICAge1xuICAgICAgICBtZXRob2QuYXBwbHkgKGNvbnNvbGUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgbWV0aG9kIChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZWJ1ZyAoKVxue1xuICAgIGlmIChfdmVyYm9zaXR5IDwgNClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUuZGVidWcgPT09ICd1bmRlZmluZWQnKVxuICAgIHtcbiAgICAgICAgLy8gSUUgMTAgZG9lc24ndCBoYXZlIGEgY29uc29sZS5kZWJ1ZygpIGZ1bmN0aW9uXG4gICAgICAgIGhhbmRsZU1zZyAoY29uc29sZS5sb2csIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGhhbmRsZU1zZyAoY29uc29sZS5kZWJ1ZywgYXJndW1lbnRzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvZyAoKVxue1xuICAgIGlmIChfdmVyYm9zaXR5IDwgMylcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYW5kbGVNc2cgKGNvbnNvbGUubG9nLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBpbmZvICgpXG57XG4gICAgaWYgKF92ZXJib3NpdHkgPCAyKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhhbmRsZU1zZyAoY29uc29sZS5pbmZvLCBhcmd1bWVudHMpO1xufVxuXG5cbmZ1bmN0aW9uIHdhcm4gKClcbntcbiAgICBpZiAoX3ZlcmJvc2l0eSA8IDEpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFuZGxlTXNnIChjb25zb2xlLndhcm4sIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGVycm9yICgpXG57XG4gICAgaGFuZGxlTXNnIChjb25zb2xlLmVycm9yLCBhcmd1bWVudHMpO1xufVxuXG52YXIgY29uc29sZUxvZ2dlciA9IHtcbiAgICBzZXRWZXJib3NpdHk6IHNldFZlcmJvc2l0eSxcbiAgICBkZWJ1ZzogZGVidWcsXG4gICAgbG9nOiBsb2csXG4gICAgaW5mbzogaW5mbyxcbiAgICB3YXJuOiB3YXJuLFxuICAgIGVycm9yOiBlcnJvclxufTtcblxuaWYgKCh0eXBlb2YgKGNvbnNvbGUpID09PSAndW5kZWZpbmVkJykgfHwgIWNvbnNvbGUubG9nKVxue1xuICAgIC8vIG5vIGNvbnNvbGUgYXZhaWxhYmxlOyBtYWtlIGZ1bmN0aW9ucyBuby1vcFxuICAgIGNvbnNvbGVMb2dnZXIuZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBjb25zb2xlTG9nZ2VyLmxvZyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIGNvbnNvbGVMb2dnZXIuaW5mbyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIGNvbnNvbGVMb2dnZXIud2FybiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIGNvbnNvbGVMb2dnZXIuZXJyb3IgPSBmdW5jdGlvbiAoKSB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlTG9nZ2VyOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4vdXRpbGl0eUZ1bmN0aW9ucycpO1xuXG52YXIgZG9tID0ge307XG5cbmRvbS5pc1Zpc2libGUgPSBmdW5jdGlvbiBpc1Zpc2libGUoZWwpIHtcbiAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICByZXR1cm4gc3R5bGUudmlzaWJpbGl0eSAhPT0gJ2hpZGRlbic7XG59O1xuXG5kb20uaXNIaWRkZW4gPSBmdW5jdGlvbiBpc0hpZGRlbihlbCkge1xuICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHJldHVybiBzdHlsZS5kaXNwbGF5ID09PSAnbm9uZSc7XG59O1xuXG5kb20uaXNTaG93biA9IGZ1bmN0aW9uIGlzU2hvd24oZWwpIHtcbiAgcmV0dXJuICFkb20uaXNIaWRkZW4oZWwpO1xufTtcblxuZG9tLmhpZGUgPSBmdW5jdGlvbiBoaWRlKGVsKSB7XG4gIGVsLl9fcHJldl9zdHlsZV9kaXNwbGF5XyA9IGVsLnN0eWxlLmRpc3BsYXk7XG4gIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG59O1xuXG5kb20uc2hvdyA9IGZ1bmN0aW9uIHNob3coZWwpIHtcbiAgaWYgKGRvbS5pc0hpZGRlbihlbCkpIHtcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX19wcmV2X3N0eWxlX2Rpc3BsYXlfO1xuICB9XG4gIGVsLl9fcHJldl9zdHlsZV9kaXNwbGF5XyA9IHVuZGVmaW5lZDtcbn07XG5cbmRvbS5oYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBjc3NDbGFzcykge1xuICB2YXIgY2xhc3NlcywgaSwgbGVuO1xuXG4gIGlmICh1dGlsaXRpZXMuaXNOb3RFbXB0eVN0cmluZyhjc3NDbGFzcykpIHtcbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNzc0NsYXNzKTtcbiAgICB9XG5cbiAgICBjbGFzc2VzID0gdXRpbGl0aWVzLmlzU3RyaW5nKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSkgPyBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykuc3BsaXQoL1xccysvKSA6IFtdO1xuICAgIGNzc0NsYXNzID0gKGNzc0NsYXNzIHx8ICcnKTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmIChjbGFzc2VzW2ldID09PSBjc3NDbGFzcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZG9tLmFkZENsYXNzID0gZnVuY3Rpb24gKGVsLCBjc3NDbGFzcykge1xuICB2YXIgY2xhc3NlcztcblxuICBpZiAodXRpbGl0aWVzLmlzTm90RW1wdHlTdHJpbmcoY3NzQ2xhc3MpKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoY3NzQ2xhc3MpO1xuICAgIH1cblxuICAgIGNsYXNzZXMgPSB1dGlsaXRpZXMuaXNTdHJpbmcoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpKSA/IGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKS5zcGxpdCgvXFxzKy8pIDogW107XG4gICAgaWYgKHV0aWxpdGllcy5pc1N0cmluZyhjc3NDbGFzcykgJiYgdXRpbGl0aWVzLmlzTm90RW1wdHlTdHJpbmcoY3NzQ2xhc3MucmVwbGFjZSgvXFxzKy8sICcnKSkpIHtcbiAgICAgIGNsYXNzZXMucHVzaChjc3NDbGFzcyk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3Nlcy5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxufTtcblxuZG9tLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGVsLCBjc3NDbGFzcykge1xuICB2YXIgY2xhc3NlcztcblxuICBpZiAodXRpbGl0aWVzLmlzTm90RW1wdHlTdHJpbmcoY3NzQ2xhc3MpKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoY3NzQ2xhc3MpO1xuICAgIH1cblxuICAgIGNsYXNzZXMgPSB1dGlsaXRpZXMuaXNTdHJpbmcoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpKSA/IGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKS5zcGxpdCgvXFxzKy8pIDogW107XG4gICAgdmFyIG5ld0NsYXNzZXMgPSBbXTtcbiAgICB2YXIgaSwgbGVuO1xuICAgIGlmICh1dGlsaXRpZXMuaXNTdHJpbmcoY3NzQ2xhc3MpICYmIHV0aWxpdGllcy5pc05vdEVtcHR5U3RyaW5nKGNzc0NsYXNzLnJlcGxhY2UoL1xccysvLCAnJykpKSB7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGNzc0NsYXNzICE9PSBjbGFzc2VzW2ldKSB7XG4gICAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKGNsYXNzZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgbmV3Q2xhc3Nlcy5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxufTtcblxuZG9tLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCB0eXBlLCBoYW5kbGVyKSB7XG4gIGlmKHV0aWxpdGllcy5pc0FycmF5KGVsKSl7XG4gICAgdXRpbGl0aWVzLmZvckVhY2goZWwsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKGUsIHR5cGUsIGhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmKHV0aWxpdGllcy5pc0FycmF5KHR5cGUpKXtcbiAgICB1dGlsaXRpZXMuZm9yRWFjaCh0eXBlLCBmdW5jdGlvbih0KSB7XG4gICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihlbCwgdCwgaGFuZGxlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChlbC5hdHRhY2hFdmVudCkge1xuICAgIC8vIFdBUk5JTkchISEgdGhpcyBpcyBhIHZlcnkgbmFpdmUgaW1wbGVtZW50YXRpb24gIVxuICAgIC8vIHRoZSBldmVudCBvYmplY3QgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBoYW5kbGVyXG4gICAgLy8gd291bGQgbm90IGJlIHRoZXJlIGZvciBJRThcbiAgICAvLyB3ZSBzaG91bGQgdXNlIFwid2luZG93LmV2ZW50XCIgYW5kIHRoZW4gXCJldmVudC5zcmNFbGVtZW50XCJcbiAgICAvLyBpbnN0ZWFkIG9mIFwiZXZlbnQudGFyZ2V0XCJcbiAgICBlbC5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBoYW5kbGVyKTtcbiAgfVxufTtcblxuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCB0eXBlLCBoYW5kbGVyKSB7XG4gIGlmKHV0aWxpdGllcy5pc0FycmF5KGVsKSl7XG4gICAgdXRpbGl0aWVzLmZvckVhY2goZWwsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKGUsIHR5cGUsIGhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmKHV0aWxpdGllcy5pc0FycmF5KHR5cGUpKXtcbiAgICB1dGlsaXRpZXMuZm9yRWFjaCh0eXBlLCBmdW5jdGlvbih0KSB7XG4gICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgdCwgaGFuZGxlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChlbC5kZXRhY2hFdmVudCkge1xuICAgIGVsLmRldGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIGVsW1wib25cIiArIHR5cGVdID0gbnVsbDtcbiAgfVxufTtcblxuZG9tLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGVsLCBldmVudCkge1xuICBpZiAoZWwuZGlzcGF0Y2hFdmVudCkge1xuICAgIGVsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGVsLmZpcmVFdmVudChcIm9uXCIgKyBldmVudC5ldmVudFR5cGUsIGV2ZW50KTtcbiAgfVxufTtcblxuZG9tLmlzRGVzY2VuZGFudCA9IGZ1bmN0aW9uIGlzRGVzY2VuZGFudChwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciBub2RlID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5kb20uZ2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiBnZXRUZXh0Q29udGVudChlbCl7XG4gIHJldHVybiBlbC50ZXh0Q29udGVudCB8fCBlbC50ZXh0O1xufTtcblxuZG9tLnByZXBlbmRDaGlsZCA9IGZ1bmN0aW9uIHByZXBlbmRDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gIGlmKGNoaWxkLnBhcmVudE5vZGUpe1xuICAgIGNoaWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG4gIHJldHVybiBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBwYXJlbnQuZmlyc3RDaGlsZCk7XG59O1xuXG5kb20ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKXtcbiAgaWYobm9kZSAmJiBub2RlLnBhcmVudE5vZGUpe1xuICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgfVxufTtcblxuZG9tLmlzRG9tRWxlbWVudCA9IGZ1bmN0aW9uIGlzRG9tRWxlbWVudChvKSB7XG4gIHJldHVybiBvIGluc3RhbmNlb2YgRWxlbWVudDtcbn07XG5cbmRvbS5jbGljayA9IGZ1bmN0aW9uKGVsLCBoYW5kbGVyKSB7XG4gIGRvbS5hZGRFdmVudExpc3RlbmVyKGVsLCAnY2xpY2snLCBoYW5kbGVyKTtcbn07XG5cbmRvbS5vbmNlID0gZnVuY3Rpb24oZWwsIHR5cGUsIGhhbmRsZXIpIHtcbiAgZnVuY3Rpb24gaGFuZGxlcldyYXAoKSB7XG4gICAgaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKGVsLCB0eXBlLCBoYW5kbGVyV3JhcCk7XG4gIH1cblxuICBkb20uYWRkRXZlbnRMaXN0ZW5lcihlbCwgdHlwZSwgaGFuZGxlcldyYXApO1xufTtcblxuLy9Ob3RlOiB0aGVyZSBpcyBubyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gaVBhZCBzbyB3ZSBuZWVkIGEgZmFsbGJhY2tcbmRvbS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24oZWxlbWVudCkge1xuICB2YXIgcmVjdDtcblxuICAvL09uIElFOSBhbmQgYmVsb3cgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGRvZXMgbm90IHdvcmsgY29uc2lzdGVudGx5XG4gIGlmKCF1dGlsaXRpZXMuaXNPbGRJRSgpICYmIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZG9tOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVybFV0aWxzID0gcmVxdWlyZSgnLi91cmxVdGlscycpO1xudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4vdXRpbGl0eUZ1bmN0aW9ucycpO1xuXG5mdW5jdGlvbiBIdHRwUmVxdWVzdEVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gJ0h0dHBSZXF1ZXN0IEVycm9yOiAnICsgKG1lc3NhZ2UgfHwgJycpO1xufVxuSHR0cFJlcXVlc3RFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbkh0dHBSZXF1ZXN0RXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIkh0dHBSZXF1ZXN0IEVycm9yXCI7XG5cbmZ1bmN0aW9uIEh0dHBSZXF1ZXN0KGNyZWF0ZVhocikge1xuICBpZiAoIXV0aWxpdGllcy5pc0Z1bmN0aW9uKGNyZWF0ZVhocikpIHtcbiAgICB0aHJvdyBuZXcgSHR0cFJlcXVlc3RFcnJvcignTWlzc2luZyBYTUxIdHRwUmVxdWVzdCBmYWN0b3J5IG1ldGhvZCcpO1xuICB9XG5cbiAgdGhpcy5jcmVhdGVYaHIgPSBjcmVhdGVYaHI7XG59XG5cbkh0dHBSZXF1ZXN0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHNhbml0eUNoZWNrKHVybCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICB2YXIgdGltZW91dCwgdGltZW91dElkO1xuICB2YXIgeGhyID0gdGhpcy5jcmVhdGVYaHIoKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRpbWVvdXQgPSB1dGlsaXRpZXMuaXNOdW1iZXIob3B0aW9ucy50aW1lb3V0KSA/IG9wdGlvbnMudGltZW91dCA6IDA7XG5cbiAgeGhyLm9wZW4obWV0aG9kLCB1cmxVdGlscy51cmxQYXJ0cyh1cmwpLmhyZWYsIHRydWUpO1xuXG4gIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICBzZXRIZWFkZXJzKHhociwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLndpdGhDcmVkZW50aWFscykge1xuICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICB9XG5cbiAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdHVzVGV4dCwgcmVzcG9uc2UsIHN0YXR1cztcblxuICAgIC8qKlxuICAgICAqIFRoZSBvbmx5IHdheSB0byBkbyBhIHNlY3VyZSByZXF1ZXN0IG9uIElFOCBhbmQgSUU5IGlzIHdpdGggdGhlIFhEb21haW5SZXF1ZXN0IG9iamVjdC4gVW5mb3J0dW5hdGVseSwgbWljcm9zb2Z0IGlzXG4gICAgICogc28gbmljZSB0aGF0IGRlY2lkZWQgdGhhdCB0aGUgc3RhdHVzIHByb3BlcnR5IGFuZCB0aGUgJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgbWV0aG9kIHdoZXJlIG5vdCBuZWVkZWQgc28gd2UgaGF2ZSB0b1xuICAgICAqIGZha2UgdGhlbS4gSWYgdGhlIHJlcXVlc3QgZ2V0cyBkb25lIHdpdGggYW4gWERvbWFpblJlcXVlc3QgaW5zdGFuY2UsIHdlIHdpbGwgYXNzdW1lIHRoYXQgdGhlcmUgYXJlIG5vIGhlYWRlcnMgYW5kXG4gICAgICogdGhlIHN0YXR1cyB3aWxsIGFsd2F5cyBiZSAyMDAuIElmIHlvdSBkb24ndCBsaWtlIGl0LCBETyBOT1QgVVNFIEFOQ0lFTlQgQlJPV1NFUlMhISFcbiAgICAgKlxuICAgICAqIEZvciBtb3IgaW5mbyBnbyB0bzogaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzI4ODA2MCh2PXZzLjg1KS5hc3B4XG4gICAgICovXG4gICAgaWYgKCF4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF4aHIuc3RhdHVzKSB7XG4gICAgICB4aHIuc3RhdHVzID0gMjAwO1xuICAgIH1cblxuICAgIGlmICh1dGlsaXRpZXMuaXNEZWZpbmVkKHRpbWVvdXRJZCkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgdGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHN0YXR1c1RleHQgPSB4aHIuc3RhdHVzVGV4dCB8fCAnJztcblxuICAgIC8vIHJlc3BvbnNlVGV4dCBpcyB0aGUgb2xkLXNjaG9vbCB3YXkgb2YgcmV0cmlldmluZyByZXNwb25zZSAoc3VwcG9ydGVkIGJ5IElFOCAmIDkpXG4gICAgLy8gcmVzcG9uc2UvcmVzcG9uc2VUeXBlIHByb3BlcnRpZXMgd2VyZSBpbnRyb2R1Y2VkIGluIFhIUiBMZXZlbDIgc3BlYyAoc3VwcG9ydGVkIGJ5IElFMTApXG4gICAgcmVzcG9uc2UgPSAoJ3Jlc3BvbnNlJyBpbiB4aHIpID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcblxuICAgIC8vIG5vcm1hbGl6ZSBJRTkgYnVnIChodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwKVxuICAgIHN0YXR1cyA9IHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzO1xuXG4gICAgY2FsbGJhY2soXG4gICAgICBzdGF0dXMsXG4gICAgICByZXNwb25zZSxcbiAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSxcbiAgICAgIHN0YXR1c1RleHQpO1xuICB9O1xuXG4gIHhoci5vbmVycm9yID0gcmVxdWVzdEVycm9yO1xuICB4aHIub25hYm9ydCA9IHJlcXVlc3RFcnJvcjtcblxuICB4aHIuc2VuZCgpO1xuXG4gIGlmICh0aW1lb3V0ID4gMCkge1xuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgeGhyICYmIHhoci5hYm9ydCgpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2FuaXR5Q2hlY2sodXJsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmICghdXRpbGl0aWVzLmlzU3RyaW5nKHVybCkgfHwgdXRpbGl0aWVzLmlzRW1wdHlTdHJpbmcodXJsKSkge1xuICAgICAgdGhyb3cgbmV3IEh0dHBSZXF1ZXN0RXJyb3IoXCJJbnZhbGlkIHVybCAnXCIgKyB1cmwgKyBcIidcIik7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsaXRpZXMuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgIHRocm93IG5ldyBIdHRwUmVxdWVzdEVycm9yKFwiSW52YWxpZCBoYW5kbGVyICdcIiArIGNhbGxiYWNrICsgXCInIGZvciB0aGUgaHR0cCByZXF1ZXN0XCIpO1xuICAgIH1cblxuICAgIGlmICh1dGlsaXRpZXMuaXNEZWZpbmVkKG9wdGlvbnMpICYmICF1dGlsaXRpZXMuaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBIdHRwUmVxdWVzdEVycm9yKFwiSW52YWxpZCBvcHRpb25zIG1hcCAnXCIgKyBvcHRpb25zICsgXCInXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEhlYWRlcnMoeGhyLCBoZWFkZXJzKSB7XG4gICAgdXRpbGl0aWVzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh1dGlsaXRpZXMuaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcXVlc3RFcnJvcigpIHtcbiAgICBjYWxsYmFjaygtMSwgbnVsbCwgbnVsbCwgJycpO1xuICB9XG59O1xuXG5IdHRwUmVxdWVzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdGhpcy5ydW4oJ0dFVCcsIHVybCwgcHJvY2Vzc1Jlc3BvbnNlLCBvcHRpb25zKTtcblxuICBmdW5jdGlvbiBwcm9jZXNzUmVzcG9uc2Uoc3RhdHVzLCByZXNwb25zZSwgaGVhZGVyc1N0cmluZywgc3RhdHVzVGV4dCkge1xuICAgIGlmIChpc1N1Y2Nlc3Moc3RhdHVzKSkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UsIHN0YXR1cywgaGVhZGVyc1N0cmluZywgc3RhdHVzVGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBIdHRwUmVxdWVzdEVycm9yKHN0YXR1c1RleHQpLCByZXNwb25zZSwgc3RhdHVzLCBoZWFkZXJzU3RyaW5nLCBzdGF0dXNUZXh0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N1Y2Nlc3Moc3RhdHVzKSB7XG4gICAgcmV0dXJuIDIwMCA8PSBzdGF0dXMgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVYaHIoKSB7XG4gIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgaWYgKCEoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHIpKSB7XG4gICAgLy8gWERvbWFpblJlcXVlc3QgZm9yIElFLlxuICAgIHhociA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICB9XG4gIHJldHVybiB4aHI7XG59XG5cbnZhciBodHRwID0gbmV3IEh0dHBSZXF1ZXN0KGNyZWF0ZVhocik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBodHRwOiBodHRwLFxuICBIdHRwUmVxdWVzdDogSHR0cFJlcXVlc3QsXG4gIEh0dHBSZXF1ZXN0RXJyb3I6IEh0dHBSZXF1ZXN0RXJyb3IsXG4gIGNyZWF0ZVhocjogY3JlYXRlWGhyXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaHRtbDU6IFtcbiAgICAndGV4dC9qYXZhc2NyaXB0JyxcbiAgICAndGV4dC9qYXZhc2NyaXB0MS4wJyxcbiAgICAndGV4dC9qYXZhc2NyaXB0MS4yJyxcbiAgICAndGV4dC9qYXZhc2NyaXB0MS40JyxcbiAgICAndGV4dC9qc2NyaXB0JyxcbiAgICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXG4gICAgJ2FwcGxpY2F0aW9uL3gtamF2YXNjcmlwdCcsXG4gICAgJ3RleHQvZWNtYXNjcmlwdCcsXG4gICAgJ3RleHQvZWNtYXNjcmlwdDEuMCcsXG4gICAgJ3RleHQvZWNtYXNjcmlwdDEuMicsXG4gICAgJ3RleHQvZWNtYXNjcmlwdDEuNCcsXG4gICAgJ3RleHQvbGl2ZXNjcmlwdCcsXG4gICAgJ2FwcGxpY2F0aW9uL2VjbWFzY3JpcHQnLFxuICAgICdhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHQnLFxuICBdLFxuXG4gIGZsYXNoOiBbXG4gICAgJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJ1xuICBdLFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXR5RnVuY3Rpb25zJyk7XG5cbnZhciBwbGF5ZXJVdGlscyA9IHt9O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY2FwdHVyZXMgdGhlIHBvcnRpb25zIG9mIHBsYXllciBzdGF0ZSByZWxldmFudCB0b1xuICogdmlkZW8gcGxheWJhY2suIFRoZSByZXN1bHQgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIHRvXG4gKiByZXN0b3JlUGxheWVyU25hcHNob3Qgd2l0aCBhIHBsYXllciB0byByZXR1cm4gdGhlIHBsYXllciB0byB0aGUgc3RhdGUgaXRcbiAqIHdhcyBpbiB3aGVuIHRoaXMgZnVuY3Rpb24gd2FzIGludm9rZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gcGxheWVyIFRoZSB2aWRlb2pzIHBsYXllciBvYmplY3RcbiAqL1xucGxheWVyVXRpbHMuZ2V0UGxheWVyU25hcHNob3QgPSBmdW5jdGlvbiBnZXRQbGF5ZXJTbmFwc2hvdChwbGF5ZXIpIHtcbiAgdmFyIHRlY2ggPSBwbGF5ZXIuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLXRlY2gnKTtcblxuICB2YXIgc25hcHNob3QgPSB7XG4gICAgZW5kZWQ6IHBsYXllci5lbmRlZCgpLFxuICAgIHNyYzogcGxheWVyLmN1cnJlbnRTcmMoKSxcbiAgICBjdXJyZW50VGltZTogcGxheWVyLmN1cnJlbnRUaW1lKCksXG4gICAgdHlwZTogcGxheWVyLmN1cnJlbnRUeXBlKCksXG4gICAgcGxheWluZzogIXBsYXllci5wYXVzZWQoKSxcbiAgICBzdXBwcmVzc2VkVHJhY2tzOiBnZXRTdXBwcmVzc2VkVHJhY2tzKHBsYXllcilcbiAgfTtcblxuICBpZiAodGVjaCkge1xuICAgIHNuYXBzaG90Lm5hdGl2ZVBvc3RlciA9IHRlY2gucG9zdGVyO1xuICAgIHNuYXBzaG90LnN0eWxlID0gdGVjaC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gIH1cblxuXHR2YXIgZWxzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndmpzLWRvY2stdGV4dCcpO1xuXHRpZiAoZWxzICYmIGVscy5sZW5ndGggPiAwKSB7XG5cdFx0c25hcHNob3QuZG9ja1RleHQgPSBlbHNbMF07XG5cdFx0c25hcHNob3QuZG9ja1RleHQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0fVxuICByZXR1cm4gc25hcHNob3Q7XG5cbiAgLyoqKiogTG9jYWwgRnVuY3Rpb25zICoqKiovXG4gIGZ1bmN0aW9uIGdldFN1cHByZXNzZWRUcmFja3MocGxheWVyKSB7XG4gICAgdmFyIHRyYWNrcyA9IHBsYXllci5yZW1vdGVUZXh0VHJhY2tzID8gcGxheWVyLnJlbW90ZVRleHRUcmFja3MoKSA6IFtdO1xuXG4gICAgaWYgKHRyYWNrcyAmJiB1dGlsaXRpZXMuaXNBcnJheSh0cmFja3MudHJhY2tzXykpIHtcbiAgICAgIHRyYWNrcyA9IHRyYWNrcy50cmFja3NfO1xuICAgIH1cblxuICAgIGlmICghdXRpbGl0aWVzLmlzQXJyYXkodHJhY2tzKSkge1xuICAgICAgdHJhY2tzID0gW107XG4gICAgfVxuXG4gICAgdmFyIHN1cHByZXNzZWRUcmFja3MgPSBbXTtcbiAgICB0cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgIHN1cHByZXNzZWRUcmFja3MucHVzaCh7XG4gICAgICAgIHRyYWNrOiB0cmFjayxcbiAgICAgICAgbW9kZTogdHJhY2subW9kZVxuICAgICAgfSk7XG4gICAgICB0cmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICB9KTtcblxuICAgIHJldHVybiBzdXBwcmVzc2VkVHJhY2tzO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIG1vZGlmeSB0aGUgc3BlY2lmaWVkIHBsYXllciBzbyB0aGF0IGl0cyBzdGF0ZSBpcyBlcXVpdmFsZW50IHRvXG4gKiB0aGUgc3RhdGUgb2YgdGhlIHNuYXBzaG90LlxuICogQHBhcmFtIHtvYmplY3R9IHNuYXBzaG90IC0gdGhlIHBsYXllciBzdGF0ZSB0byBhcHBseVxuICovXG5wbGF5ZXJVdGlscy5yZXN0b3JlUGxheWVyU25hcHNob3QgPSBmdW5jdGlvbiByZXN0b3JlUGxheWVyU25hcHNob3QocGxheWVyLCBzbmFwc2hvdCkge1xuICB2YXIgdGVjaCA9IHBsYXllci5lbCgpLnF1ZXJ5U2VsZWN0b3IoJy52anMtdGVjaCcpO1xuICB2YXIgYXR0ZW1wdHMgPSAyMDsgLy8gdGhlIG51bWJlciBvZiByZW1haW5pbmcgYXR0ZW1wdHMgdG8gcmVzdG9yZSB0aGUgc25hcHNob3RcblxuICBpZiAoc25hcHNob3QubmF0aXZlUG9zdGVyKSB7XG4gICAgdGVjaC5wb3N0ZXIgPSBzbmFwc2hvdC5uYXRpdmVQb3N0ZXI7XG4gIH1cblxuICBpZiAoJ3N0eWxlJyBpbiBzbmFwc2hvdCkge1xuICAgIC8vIG92ZXJ3cml0ZSBhbGwgY3NzIHN0eWxlIHByb3BlcnRpZXMgdG8gcmVzdG9yZSBzdGF0ZSBwcmVjaXNlbHlcbiAgICB0ZWNoLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzbmFwc2hvdC5zdHlsZSB8fCAnJyk7XG4gIH1cblxuXHRpZiAoc25hcHNob3QuZG9ja1RleHQpIHtcblx0XHRzbmFwc2hvdC5kb2NrVGV4dC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0fVxuXG4gIC8vaWYgKGhhc1NyY0NoYW5nZWQocGxheWVyLCBzbmFwc2hvdCkpIHtcblxuICAgIC8vIG9uIGlvczcsIGZpZGRsaW5nIHdpdGggdGV4dFRyYWNrcyB0b28gZWFybHkgd2lsbCBjYXVzZSBzYWZhcmkgdG8gY3Jhc2hcbiAgICBwbGF5ZXIub25lKCdjb250ZW50bG9hZGVkbWV0YWRhdGEnLCByZXN0b3JlVHJhY2tzKTtcblxuICAgIHBsYXllci5vbmUoJ2NhbnBsYXknLCB0cnlUb1Jlc3VtZSk7XG4gICAgZW5zdXJlQ2FucGxheUV2dEdldHNGaXJlZCgpO1xuXG4gICAgLy8gaWYgdGhlIHNyYyBjaGFuZ2VkIGZvciBhZCBwbGF5YmFjaywgcmVzZXQgaXRcbiAgICBwbGF5ZXIuc3JjKHtzcmM6IHNuYXBzaG90LnNyYywgdHlwZTogc25hcHNob3QudHlwZX0pO1xuXG4gICAgLy8gc2FmYXJpIHJlcXVpcmVzIGEgY2FsbCB0byBgbG9hZGAgdG8gcGljayB1cCBhIGNoYW5nZWQgc291cmNlXG4gICAgLy8gcGxheWVyLmxvYWQoKTtcdC8vIFNhZmFyaSAxMSBubyBtb3JlIHJlcXVpcmVzICdsb2FkJy4gRmlyZWZveCBkb2Vzbid0IGxpa2UgJ2xvYWQnIGNhbGwgZm9yIGFscmVhZHkgbG9hZGVkIGNvbnRlbnQgKGluIGNhc2Ugb2YgQWRMb2FkZWQgdGltZW91dCkuXG5cbiAgLyp9IGVsc2Uge1xuICAgIHJlc3RvcmVUcmFja3MoKTtcblxuICAgIGlmIChzbmFwc2hvdC5wbGF5aW5nKSB7XG4gICAgICBwbGF5ZXIucGxheSgpO1xuICAgIH1cbiAgfSovXG5cbiAgLyoqKiBMb2NhbCBGdW5jdGlvbnMgKioqL1xuXG4gIC8qKlxuICAgKiBTb21ldGltZXMgZmlyZWZveCBkb2VzIG5vdCB0cmlnZ2VyIHRoZSAnY2FucGxheScgZXZ0LlxuICAgKiBUaGlzIGNvZGUgZW5zdXJlIHRoYXQgaXQgYWx3YXlzIGdldHMgdHJpZ2dlcmVkIHRyaWdnZXJlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbnBsYXlFdnRHZXRzRmlyZWQoKSB7XG4gICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBwbGF5ZXIudHJpZ2dlcignY2FucGxheScpO1xuICAgIH0sIDEwMDApO1xuXG4gICAgcGxheWVyLm9uZSgnY2FucGxheScsIGZ1bmN0aW9uKCl7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgcGxheWVyIG5lZWRzIHRvIGJlIHJlc3RvcmVkIHRvIGl0cyBzdGF0ZVxuICAgKiBiZWZvcmUgYWQgcGxheWJhY2sgYmVnYW4uIFdpdGggYSBjdXN0b20gYWQgZGlzcGxheSBvciBidXJuZWQtaW5cbiAgICogYWRzLCB0aGUgY29udGVudCBwbGF5ZXIgc3RhdGUgaGFzbid0IGJlZW4gbW9kaWZpZWQgYW5kIHNvIG5vXG4gICAqIHJlc3RvcmF0aW9uIGlzIHJlcXVpcmVkXG4gICAqL1xuICAvKmZ1bmN0aW9uIGhhc1NyY0NoYW5nZWQocGxheWVyLCBzbmFwc2hvdCkge1xuICAgIGlmIChwbGF5ZXIuc3JjKCkpIHtcbiAgICAgIHJldHVybiBwbGF5ZXIuc3JjKCkgIT09IHNuYXBzaG90LnNyYztcbiAgICB9XG4gICAgLy8gdGhlIHBsYXllciB3YXMgY29uZmlndXJlZCB0aHJvdWdoIHNvdXJjZSBlbGVtZW50IGNoaWxkcmVuXG4gICAgcmV0dXJuIHBsYXllci5jdXJyZW50U3JjKCkgIT09IHNuYXBzaG90LnNyYztcbiAgfSovXG5cbiAgZnVuY3Rpb24gcmVzdG9yZVRyYWNrcygpIHtcbiAgICB2YXIgc3VwcHJlc3NlZFRyYWNrcyA9IHNuYXBzaG90LnN1cHByZXNzZWRUcmFja3M7XG4gICAgc3VwcHJlc3NlZFRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja1NuYXBzaG90KSB7XG4gICAgICB0cmFja1NuYXBzaG90LnRyYWNrLm1vZGUgPSB0cmFja1NuYXBzaG90Lm1vZGU7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSB2aWRlbyBlbGVtZW50IGhhcyBsb2FkZWQgZW5vdWdoIG9mIHRoZSBzbmFwc2hvdCBzb3VyY2VcbiAgICogdG8gYmUgcmVhZHkgdG8gYXBwbHkgdGhlIHJlc3Qgb2YgdGhlIHN0YXRlXG4gICAqL1xuICBmdW5jdGlvbiB0cnlUb1Jlc3VtZSgpIHtcblxuICAgIC8vIGlmIHNvbWUgcGVyaW9kIG9mIHRoZSB2aWRlbyBpcyBzZWVrYWJsZSwgcmVzdW1lIHBsYXliYWNrXG4gICAgLy8gb3RoZXJ3aXNlIGRlbGF5IGEgYml0IGFuZCB0aGVuIGNoZWNrIGFnYWluIHVubGVzcyB3ZSdyZSBvdXQgb2YgYXR0ZW1wdHNcblxuXHQgIC8vIHNhZmFyaSAxMSByZXF1aXJlcyBjYWxsIGBwbGF5YCB0byBtYWtlIHNlZWsgYXZhaWxhYmxlXG4gICAgICBwbGF5ZXIucGxheSgpO1xuXG4gICAgaWYgKCFwbGF5ZXJVdGlscy5pc1JlYWR5VG9SZXN1bWUocGxheWVyKSAmJiBhdHRlbXB0cy0tKSB7XG4gICAgICBzZXRUaW1lb3V0KHRyeVRvUmVzdW1lLCA1MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJyoqKioqKiBNT0wgdHJ5IG5hdmlnYXRlIGFmdGVyIGF0dGVtcHRzICgnICsgYXR0ZW1wdHMgKyAnKScpO1xuICAgICAgICBpZihwbGF5ZXIuY3VycmVudFRpbWUoKSAhPT0gc25hcHNob3QuY3VycmVudFRpbWUpIHtcbiAgICAgICAgICBpZiAoc25hcHNob3QucGxheWluZykgeyAvLyBpZiBuZWVkZWQgcmVzdG9yZSBwbGF5aW5nIHN0YXR1cyBhZnRlciBzZWVrIGNvbXBsZXRlc1xuICAgICAgICAgICAgcGxheWVyLm9uZSgnc2Vla2VkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJyoqKioqKiBNT0wgcGxheSBtYWluIGNvbnRlbnQgKCcgKyBwbGF5ZXIuY3VycmVudFRpbWUoKSArICcpIGJ5IHNlZWsnKTtcbiAgICAgICAgICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCcqKioqKiogTU9MIG5hdmlnYXRlIG1haW4gY29udGVudCB0byAnICsgc25hcHNob3QuY3VycmVudFRpbWUpO1xuICAgICAgICAgIHBsYXllci5jdXJyZW50VGltZShzbmFwc2hvdC5jdXJyZW50VGltZSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChzbmFwc2hvdC5wbGF5aW5nKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnKioqKioqIE1PTCBwbGF5IG1haW4gY29udGVudCAoJyArIHBsYXllci5jdXJyZW50VGltZSgpICsgJyknKTtcbiAgICAgICAgICAvLyBpZiBuZWVkZWQgYW5kIG5vIHNlZWsgaGFzIGJlZW4gcGVyZm9ybWVkLCByZXN0b3JlIHBsYXlpbmcgc3RhdHVzIGltbWVkaWF0ZWx5XG4gICAgICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICAgICAgfVxuXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHZpZGVvanMubG9nLndhcm4oJ0ZhaWxlZCB0byByZXN1bWUgdGhlIGNvbnRlbnQgYWZ0ZXIgYW4gYWR2ZXJ0aXNlbWVudCcsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxucGxheWVyVXRpbHMuaXNSZWFkeVRvUmVzdW1lID0gZnVuY3Rpb24gKHBsYXllcikge1xuXG4gIGlmIChwbGF5ZXIucmVhZHlTdGF0ZSgpID4gMSkge1xuICAgIC8vIHNvbWUgYnJvd3NlcnMgYW5kIG1lZGlhIGFyZW4ndCBcInNlZWthYmxlXCIuXG4gICAgLy8gcmVhZHlTdGF0ZSBncmVhdGVyIHRoYW4gMSBhbGxvd3MgZm9yIHNlZWtpbmcgd2l0aG91dCBleGNlcHRpb25zXG4gICAgLy9jb25zb2xlLmxvZygnKioqKioqIE1PTCByZWFkeSB0byByZXN1bWUgcGxheWVyIHN0YXRlICcgKyBwbGF5ZXIucmVhZHlTdGF0ZSgpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodXRpbGl0aWVzLmlzSUUxMSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHBsYXllci5zZWVrYWJsZSgpID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBpZiB0aGUgcGxheWVyIGRvZXNuJ3QgZXhwb3NlIHRoZSBzZWVrYWJsZSB0aW1lIHJhbmdlcywgdHJ5IHRvXG4gICAgLy8gcmVzdW1lIHBsYXliYWNrIGltbWVkaWF0ZWx5XG4gICAgLy9jb25zb2xlLmxvZygnKioqKioqIE1PTCByZWFkeSB0byByZXN1bWUgcGxheWVyLnNlZWthYmxlKCkgPT09IHVuZGVmaW5lZCcpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHBsYXllci5zZWVrYWJsZSgpLmxlbmd0aCA+IDApIHtcbiAgICAvLyBpZiBzb21lIHBlcmlvZCBvZiB0aGUgdmlkZW8gaXMgc2Vla2FibGUsIHJlc3VtZSBwbGF5YmFja1xuICAgIC8vY29uc29sZS5sb2coJyoqKioqKiBNT0wgcmVhZHkgdG8gcmVzdW1lIHBsYXllci5zZWVrYWJsZSgpLmxlbmd0aCA9ICcgKyBwbGF5ZXIuc2Vla2FibGUoKS5sZW5ndGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHByZXBhcmVzIHRoZSBwbGF5ZXIgdG8gZGlzcGxheSBhZHMuXG4gKiBBZGRpbmcgY29udmVuaWVuY2UgZXZlbnRzIGxpa2UgdGhlICd2YXN0LmZpcnNQbGF5JyB0aGF0IGdldHMgZmlyZWQgd2hlbiB0aGUgdmlkZW8gaXMgZmlyc3QgcGxheWVkXG4gKiBhbmQgYWRzIHRoZSBibGFja1Bvc3RlciB0byB0aGUgcGxheWVyIHRvIHByZXZlbnQgY29udGVudCBmcm9tIGJlaW5nIGRpc3BsYXllZCBiZWZvcmUgdGhlIHByZXJvbGwgYWQuXG4gKlxuICogQHBhcmFtIHBsYXllclxuICovXG5wbGF5ZXJVdGlscy5wcmVwYXJlRm9yQWRzID0gZnVuY3Rpb24gKHBsYXllcikge1xuICB2YXIgYmxhY2tQb3N0ZXIgPSBwbGF5ZXIuYWRkQ2hpbGQoJ2JsYWNrUG9zdGVyJyk7XG4gIC8vdmFyIF9maXJzdFBsYXkgPSB0cnVlO1xuICB2YXIgdm9sdW1lU25hcHNob3Q7XG5cblxuICBtb25rZXlQYXRjaFBsYXllckFwaSgpO1xuXG4gIHBsYXllci5vbigncGxheScsIHRyeVRvVHJpZ2dlckZpcnN0UGxheSk7XG4gIHBsYXllci5vbigndmFzdC5yZXNldCcsIHJlc2V0Rmlyc3RQbGF5KTsvL0V2ZXJ5IHRpbWUgd2UgY2hhbmdlIHRoZSBzb3VyY2VzIHdlIHJlc2V0IHRoZSBmaXJzdCBwbGF5LlxuICBwbGF5ZXIub24oJ3Zhc3QuZmlyc3RQbGF5JywgcmVzdG9yZUNvbnRlbnRWb2x1bWUpO1xuICBwbGF5ZXIub24oJ2Vycm9yJywgaGlkZUJsYWNrUG9zdGVyKTsvL0lmIHRoZXJlIGlzIGFuIGVycm9yIGluIHRoZSBwbGF5ZXIgd2UgcmVtb3ZlIHRoZSBibGFja3Bvc3RlciB0byBzaG93IHRoZSBlcnIgbXNnXG4gIHBsYXllci5vbigndmFzdC5hZFN0YXJ0JywgaGlkZUJsYWNrUG9zdGVyKTtcbiAgcGxheWVyLm9uKCd2YXN0LmFkc0NhbmNlbCcsIGhpZGVCbGFja1Bvc3Rlcik7XG4gIHBsYXllci5vbigndmFzdC5hZEVycm9yJywgaGlkZUJsYWNrUG9zdGVyKTtcbiAgcGxheWVyLm9uKCd2YXN0LmFkU3RhcnQnLCBhZGRTdHlsZXMpO1xuICBwbGF5ZXIub24oJ3Zhc3QuYWRFbmQnLCByZW1vdmVTdHlsZXMpO1xuICBwbGF5ZXIub24oJ3Zhc3QuYWRzQ2FuY2VsJywgcmVtb3ZlU3R5bGVzKTtcblxuICAvLyBWSURMQS0yNDY1IC0gaGlkZSB2anMgZXJyb3IgZGlhbG9nIHdoZW4gYWQgcnVubmluZ1xuICB2YXIgZXJyb3JEaWFsb2c7XG4gIHZhciBkbGdzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndmpzLWVycm9yLWRpc3BsYXknKTtcbiAgaWYgKGRsZ3MgJiYgZGxncy5sZW5ndGggPiAwKSB7XG5cdCAgZXJyb3JEaWFsb2cgPSBkbGdzWzBdO1xuXHQgIGVycm9yRGlhbG9nLnN0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ25vbmUnLCAnaW1wb3J0YW50Jyk7XG4gIH1cbiAgXG4gIC8qKiogTG9jYWwgRnVuY3Rpb25zICoqKi9cblxuICAvKipcbiAgIFdoYXQgdGhpcyBmdW5jdGlvbiBkb2VzIGlzIHVnbHkgYW5kIGhvcnJpYmxlIGFuZCBJIHNob3VsZCB0aGluayB0d2ljZSBiZWZvcmUgY2FsbGluZyBteXNlbGYgYSBnb29kIGRldmVsb3Blci4gV2l0aCB0aGF0IHNhaWQsXG4gICBpdCBpcyB0aGUgYmVzdCBzb2x1dGlvbiBJIGNvdWxkIGZpbmQgdG8gbXV0ZSB0aGUgdmlkZW8gdW50aWwgdGhlICdwbGF5JyBldmVudCBoYXBwZW5zIChvbiBtb2JpbGUgZGV2aWNlcykgYW5kIHRoZSBwbHVnaW4gY2FuIGRlY2lkZSB3aGV0aGVyXG4gICB0byBwbGF5IHRoZSBhZCBvciBub3QuXG5cbiAgIFdlIGFsc28gbmVlZCB0aGlzIG1vbmtleXBhdGNoIHRvIGJlIGFibGUgdG8gcGF1c2UgYW5kIHJlc3VtZSBhbiBhZCB1c2luZyB0aGUgcGxheWVyJ3MgQVBJXG5cbiAgIElmIHlvdSBoYXZlIGEgYmV0dGVyIHNvbHV0aW9uIHBsZWFzZSBkbyB0ZWxsIG1lLlxuICAgKi9cbiAgZnVuY3Rpb24gbW9ua2V5UGF0Y2hQbGF5ZXJBcGkoKSB7XG5cbiAgICAvKipcbiAgICAgKiBNb25rZXkgcGF0Y2ggbmVlZGVkIHRvIGhhbmRsZSBmaXJzdFBsYXkgYW5kIHJlc3VtZSBvZiBwbGF5aW5nIGFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxPcmlnUGxheSBuZWNlc3NhcnkgZmxhZyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3Agd2hlbiB5b3UgYXJlIHJlc3RvcmluZyBhIFZBU1QgYWQuXG4gICAgICogQHJldHVybnMge3BsYXllcn1cbiAgICAgKi9cbiAgICB2YXIgb3JpZ1BsYXkgPSBwbGF5ZXIucGxheTtcbiAgICBwbGF5ZXIucGxheSA9IGZ1bmN0aW9uIChjYWxsT3JpZ1BsYXkpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgaWYgKGlzRmlyc3RQbGF5KCkpIHtcbiAgICAgICAgZmlyc3RQbGF5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bWUoY2FsbE9yaWdQbGF5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8qKiogbG9jYWwgZnVuY3Rpb25zICoqKi9cbiAgICAgIGZ1bmN0aW9uIGZpcnN0UGxheSgpIHtcbiAgICAgICAgaWYgKCF1dGlsaXRpZXMuaXNJUGhvbmUoKSkge1xuICAgICAgICAgIGlmICghdm9sdW1lU25hcHNob3QpIHtcbiAgICAgICAgICAgICAgdm9sdW1lU25hcHNob3QgPSBzYXZlVm9sdW1lU25hcHNob3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGxheWVyLm11dGVkKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3JpZ1BsYXkuYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVzdW1lKGNhbGxPcmlnUGxheSkge1xuICAgICAgICBpZiAoaXNBZFBsYXlpbmcoKSAmJiAhY2FsbE9yaWdQbGF5KSB7XG4gICAgICAgICAgcGxheWVyLnZhc3QuYWRVbml0LnJlc3VtZUFkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIFx0aWYgKCFpc1ZwYWlkUGxheWluZygpKSB7XG4gICAgICAgICAgICAgICAgb3JpZ1BsYXkuYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgICAgICAgXHR9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBOZWVkZWQgbW9ua2V5IHBhdGNoIHRvIGhhbmRsZSBwYXVzZSBvZiBwbGF5aW5nIGFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxPcmlnUGxheSBuZWNlc3NhcnkgZmxhZyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3Agd2hlbiB5b3UgYXJlIHBhdXNpbmcgYSBWQVNUIGFkLlxuICAgICAqIEByZXR1cm5zIHtwbGF5ZXJ9XG4gICAgICovXG4gICAgdmFyIG9yaWdQYXVzZSA9IHBsYXllci5wYXVzZTtcbiAgICBwbGF5ZXIucGF1c2UgPSBmdW5jdGlvbiAoY2FsbE9yaWdQYXVzZSkge1xuICAgICAgaWYgKGlzQWRQbGF5aW5nKCkgJiYgIWNhbGxPcmlnUGF1c2UpIHtcbiAgICAgICAgcGxheWVyLnZhc3QuYWRVbml0LnBhdXNlQWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICBcdGlmICghaXNWcGFpZFBsYXlpbmcoKSkge1xuICAgICAgXHRcdG9yaWdQYXVzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgXHR9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBOZWVkZWQgbW9ua2V5IHBhdGNoIHRvIGhhbmRsZSBwYXVzZWQgc3RhdGUgb2YgdGhlIHBsYXllciB3aGVuIGFkcyBhcmUgcGxheWluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsT3JpZ1BsYXkgbmVjZXNzYXJ5IGZsYWcgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wIHdoZW4geW91IGFyZSBwYXVzaW5nIGEgVkFTVCBhZC5cbiAgICAgKiBAcmV0dXJucyB7cGxheWVyfVxuICAgICAqL1xuICAgIHZhciBvcmlnUGF1c2VkID0gcGxheWVyLnBhdXNlZDtcbiAgICBwbGF5ZXIucGF1c2VkID0gZnVuY3Rpb24gKGNhbGxPcmlnUGF1c2VkKSB7XG4gICAgICBpZiAoaXNBZFBsYXlpbmcoKSAmJiAhY2FsbE9yaWdQYXVzZWQpIHtcbiAgICAgICAgcmV0dXJuIHBsYXllci52YXN0LmFkVW5pdC5pc1BhdXNlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdQYXVzZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIFxuICBmdW5jdGlvbiBpc1ZwYWlkUGxheWluZygpIHtcblx0ICByZXR1cm4gcGxheWVyLnZhc3QgJiYgcGxheWVyLnZhc3QuVlBBSUQ7XG4gIH1cblxuICBmdW5jdGlvbiBpc0FkUGxheWluZygpIHtcbiAgICByZXR1cm4gcGxheWVyLnZhc3QgJiYgcGxheWVyLnZhc3QuYWRVbml0O1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9UcmlnZ2VyRmlyc3RQbGF5KCkge1xuICAgIGlmIChpc0ZpcnN0UGxheSgpKSB7XG4gIFx0ICB3aW5kb3cuX21vbFNldHRpbmdzLmZpcnN0UGxheSA9IGZhbHNlO1xuICAgICAgLy9fZmlyc3RQbGF5ID0gZmFsc2U7XG4gICAgICBwbGF5ZXIudHJpZ2dlcigndmFzdC5maXJzdFBsYXknKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEZpcnN0UGxheSgpIHtcblx0ICB3aW5kb3cuX21vbFNldHRpbmdzLmZpcnN0UGxheSA9IHRydWU7XG5cdCAgICAvL19maXJzdFBsYXkgPSB0cnVlO1xuICAgIGJsYWNrUG9zdGVyLnNob3coKTtcbiAgICByZXN0b3JlQ29udGVudFZvbHVtZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGaXJzdFBsYXkoKSB7XG5cdCAgcmV0dXJuIHdpbmRvdy5fbW9sU2V0dGluZ3MuZmlyc3RQbGF5O1xuXHQgICAgLy9yZXR1cm4gX2ZpcnN0UGxheTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhdmVWb2x1bWVTbmFwc2hvdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbXV0ZWQ6IHBsYXllci5tdXRlZCgpLFxuICAgICAgdm9sdW1lOiBwbGF5ZXIudm9sdW1lKClcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZUNvbnRlbnRWb2x1bWUoKSB7XG4gICAgaWYgKHZvbHVtZVNuYXBzaG90KSB7XG4gICAgICAvL3BsYXllci5jdXJyZW50VGltZSgwKTtcbiAgICAgIHJlc3RvcmVWb2x1bWVTbmFwc2hvdCh2b2x1bWVTbmFwc2hvdCk7XG4gICAgICB2b2x1bWVTbmFwc2hvdCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZVZvbHVtZVNuYXBzaG90KHNuYXBzaG90KSB7XG4gICAgaWYgKHV0aWxpdGllcy5pc09iamVjdChzbmFwc2hvdCkpIHtcbiAgICAgIHBsYXllci52b2x1bWUoc25hcHNob3Qudm9sdW1lKTtcbiAgICAgIHBsYXllci5tdXRlZChzbmFwc2hvdC5tdXRlZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGlkZUJsYWNrUG9zdGVyKCkge1xuICAgIGlmICghZG9tLmhhc0NsYXNzKGJsYWNrUG9zdGVyLmVsKCksICd2anMtaGlkZGVuJykpIHtcbiAgICAgIGJsYWNrUG9zdGVyLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRTdHlsZXMoKSB7XG4gICAgZG9tLmFkZENsYXNzKHBsYXllci5lbCgpLCAndmpzLWFkLXBsYXlpbmcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVN0eWxlcygpIHtcblx0ICBwbGF5ZXIub2ZmKCdwbGF5JywgdHJ5VG9UcmlnZ2VyRmlyc3RQbGF5KTtcblx0ICBwbGF5ZXIub2ZmKCd2YXN0LnJlc2V0JywgcmVzZXRGaXJzdFBsYXkpOy8vRXZlcnkgdGltZSB3ZSBjaGFuZ2UgdGhlIHNvdXJjZXMgd2UgcmVzZXQgdGhlIGZpcnN0IHBsYXkuXG5cdCAgcGxheWVyLm9mZigndmFzdC5maXJzdFBsYXknLCByZXN0b3JlQ29udGVudFZvbHVtZSk7XG5cdCAgcGxheWVyLm9mZignZXJyb3InLCBoaWRlQmxhY2tQb3N0ZXIpOy8vSWYgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIHBsYXllciB3ZSByZW1vdmUgdGhlIGJsYWNrcG9zdGVyIHRvIHNob3cgdGhlIGVyciBtc2dcblx0ICBwbGF5ZXIub2ZmKCd2YXN0LmFkU3RhcnQnLCBoaWRlQmxhY2tQb3N0ZXIpO1xuXHQgIHBsYXllci5vZmYoJ3Zhc3QuYWRzQ2FuY2VsJywgaGlkZUJsYWNrUG9zdGVyKTtcblx0ICBwbGF5ZXIub2ZmKCd2YXN0LmFkRXJyb3InLCBoaWRlQmxhY2tQb3N0ZXIpO1xuXHQgIHBsYXllci5vZmYoJ3Zhc3QuYWRTdGFydCcsIGFkZFN0eWxlcyk7XG5cdCAgcGxheWVyLm9mZigndmFzdC5hZEVuZCcsIHJlbW92ZVN0eWxlcyk7XG5cdCAgcGxheWVyLm9mZigndmFzdC5hZHNDYW5jZWwnLCByZW1vdmVTdHlsZXMpO1xuXHQgIFxuICAgICAgZG9tLnJlbW92ZUNsYXNzKHBsYXllci5lbCgpLCAndmpzLWFkLXBsYXlpbmcnKTtcblx0ICBkb20ucmVtb3ZlQ2xhc3MocGxheWVyLmNvbnRyb2xCYXIucGxheVRvZ2dsZS5lbCgpLCAndmpzLWVuZGVkJyk7XG5cdCAgXG5cdCAgaWYgKGVycm9yRGlhbG9nKSB7XG5cdFx0ICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0ICBlcnJvckRpYWxvZy5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnZGlzcGxheScpO1xuXHRcdCAgfSwgNTAwKTtcblx0ICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBwb3N0ZXIgYXR0cmlidXRlIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQgdGVjaCwgaWYgcHJlc2VudC4gV2hlblxuICogcmV1c2luZyBhIHZpZGVvIGVsZW1lbnQgZm9yIG11bHRpcGxlIHZpZGVvcywgdGhlIHBvc3RlciBpbWFnZSB3aWxsIGJyaWVmbHlcbiAqIHJlYXBwZWFyIHdoaWxlIHRoZSBuZXcgc291cmNlIGxvYWRzLiBSZW1vdmluZyB0aGUgYXR0cmlidXRlIGFoZWFkIG9mIHRpbWVcbiAqIHByZXZlbnRzIHRoZSBwb3N0ZXIgZnJvbSBzaG93aW5nIHVwIGJldHdlZW4gdmlkZW9zLlxuICogQHBhcmFtIHtvYmplY3R9IHBsYXllciBUaGUgdmlkZW9qcyBwbGF5ZXIgb2JqZWN0XG4gKi9cbnBsYXllclV0aWxzLnJlbW92ZU5hdGl2ZVBvc3RlciA9IGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgdmFyIHRlY2ggPSBwbGF5ZXIuZWwoKS5xdWVyeVNlbGVjdG9yKCcudmpzLXRlY2gnKTtcbiAgaWYgKHRlY2gpIHtcbiAgICB0ZWNoLnJlbW92ZUF0dHJpYnV0ZSgncG9zdGVyJyk7XG4gIH1cbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGxpc3RlbiB0byBtYW55IGV2ZW50cyB1bnRpbCBvbmUgb2YgdGhlbSBnZXRzIGZpcmVkLCB0aGVuIHdlXG4gKiBleGVjdXRlIHRoZSBoYW5kbGVyIGFuZCB1bnN1YnNjcmliZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycztcbiAqXG4gKiBAcGFyYW0gcGxheWVyIHNwZWNpZmljIHBsYXllciBmcm9tIHdoZXJlIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50c1xuICogQHBhcmFtIGV2ZW50cyBhcnJheSBvZiBldmVudHNcbiAqIEBwYXJhbSBoYW5kbGVyIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSBvbmUgb2YgdGhlIGV2ZW50cyBmaXJlc1xuICovXG5wbGF5ZXJVdGlscy5vbmNlID0gZnVuY3Rpb24gb25jZShwbGF5ZXIsIGV2ZW50cywgaGFuZGxlcikge1xuICBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cbiAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHBsYXllci5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgIHBsYXllci5vbihldmVudCwgbGlzdGVuZXIpO1xuICB9KTtcbn07XG5cbi8vcGx1Z2luIHV0aWxzXG5wbGF5ZXJVdGlscy5zaG93QmlnUGxheUJ1dHRvbiA9IGZ1bmN0aW9uKHBsYXllciwgc2hvdykge1xuXHR2YXIgYnV0dG9uID0gcGxheWVyLmJpZ1BsYXlCdXR0b24uZWxfO1xuXHRpZiAoYnV0dG9uKSB7XG5cdFx0aWYgKHNob3cpIHtcblx0XHRcdGJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0XHRcdGJ1dHRvbi5zdHlsZS56SW5kZXggPSA5OTk5OTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRidXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdGJ1dHRvbi5zdHlsZS56SW5kZXggPSAnJztcblx0XHR9XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGxheWVyVXRpbHM7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXR5RnVuY3Rpb25zJyk7XG5cbi8qKlxuICpcbiAqIElNUE9SVEFOVCBOT1RFOiBUaGlzIGZ1bmN0aW9uIGNvbWVzIGZyb20gYW5ndWxhckpzIGFuZCB3YXMgb3JpZ2luYWxseSBjYWxsZWQgdXJsUmVzb2x2ZVxuICogICAgICAgICAgICAgICAgIHlvdSBjYW4gdGFrZSBhIGxvb2sgYXQgdGhlIG9yaWdpbmFsIGNvZGUgaGVyZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL2Jsb2IvbWFzdGVyL3NyYy9uZy91cmxVdGlscy5qc1xuICpcbiAqIEltcGxlbWVudGF0aW9uIE5vdGVzIGZvciBub24tSUUgYnJvd3NlcnNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEFzc2lnbmluZyBhIFVSTCB0byB0aGUgaHJlZiBwcm9wZXJ0eSBvZiBhbiBhbmNob3IgRE9NIG5vZGUsIGV2ZW4gb25lIGF0dGFjaGVkIHRvIHRoZSBET00sXG4gKiByZXN1bHRzIGJvdGggaW4gdGhlIG5vcm1hbGl6aW5nIGFuZCBwYXJzaW5nIG9mIHRoZSBVUkwuICBOb3JtYWxpemluZyBtZWFucyB0aGF0IGEgcmVsYXRpdmVcbiAqIFVSTCB3aWxsIGJlIHJlc29sdmVkIGludG8gYW4gYWJzb2x1dGUgVVJMIGluIHRoZSBjb250ZXh0IG9mIHRoZSBhcHBsaWNhdGlvbiBkb2N1bWVudC5cbiAqIFBhcnNpbmcgbWVhbnMgdGhhdCB0aGUgYW5jaG9yIG5vZGUncyBob3N0LCBob3N0bmFtZSwgcHJvdG9jb2wsIHBvcnQsIHBhdGhuYW1lIGFuZCByZWxhdGVkXG4gKiBwcm9wZXJ0aWVzIGFyZSBhbGwgcG9wdWxhdGVkIHRvIHJlZmxlY3QgdGhlIG5vcm1hbGl6ZWQgVVJMLiAgVGhpcyBhcHByb2FjaCBoYXMgd2lkZVxuICogY29tcGF0aWJpbGl0eSAtIFNhZmFyaSAxKywgTW96aWxsYSAxKywgT3BlcmEgNyssZSBldGMuICBTZWVcbiAqIGh0dHA6Ly93d3cuYXB0YW5hLmNvbS9yZWZlcmVuY2UvaHRtbC9hcGkvSFRNTEFuY2hvckVsZW1lbnQuaHRtbFxuICpcbiAqIEltcGxlbWVudGF0aW9uIE5vdGVzIGZvciBJRVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBJRSA+PSA4IGFuZCA8PSAxMCBub3JtYWxpemVzIHRoZSBVUkwgd2hlbiBhc3NpZ25lZCB0byB0aGUgYW5jaG9yIG5vZGUgc2ltaWxhciB0byB0aGUgb3RoZXJcbiAqIGJyb3dzZXJzLiAgSG93ZXZlciwgdGhlIHBhcnNlZCBjb21wb25lbnRzIHdpbGwgbm90IGJlIHNldCBpZiB0aGUgVVJMIGFzc2lnbmVkIGRpZCBub3Qgc3BlY2lmeVxuICogdGhlbS4gIChlLmcuIGlmIHlvdSBhc3NpZ24gYS5ocmVmID0gXCJmb29cIiwgdGhlbiBhLnByb3RvY29sLCBhLmhvc3QsIGV0Yy4gd2lsbCBiZSBlbXB0eS4pICBXZVxuICogd29yayBhcm91bmQgdGhhdCBieSBwZXJmb3JtaW5nIHRoZSBwYXJzaW5nIGluIGEgMm5kIHN0ZXAgYnkgdGFraW5nIGEgcHJldmlvdXNseSBub3JtYWxpemVkXG4gKiBVUkwgKGUuZy4gYnkgYXNzaWduaW5nIHRvIGEuaHJlZikgYW5kIGFzc2lnbmluZyBpdCBhLmhyZWYgYWdhaW4uICBUaGlzIGNvcnJlY3RseSBwb3B1bGF0ZXMgdGhlXG4gKiBwcm9wZXJ0aWVzIHN1Y2ggYXMgcHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0LCBldGMuXG4gKlxuICogSUU3IGRvZXMgbm90IG5vcm1hbGl6ZSB0aGUgVVJMIHdoZW4gYXNzaWduZWQgdG8gYW4gYW5jaG9yIG5vZGUuICAoQXBwYXJlbnRseSwgaXQgZG9lcywgaWYgb25lXG4gKiB1c2VzIHRoZSBpbm5lciBIVE1MIGFwcHJvYWNoIHRvIGFzc2lnbiB0aGUgVVJMIGFzIHBhcnQgb2YgYW4gSFRNTCBzbmlwcGV0IC1cbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ3MjcyOSkgIEhvd2V2ZXIsIHNldHRpbmcgaW1nW3NyY10gZG9lcyBub3JtYWxpemUgdGhlIFVSTC5cbiAqIFVuZm9ydHVuYXRlbHksIHNldHRpbmcgaW1nW3NyY10gdG8gc29tZXRoaW5nIGxpa2UgXCJqYXZhc2NyaXB0OmZvb1wiIG9uIElFIHRocm93cyBhbiBleGNlcHRpb24uXG4gKiBTaW5jZSB0aGUgcHJpbWFyeSB1c2FnZSBmb3Igbm9ybWFsaXppbmcgVVJMcyBpcyB0byBzYW5pdGl6ZSBzdWNoIFVSTHMsIHdlIGNhbid0IHVzZSB0aGF0XG4gKiBtZXRob2QgYW5kIElFIDwgOCBpcyB1bnN1cHBvcnRlZC5cbiAqXG4gKiBSZWZlcmVuY2VzOlxuICogICBodHRwOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MQW5jaG9yRWxlbWVudFxuICogICBodHRwOi8vd3d3LmFwdGFuYS5jb20vcmVmZXJlbmNlL2h0bWwvYXBpL0hUTUxBbmNob3JFbGVtZW50Lmh0bWxcbiAqICAgaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvcHVsbC8yOTAyXG4gKiAgIGh0dHA6Ly9qYW1lcy5wYWRvbHNleS5jb20vamF2YXNjcmlwdC9wYXJzaW5nLXVybHMtd2l0aC10aGUtZG9tL1xuICpcbiAqIEBraW5kIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkLlxuICogQGRlc2NyaXB0aW9uIE5vcm1hbGl6ZXMgYW5kIHBhcnNlcyBhIFVSTC5cbiAqIEByZXR1cm5zIHtvYmplY3R9IFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgVVJMIGFzIGEgZGljdGlvbmFyeS5cbiAqXG4gKiAgIHwgbWVtYmVyIG5hbWUgICB8IERlc2NyaXB0aW9uICAgIHxcbiAqICAgfC0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tfFxuICogICB8IGhyZWYgICAgICAgICAgfCBBIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgcHJvdmlkZWQgVVJMIGlmIGl0IHdhcyBub3QgYW4gYWJzb2x1dGUgVVJMIHxcbiAqICAgfCBwcm90b2NvbCAgICAgIHwgVGhlIHByb3RvY29sIGluY2x1ZGluZyB0aGUgdHJhaWxpbmcgY29sb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgIHwgaG9zdCAgICAgICAgICB8IFRoZSBob3N0IGFuZCBwb3J0IChpZiB0aGUgcG9ydCBpcyBub24tZGVmYXVsdCkgb2YgdGhlIG5vcm1hbGl6ZWRVcmwgICAgfFxuICogICB8IHNlYXJjaCAgICAgICAgfCBUaGUgc2VhcmNoIHBhcmFtcywgbWludXMgdGhlIHF1ZXN0aW9uIG1hcmsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgfCBoYXNoICAgICAgICAgIHwgVGhlIGhhc2ggc3RyaW5nLCBtaW51cyB0aGUgaGFzaCBzeW1ib2xcbiAqICAgfCBob3N0bmFtZSAgICAgIHwgVGhlIGhvc3RuYW1lXG4gKiAgIHwgcG9ydCAgICAgICAgICB8IFRoZSBwb3J0LCB3aXRob3V0IFwiOlwiXG4gKiAgIHwgcGF0aG5hbWUgICAgICB8IFRoZSBwYXRobmFtZSwgYmVnaW5uaW5nIHdpdGggXCIvXCJcbiAqXG4gKi9cblxudmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4vKipcbiAqIGRvY3VtZW50TW9kZSBpcyBhbiBJRS1vbmx5IHByb3BlcnR5XG4gKiBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvY2MxOTY5ODgodj12cy44NSkuYXNweFxuICovXG52YXIgbXNpZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcblxuZnVuY3Rpb24gdXJsUGFydHModXJsKSB7XG4gIHZhciBocmVmID0gdXJsO1xuXG4gIGlmIChtc2llKSB7XG4gICAgLy8gTm9ybWFsaXplIGJlZm9yZSBwYXJzZS4gIFJlZmVyIEltcGxlbWVudGF0aW9uIE5vdGVzIG9uIHdoeSB0aGlzIGlzXG4gICAgLy8gZG9uZSBpbiB0d28gc3RlcHMgb24gSUUuXG4gICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBocmVmKTtcbiAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgfVxuXG4gIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgcmV0dXJuIHtcbiAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgcG9ydDogdXRpbGl0aWVzLmlzTm90RW1wdHlTdHJpbmcodXJsUGFyc2luZ05vZGUucG9ydCk/IHVybFBhcnNpbmdOb2RlLnBvcnQ6IDgwLFxuICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpXG4gICAgICA/IHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICA6ICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gIH07XG59XG5cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYSBxdWVyeSBzdHJpbmcgKHNlYXJjaCBwYXJ0IG9mIGEgdXJsKSBhbmQgcmV0dXJucyBhIGRpY3Rpb25hcnkgd2l0aFxuICogdGhlIGRpZmZlcmVudCBrZXkgdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBxcyBxdWVyeVN0cmluZ1xuICovXG5mdW5jdGlvbiBxdWVyeVN0cmluZ1RvT2JqKHFzLCBjb25kKSB7XG4gIHZhciBwYWlycywgcXNPYmo7XG5cbiAgY29uZCA9IHV0aWxpdGllcy5pc0Z1bmN0aW9uKGNvbmQpPyBjb25kIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcXMgPSBxcy50cmltKCkucmVwbGFjZSgvXlxcPy8sICcnKTtcbiAgcGFpcnMgPSBxcy5zcGxpdCgnJicpO1xuICBxc09iaiA9IHt9O1xuXG4gIHV0aWxpdGllcy5mb3JFYWNoKHBhaXJzLCBmdW5jdGlvbiAocGFpcikge1xuICAgIHZhciBrZXlWYWx1ZSwga2V5LCB2YWx1ZTtcbiAgICBpZiAocGFpciAhPT0gJycpIHtcbiAgICAgIGtleVZhbHVlID0gcGFpci5zcGxpdCgnPScpO1xuICAgICAga2V5ID0ga2V5VmFsdWVbMF07XG4gICAgICB2YWx1ZSA9IGtleVZhbHVlWzFdO1xuICAgICAgaWYoY29uZChrZXksIHZhbHVlKSl7XG4gICAgICAgIHFzT2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBxc09iajtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW4gb2JqZWN0IGFuZCBzZXJpYWxpemVzIGl0IGludG8gYSBxdWVyeSBzdHJpbmcgd2l0aG91dCB0aGUgbGVhZGluZyAnPydcbiAqIEBwYXJhbSBvYmpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9ialRvUXVlcnlTdHJpbmcob2JqKSB7XG4gIHZhciBwYWlycyA9IFtdO1xuICB1dGlsaXRpZXMuZm9yRWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcGFpcnMucHVzaChrZXkgKyAnPScgKyB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdXJsUGFydHM6IHVybFBhcnRzLFxuICBxdWVyeVN0cmluZ1RvT2JqOiBxdWVyeVN0cmluZ1RvT2JqLFxuICBvYmpUb1F1ZXJ5U3RyaW5nOiBvYmpUb1F1ZXJ5U3RyaW5nXG59O1xuIiwiLypqc2hpbnQgdW51c2VkOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIE5PREVfVFlQRV9FTEVNRU5UID0gMTtcbnZhciBTTkFLRV9DQVNFX1JFR0VYUCA9IC9bQS1aXS9nO1xudmFyIEVNQUlMX1JFR0VYUCA9IC9eW2EtejAtOSEjJCUmJyorXFwvPT9eX2B7fH1+Li1dK0BbYS16MC05XShbYS16MC05LV0qW2EtejAtOV0pPyhcXC5bYS16MC05XShbYS16MC05LV0qW2EtejAtOV0pPykrJC9pO1xuLypqc2xpbnQgbWF4bGVuOiA1MDAgKi9cbnZhciBJU084MDg2X1JFR0VYUCA9IC9eKFtcXCstXT9cXGR7NH0oPyFcXGR7Mn1cXGIpKSgoLT8pKCgwWzEtOV18MVswLTJdKShcXDMoWzEyXVxcZHwwWzEtOV18M1swMV0pKT98VyhbMC00XVxcZHw1WzAtMl0pKC0/WzEtN10pP3woMDBbMS05XXwwWzEtOV1cXGR8WzEyXVxcZHsyfXwzKFswLTVdXFxkfDZbMS02XSkpKShbVFxcc10oKChbMDFdXFxkfDJbMC0zXSkoKDo/KVswLTVdXFxkKT98MjRcXDo/MDApKFtcXC4sXVxcZCsoPyE6KSk/KT8oXFwxN1swLTVdXFxkKFtcXC4sXVxcZCspPyk/KFt6Wl18KFtcXCstXSkoWzAxXVxcZHwyWzAtM10pOj8oWzAtNV1cXGQpPyk/KT8pPyQvO1xuXG5cbmZ1bmN0aW9uIG5vb3AoKXsgfVxuXG5mdW5jdGlvbiBpc051bGwobykge1xuICByZXR1cm4gbyA9PT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkKG8pe1xuICByZXR1cm4gbyAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvKXtcbiAgcmV0dXJuIG8gPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihzdHIpe1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIobnVtKXtcbiAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc1dpbmRvdyhvYmopIHtcbiAgcmV0dXJuIHV0aWxpdGllcy5pc09iamVjdChvYmopICYmIG9iai53aW5kb3cgPT09IG9iajtcbn1cblxuZnVuY3Rpb24gaXNBcnJheShhcnJheSl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoIGFycmF5ICkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKG9iaikge1xuICBpZiAob2JqID09PSBudWxsIHx8IHV0aWxpdGllcy5pc1dpbmRvdyhvYmopIHx8IHV0aWxpdGllcy5pc0Z1bmN0aW9uKG9iaikgfHwgdXRpbGl0aWVzLmlzVW5kZWZpbmVkKG9iaikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcblxuICBpZiAob2JqLm5vZGVUeXBlID09PSBOT0RFX1RZUEVfRUxFTUVOVCAmJiBsZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB1dGlsaXRpZXMuaXNTdHJpbmcob2JqKSB8fCB1dGlsaXRpZXMuaXNBcnJheShvYmopIHx8IGxlbmd0aCA9PT0gMCB8fFxuICAgIHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInICYmIGxlbmd0aCA+IDAgJiYgKGxlbmd0aCAtIDEpIGluIG9iajtcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcoc3RyKSB7XG4gIHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJztcbn1cblxuZnVuY3Rpb24gaXNFbXB0eVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHV0aWxpdGllcy5pc1N0cmluZyhzdHIpICYmIHN0ci5sZW5ndGggPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzTm90RW1wdHlTdHJpbmcoc3RyKSB7XG4gIHJldHVybiB1dGlsaXRpZXMuaXNTdHJpbmcoc3RyKSAmJiBzdHIubGVuZ3RoICE9PSAwO1xufVxuXG5mdW5jdGlvbiBhcnJheUxpa2VPYmpUb0FycmF5KGFyZ3MpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgdmFyIGtleSwgbGVuZ3RoO1xuICBpZiAob2JqKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24ob2JqKSkge1xuICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIC8vIE5lZWQgdG8gY2hlY2sgaWYgaGFzT3duUHJvcGVydHkgZXhpc3RzLFxuICAgICAgICAvLyBhcyBvbiBJRTggdGhlIHJlc3VsdCBvZiBxdWVyeVNlbGVjdG9yQWxsIGlzIGFuIG9iamVjdCB3aXRob3V0IGEgaGFzT3duUHJvcGVydHkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGtleSAhPT0gJ3Byb3RvdHlwZScgJiYga2V5ICE9PSAnbGVuZ3RoJyAmJiBrZXkgIT09ICduYW1lJyAmJiAoIW9iai5oYXNPd25Qcm9wZXJ0eSB8fCBvYmouaGFzT3duUHJvcGVydHkoa2V5KSkpIHtcbiAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgdmFyIGlzUHJpbWl0aXZlID0gdHlwZW9mIG9iaiAhPT0gJ29iamVjdCc7XG4gICAgICBmb3IgKGtleSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGtleSA8IGxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgaWYgKGlzUHJpbWl0aXZlIHx8IGtleSBpbiBvYmopIHtcbiAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iai5mb3JFYWNoICYmIG9iai5mb3JFYWNoICE9PSBmb3JFYWNoKSB7XG4gICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCwgb2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBzbmFrZV9jYXNlKG5hbWUsIHNlcGFyYXRvcikge1xuICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgJ18nO1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKFNOQUtFX0NBU0VfUkVHRVhQLCBmdW5jdGlvbihsZXR0ZXIsIHBvcykge1xuICAgIHJldHVybiAocG9zID8gc2VwYXJhdG9yIDogJycpICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRW1haWwoZW1haWwpe1xuICBpZighdXRpbGl0aWVzLmlzU3RyaW5nKGVtYWlsKSl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIEVNQUlMX1JFR0VYUC50ZXN0KGVtYWlsLnRyaW0oKSk7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCAob2JqKSB7XG4gIHZhciBhcmcsIGksIGs7XG4gIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChrIGluIGFyZykge1xuICAgICAgaWYgKGFyZy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICBpZihpc09iamVjdChvYmpba10pICYmICFpc051bGwob2JqW2tdKSAmJiBpc09iamVjdChhcmdba10pKXtcbiAgICAgICAgICBvYmpba10gPSBleHRlbmQoe30sIG9ialtrXSwgYXJnW2tdKTtcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgIG9ialtrXSA9IGFyZ1trXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHMpe1xuICByZXR1cm4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7XG59XG5cbmZ1bmN0aW9uIGRlY2FwaXRhbGl6ZShzKSB7XG4gIHJldHVybiBzLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgcy5zbGljZSgxKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCB3b3JrcyB0aGUgc2FtZSB3YXkgYXJyYXkucHJvdG90eXBlLm1hcCB3b3JrcyBidXQgaWYgdGhlIHRyYW5zZm9ybWVyIHJldHVybnMgdW5kZWZpbmUsIHRoZW5cbiAqIGl0IHdvbid0IGJlIGFkZGVkIHRvIHRoZSB0cmFuc2Zvcm1lZCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtQXJyYXkoYXJyYXksIHRyYW5zZm9ybWVyKSB7XG4gIHZhciB0cmFuc2Zvcm1lZEFycmF5ID0gW107XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpbmRleCl7XG4gICAgdmFyIHRyYW5zZm9ybWVkSXRlbSA9IHRyYW5zZm9ybWVyKGl0ZW0sIGluZGV4KTtcbiAgICBpZih1dGlsaXRpZXMuaXNEZWZpbmVkKHRyYW5zZm9ybWVkSXRlbSkpIHtcbiAgICAgIHRyYW5zZm9ybWVkQXJyYXkucHVzaCh0cmFuc2Zvcm1lZEl0ZW0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybWVkQXJyYXk7XG59XG5cbmZ1bmN0aW9uIHRvRml4ZWREaWdpdHMobnVtLCBkaWdpdHMpIHtcbiAgdmFyIGZvcm1hdHRlZE51bSA9IG51bSArICcnO1xuICBkaWdpdHMgPSB1dGlsaXRpZXMuaXNOdW1iZXIoZGlnaXRzKSA/IGRpZ2l0cyA6IDA7XG4gIG51bSA9IHV0aWxpdGllcy5pc051bWJlcihudW0pID8gbnVtIDogcGFyc2VJbnQobnVtLCAxMCk7XG4gIGlmKHV0aWxpdGllcy5pc051bWJlcihudW0pICYmICFpc05hTihudW0pKXtcbiAgICBmb3JtYXR0ZWROdW0gPSBudW0gKyAnJztcbiAgICB3aGlsZShmb3JtYXR0ZWROdW0ubGVuZ3RoIDwgZGlnaXRzKSB7XG4gICAgICBmb3JtYXR0ZWROdW0gPSAnMCcgKyBmb3JtYXR0ZWROdW07XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXR0ZWROdW07XG4gIH1cbiAgcmV0dXJuIE5hTiArICcnO1xufVxuXG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaywgZGVsYXkpIHtcbiAgdmFyIHByZXZpb3VzQ2FsbCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gKGRlbGF5ICsgMSk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGlmICgodGltZSAtIHByZXZpb3VzQ2FsbCkgPj0gZGVsYXkpIHtcbiAgICAgIHByZXZpb3VzQ2FsbCA9IHRpbWU7XG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVib3VuY2UgKGNhbGxiYWNrLCB3YWl0KSB7XG4gIHZhciB0aW1lb3V0SWQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpe1xuICAgIGlmKHRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgfSwgd2FpdCk7XG4gIH07XG59XG5cbi8vIGEgZnVuY3Rpb24gZGVzaWduZWQgdG8gYmxvdyB1cCB0aGUgc3RhY2sgaW4gYSBuYWl2ZSB3YXlcbi8vIGJ1dCBpdCBpcyBvayBmb3IgdmlkZW9KcyBjaGlsZHJlbiBjb21wb25lbnRzXG5mdW5jdGlvbiB0cmVlU2VhcmNoKHJvb3QsIGdldENoaWxkcmVuLCBmb3VuZCl7XG4gIHZhciBjaGlsZHJlbiA9IGdldENoaWxkcmVuKHJvb3QpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKXtcbiAgICBpZiAoZm91bmQoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGVsID0gdHJlZVNlYXJjaChjaGlsZHJlbltpXSwgZ2V0Q2hpbGRyZW4sIGZvdW5kKTtcbiAgICAgIGlmIChlbCl7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZWNob0ZuKHZhbCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2YWw7XG4gIH07XG59XG5cbi8vTm90ZTogU3VwcG9ydGVkIGZvcm1hdHMgY29tZSBmcm9tIGh0dHA6Ly93d3cudzMub3JnL1RSL05PVEUtZGF0ZXRpbWVcbi8vIGFuZCB0aGUgaXNvODYwMSByZWdleCBjb21lcyBmcm9tIGh0dHA6Ly93d3cucGVsYWdvZGVzaWduLmNvbS9ibG9nLzIwMDkvMDUvMjAvaXNvLTg2MDEtZGF0ZS12YWxpZGF0aW9uLXRoYXQtZG9lc250LXN1Y2svXG5mdW5jdGlvbiBpc0lTTzg2MDEodmFsdWUpIHtcbiAgaWYodXRpbGl0aWVzLmlzTnVtYmVyKHZhbHVlKSl7XG4gICAgdmFsdWUgPSB2YWx1ZSArICcnOyAgLy93ZSBtYWtlIHN1cmUgdGhhdCB3ZSBhcmUgd29ya2luZyB3aXRoIHN0cmluZ3NcbiAgfVxuXG4gIGlmKCF1dGlsaXRpZXMuaXNTdHJpbmcodmFsdWUpKXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gSVNPODA4Nl9SRUdFWFAudGVzdCh2YWx1ZS50cmltKCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgQnJvd3NlciBpcyBJRTkgYW5kIGJlbG93XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIHZlcnNpb24gPSB1dGlsaXRpZXMuZ2V0SW50ZXJuZXRFeHBsb3JlclZlcnNpb24obmF2aWdhdG9yKTtcbiAgaWYgKHZlcnNpb24gPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHZlcnNpb24gPCAxMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2ZXJzaW9uIG9mIEludGVybmV0IEV4cGxvcmVyIG9yIGEgLTEgKGluZGljYXRpbmcgdGhlIHVzZSBvZiBhbm90aGVyIGJyb3dzZXIpLlxuICogU291cmNlOiBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM3NTA5KHY9dnMuODUpLmFzcHhcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSB2ZXJzaW9uIG9mIEludGVybmV0IEV4cGxvcmVyIG9yIGEgLTEgKGluZGljYXRpbmcgdGhlIHVzZSBvZiBhbm90aGVyIGJyb3dzZXIpLlxuICovXG5mdW5jdGlvbiBnZXRJbnRlcm5ldEV4cGxvcmVyVmVyc2lvbihuYXZpZ2F0b3IpIHtcbiAgdmFyIHJ2ID0gLTE7XG5cbiAgaWYgKG5hdmlnYXRvci5hcHBOYW1lID09ICdNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXInKSB7XG4gICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiTVNJRSAoWzAtOV17MSx9W1xcLjAtOV17MCx9KVwiKTtcbiAgICB2YXIgcmVzID0gcmUuZXhlYyh1YSk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgcnYgPSBwYXJzZUZsb2F0KHJlc1sxXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2O1xufVxuXG5mdW5jdGlvbiBpc0lFMTEoKSB7XG4gIHZhciByZXMgPSBuYXZpZ2F0b3IudXNlckFnZW50LnNlYXJjaCgvKHRyaWRlbnQpLitydls6XFxzXShbXFx3XFwuXSspLitsaWtlXFxzZ2Vja28vaSk7XG4gIHJldHVybiByZXMgPj0gMDtcbn1cblxuLyoqKiBNb2JpbGUgVXRpbGl0eSBmdW5jdGlvbnMgKioqL1xuZnVuY3Rpb24gaXNJRGV2aWNlKCkge1xuICByZXR1cm4gL2lQKGhvbmV8YWQpLy50ZXN0KHV0aWxpdGllcy5fVUEpO1xufVxuXG5mdW5jdGlvbiBpc01vYmlsZSgpIHtcbiAgcmV0dXJuIC9pUChob25lfGFkfG9kKXxBbmRyb2lkfFdpbmRvd3MgUGhvbmUvLnRlc3QodXRpbGl0aWVzLl9VQSk7XG59XG5cbmZ1bmN0aW9uIGlzSVBob25lKCkge1xuICByZXR1cm4gL2lQKGhvbmV8b2QpLy50ZXN0KHV0aWxpdGllcy5fVUEpO1xufVxuXG5mdW5jdGlvbiBpc0FuZHJvaWQoKSB7XG4gIHJldHVybiAvQW5kcm9pZC8udGVzdCh1dGlsaXRpZXMuX1VBKTtcbn1cblxudmFyIHV0aWxpdGllcyA9IHtcbiAgX1VBOiBuYXZpZ2F0b3IudXNlckFnZW50LFxuICBub29wOiBub29wLFxuICBpc051bGw6IGlzTnVsbCxcbiAgaXNEZWZpbmVkOiBpc0RlZmluZWQsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzV2luZG93OiBpc1dpbmRvdyxcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUxpa2U6IGlzQXJyYXlMaWtlLFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzRW1wdHlTdHJpbmc6IGlzRW1wdHlTdHJpbmcsXG4gIGlzTm90RW1wdHlTdHJpbmc6IGlzTm90RW1wdHlTdHJpbmcsXG4gIGFycmF5TGlrZU9ialRvQXJyYXk6IGFycmF5TGlrZU9ialRvQXJyYXksXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIHNuYWtlX2Nhc2U6IHNuYWtlX2Nhc2UsXG4gIGlzVmFsaWRFbWFpbDogaXNWYWxpZEVtYWlsLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgY2FwaXRhbGl6ZTogY2FwaXRhbGl6ZSxcbiAgZGVjYXBpdGFsaXplOiBkZWNhcGl0YWxpemUsXG4gIHRyYW5zZm9ybUFycmF5OiB0cmFuc2Zvcm1BcnJheSxcbiAgdG9GaXhlZERpZ2l0czogdG9GaXhlZERpZ2l0cyxcbiAgdGhyb3R0bGU6IHRocm90dGxlLFxuICBkZWJvdW5jZTogZGVib3VuY2UsXG4gIHRyZWVTZWFyY2g6IHRyZWVTZWFyY2gsXG4gIGVjaG9GbjogZWNob0ZuLFxuICBpc0lTTzg2MDE6IGlzSVNPODYwMSxcbiAgaXNPbGRJRTogaXNPbGRJRSxcbiAgZ2V0SW50ZXJuZXRFeHBsb3JlclZlcnNpb246IGdldEludGVybmV0RXhwbG9yZXJWZXJzaW9uLFxuICBpc0lFMTE6IGlzSUUxMSxcbiAgaXNJRGV2aWNlOiBpc0lEZXZpY2UsXG4gIGlzTW9iaWxlOiBpc01vYmlsZSxcbiAgaXNJUGhvbmU6IGlzSVBob25lLFxuICBpc0FuZHJvaWQ6IGlzQW5kcm9pZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsaXRpZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdHlGdW5jdGlvbnMnKTtcblxudmFyIHhtbCA9IHt9O1xuXG54bWwuc3RyVG9YTUxEb2MgPSBmdW5jdGlvbiBzdHJUb1hNTERvYyhzdHJpbmdDb250YWluaW5nWE1MU291cmNlKXtcbiAgLy9JRSA4XG4gIGlmKHR5cGVvZiB3aW5kb3cuRE9NUGFyc2VyID09PSAndW5kZWZpbmVkJyl7XG4gICAgdmFyIHhtbERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxET00nKTtcbiAgICB4bWxEb2N1bWVudC5hc3luYyA9IGZhbHNlO1xuICAgIHhtbERvY3VtZW50LmxvYWRYTUwoc3RyaW5nQ29udGFpbmluZ1hNTFNvdXJjZSk7XG4gICAgcmV0dXJuIHhtbERvY3VtZW50O1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlU3RyaW5nKHN0cmluZ0NvbnRhaW5pbmdYTUxTb3VyY2UpO1xuXG4gIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cmluZ0NvbnRhaW5pbmdYTUxTb3VyY2Upe1xuICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgdmFyIHBhcnNlZERvY3VtZW50O1xuXG4gICAgLy9Ob3RlOiBUaGlzIHRyeSBjYXRjaCBpcyB0byBkZWFsIHdpdGggdGhlIGZhY3QgdGhhdCBvbiBJRSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nIGRvZXMgdGhyb3cgYW4gZXJyb3IgYnV0IHRoZSByZXN0IG9mIHRoZSBicm93c2VycyBkb24ndC5cbiAgICB0cnkge1xuICAgICAgcGFyc2VkRG9jdW1lbnQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN0cmluZ0NvbnRhaW5pbmdYTUxTb3VyY2UsIFwiYXBwbGljYXRpb24veG1sXCIpO1xuXG4gICAgICBpZihpc1BhcnNlRXJyb3IocGFyc2VkRG9jdW1lbnQpIHx8IHV0aWxpdGllcy5pc0VtcHR5U3RyaW5nKHN0cmluZ0NvbnRhaW5pbmdYTUxTb3VyY2UpKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9XG4gICAgfWNhdGNoKGUpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwieG1sLnN0clRvWE1MRE9DOiBFcnJvciBwYXJzaW5nIHRoZSBzdHJpbmc6ICdcIiArIHN0cmluZ0NvbnRhaW5pbmdYTUxTb3VyY2UgKyBcIidcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZERvY3VtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXJzZUVycm9yKHBhcnNlZERvY3VtZW50KSB7XG4gICAgdHJ5IHsgLy8gcGFyc2VyIGFuZCBwYXJzZXJlcnJvck5TIGNvdWxkIGJlIGNhY2hlZCBvbiBzdGFydHVwIGZvciBlZmZpY2llbmN5XG4gICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpLFxuICAgICAgICBlcnJvbmVvdXNQYXJzZSA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoJ0lOVkFMSUQnLCAndGV4dC94bWwnKSxcbiAgICAgICAgcGFyc2VyZXJyb3JOUyA9IGVycm9uZW91c1BhcnNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIilbMF0ubmFtZXNwYWNlVVJJO1xuXG4gICAgICBpZiAocGFyc2VyZXJyb3JOUyA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnKSB7XG4gICAgICAgIC8vIEluIFBoYW50b21KUyB0aGUgcGFyc2VlcnJvciBlbGVtZW50IGRvZXNuJ3Qgc2VlbSB0byBoYXZlIGEgc3BlY2lhbCBuYW1lc3BhY2UsIHNvIHdlIGFyZSBqdXN0IGd1ZXNzaW5nIGhlcmUgOihcbiAgICAgICAgcmV0dXJuIHBhcnNlZERvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIikubGVuZ3RoID4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlZERvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lTlMocGFyc2VyZXJyb3JOUywgJ3BhcnNlcmVycm9yJykubGVuZ3RoID4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvL05vdGUgb24gSUUgcGFyc2VTdHJpbmcgdGhyb3dzIGFuIGVycm9yIGJ5IGl0c2VsZiBhbmQgaXQgd2lsbCBuZXZlciByZWFjaCB0aGlzIGNvZGUuIEJlY2F1c2UgaXQgd2lsbCBoYXZlIGZhaWxlZCBiZWZvcmVcbiAgICB9XG4gIH1cbn07XG5cbnhtbC5wYXJzZVRleHQgPSBmdW5jdGlvbiBwYXJzZVRleHQgKHNWYWx1ZSkge1xuICBpZiAoL15cXHMqJC8udGVzdChzVmFsdWUpKSB7IHJldHVybiBudWxsOyB9XG4gIGlmICgvXig/OnRydWV8ZmFsc2UpJC9pLnRlc3Qoc1ZhbHVlKSkgeyByZXR1cm4gc1ZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiOyB9XG4gIGlmIChpc0Zpbml0ZShzVmFsdWUpKSB7IHJldHVybiBwYXJzZUZsb2F0KHNWYWx1ZSk7IH1cbiAgaWYgKHV0aWxpdGllcy5pc0lTTzg2MDEoc1ZhbHVlKSkgeyByZXR1cm4gbmV3IERhdGUoc1ZhbHVlKTsgfVxuICByZXR1cm4gc1ZhbHVlLnRyaW0oKTtcbn07XG5cbnhtbC5KWE9OVHJlZSA9IGZ1bmN0aW9uIEpYT05UcmVlIChvWE1MUGFyZW50KSB7XG4gIHZhciBwYXJzZVRleHQgPSB4bWwucGFyc2VUZXh0O1xuXG4gIC8vVGhlIGRvY3VtZW50IG9iamVjdCBpcyBhbiBlc3BlY2lhbCBvYmplY3QgdGhhdCBpdCBtYXkgbWlzcyBzb21lIGZ1bmN0aW9ucyBvciBhdHRycyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIuXG4gIC8vVG8gcHJldmVudCB0aGlzIHByb2JsZW0gd2l0aCBjcmVhdGUgdGhlIEpYT05UcmVlIHVzaW5nIHRoZSByb290IGNoaWxkTm9kZSB3aGljaCBpcyBhIGZ1bGx5IGZsZXNoZWQgbm9kZSBvbiBhbGwgc3VwcG9ydGVkXG4gIC8vYnJvd3NlcnMuXG4gIGlmKG9YTUxQYXJlbnQuZG9jdW1lbnRFbGVtZW50KXtcbiAgICByZXR1cm4gbmV3IHhtbC5KWE9OVHJlZShvWE1MUGFyZW50LmRvY3VtZW50RWxlbWVudCk7XG4gIH1cblxuICBpZiAob1hNTFBhcmVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICB2YXIgc0NvbGxlY3RlZFR4dCA9IFwiXCI7XG4gICAgZm9yICh2YXIgb05vZGUsIHNQcm9wLCB2Q29udGVudCwgbkl0ZW0gPSAwOyBuSXRlbSA8IG9YTUxQYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGg7IG5JdGVtKyspIHtcbiAgICAgIG9Ob2RlID0gb1hNTFBhcmVudC5jaGlsZE5vZGVzLml0ZW0obkl0ZW0pO1xuICAgICAgLypqc2hpbnQgYml0d2lzZTogZmFsc2UqL1xuICAgICAgaWYgKChvTm9kZS5ub2RlVHlwZSAtIDEgfCAxKSA9PT0gMykgeyBzQ29sbGVjdGVkVHh0ICs9IG9Ob2RlLm5vZGVUeXBlID09PSAzID8gb05vZGUubm9kZVZhbHVlLnRyaW0oKSA6IG9Ob2RlLm5vZGVWYWx1ZTsgfVxuICAgICAgZWxzZSBpZiAob05vZGUubm9kZVR5cGUgPT09IDEgJiYgIW9Ob2RlLnByZWZpeCkge1xuICAgICAgICBzUHJvcCA9IHV0aWxpdGllcy5kZWNhcGl0YWxpemUob05vZGUubm9kZU5hbWUpO1xuICAgICAgICB2Q29udGVudCA9IG5ldyB4bWwuSlhPTlRyZWUob05vZGUpO1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShzUHJvcCkpIHtcbiAgICAgICAgICBpZiAodGhpc1tzUHJvcF0uY29uc3RydWN0b3IgIT09IEFycmF5KSB7IHRoaXNbc1Byb3BdID0gW3RoaXNbc1Byb3BdXTsgfVxuICAgICAgICAgIHRoaXNbc1Byb3BdLnB1c2godkNvbnRlbnQpO1xuICAgICAgICB9IGVsc2UgeyB0aGlzW3NQcm9wXSA9IHZDb250ZW50OyB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzQ29sbGVjdGVkVHh0KSB7IHRoaXMua2V5VmFsdWUgPSBwYXJzZVRleHQoc0NvbGxlY3RlZFR4dCk7IH1cbiAgfVxuXG4gIC8vSUU4IFN0dXBpZCBmaXhcbiAgdmFyIGhhc0F0dHIgPSB0eXBlb2Ygb1hNTFBhcmVudC5oYXNBdHRyaWJ1dGVzID09PSAndW5kZWZpbmVkJz8gb1hNTFBhcmVudC5hdHRyaWJ1dGVzLmxlbmd0aCA+IDA6IG9YTUxQYXJlbnQuaGFzQXR0cmlidXRlcygpO1xuICBpZiAoaGFzQXR0cikge1xuICAgIHZhciBvQXR0cmliO1xuICAgIGZvciAodmFyIG5BdHRyaWIgPSAwOyBuQXR0cmliIDwgb1hNTFBhcmVudC5hdHRyaWJ1dGVzLmxlbmd0aDsgbkF0dHJpYisrKSB7XG4gICAgICBvQXR0cmliID0gb1hNTFBhcmVudC5hdHRyaWJ1dGVzLml0ZW0obkF0dHJpYik7XG4gICAgICB0aGlzW1wiQFwiICsgdXRpbGl0aWVzLmRlY2FwaXRhbGl6ZShvQXR0cmliLm5hbWUpXSA9IHBhcnNlVGV4dChvQXR0cmliLnZhbHVlLnRyaW0oKSk7XG4gICAgfVxuICB9XG59O1xuXG54bWwuSlhPTlRyZWUucHJvdG90eXBlLmF0dHIgPSBmdW5jdGlvbihhdHRyKSB7XG4gIHJldHVybiB0aGlzWydAJyArIHV0aWxpdGllcy5kZWNhcGl0YWxpemUoYXR0cildO1xufTtcblxueG1sLnRvSlhPTlRyZWUgPSBmdW5jdGlvbiB0b0pYT05UcmVlKHhtbFN0cmluZyl7XG4gIHZhciB4bWxEb2MgPSB4bWwuc3RyVG9YTUxEb2MoeG1sU3RyaW5nKTtcbiAgcmV0dXJuIG5ldyB4bWwuSlhPTlRyZWUoeG1sRG9jKTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGV4dHJhY3QgdGhlIGtleXZhbHVlIG9mIGEgSlhPTlRyZWUgb2JqXG4gKlxuICogQHBhcmFtIHhtbE9iaiB7SlhPTlRyZWV9XG4gKiByZXR1cm4gdGhlIGtleSB2YWx1ZSBvciB1bmRlZmluZWQ7XG4gKi9cbnhtbC5rZXlWYWx1ZSA9IGZ1bmN0aW9uIGdldEtleVZhbHVlKHhtbE9iaikge1xuICBpZih4bWxPYmope1xuICAgIHJldHVybiB4bWxPYmoua2V5VmFsdWU7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbnhtbC5hdHRyID0gZnVuY3Rpb24gZ2V0QXR0clZhbHVlKHhtbE9iaiwgYXR0cikge1xuICBpZih4bWxPYmopIHtcbiAgICByZXR1cm4geG1sT2JqWydAJyArIHV0aWxpdGllcy5kZWNhcGl0YWxpemUoYXR0cildO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG54bWwuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlWE1MKHN0cikge1xuICBpZiAoIXV0aWxpdGllcy5pc1N0cmluZyhzdHIpKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIHJldHVybiBzdHIucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgIC5yZXBsYWNlKC8nL2csICcmYXBvczsnKTtcbn07XG5cbnhtbC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGVYTUwoc3RyKSB7XG4gIGlmICghdXRpbGl0aWVzLmlzU3RyaW5nKHN0cikpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mYXBvczsvZywgXCInXCIpXG4gICAgLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKVxuICAgIC5yZXBsYWNlKC8mZ3Q7L2csICc+JylcbiAgICAucmVwbGFjZSgvJmx0Oy9nLCAnPCcpXG4gICAgLnJlcGxhY2UoLyZhbXA7L2csICcmJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHhtbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy9AZXhjbHVkZVxudmFyIHZpZGVvanMgPSB3aW5kb3cudmlkZW9qcyB8fCB7XG5cdGdldENvbXBvbmVudCA6IGZ1bmN0aW9uKCkge30sXG5cdGV4dGVuZCA6IGZ1bmN0aW9uKCkge30sXG5cdHJlZ2lzdGVyQ29tcG9uZW50IDogZnVuY3Rpb24oKSB7fSxcblx0cmVnaXN0ZXJQbHVnaW4gOiBmdW5jdGlvbigpIHt9XG59O1xuLy8gQGVuZGV4Y2x1ZGVcblxud2luZG93Ll9tb2xTZXR0aW5ncyA9IG51bGw7XG5cbnJlcXVpcmUoJy4vcGx1Z2luL2NvbXBvbmVudHMvYWRzLWxhYmVsXzUnKTtcbnJlcXVpcmUoJy4vcGx1Z2luL2NvbXBvbmVudHMvYmxhY2stcG9zdGVyXzUnKTtcblxuY29uc29sZS5sb2coJ0N1c3RvbSBNYWlsT25saW5lIHBsdWdpbiB2ZXJzaW9uIDEuMi42Jyk7XG5cbnZhciB2aWRlb0pzVkFTVCA9IHJlcXVpcmUoJy4vcGx1Z2luL3ZpZGVvanMudmFzdC52cGFpZCcpO1xuXG5pZiAodmlkZW9qcy5yZWdpc3RlclBsdWdpbikge1xuXHR2aWRlb2pzLnJlZ2lzdGVyUGx1Z2luKCd2YXN0Q2xpZW50JywgdmlkZW9Kc1ZBU1QpO1xufVxuZWxzZSB7XG5cdHZpZGVvanMucGx1Z2luKCd2YXN0Q2xpZW50JywgdmlkZW9Kc1ZBU1QpO1xufVxuIl19


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	var _prefix = "apnVmapVast->userSync";
	var _logger = __webpack_require__(3);
	var debug = function (message) {
	   _logger.log(_prefix, message);
	};

	var UserSync = function() {
	    debug("initiated");
	    this.isComplete = false;

	    this.run = function(options) {
	        debug("start UserSync");
	        try {
	            if (this.isComplete) {
	                debug("stop UserSync because it's already done");
	            } else {
	                var targetElement = options.userSyncTargetElement;
	                if (options && options.usersync_url && typeof(options.usersync_url) === "string" && options.usersync_url !== "") {
	                    this.executeUserSync(options, targetElement);
	                    this.isComplete = true;
	                    debug("done");
	                } else {
	                    debug("stop UserSync because it needs proper options.usersync_url");
	                }
	            }
	        } catch (ex) {
	            debug("error: " + ex);
	        }

	    };

	    this.executeUserSync = function(options, targetElement) {
	        if (targetElement.ownerDocument && targetElement.ownerDocument.getElementById("apn_user_sync")) {
	            debug("stop UserSync because it's already done");
	        }
	        else {
		        debug("decode UserSync url");
		        var userSyncUrl = decodeURIComponent(options.usersync_url);
		        this.prepareIframeAndScript(userSyncUrl, targetElement);
	        }
	    };

	    this.prepareIframeAndScript = function(userSyncUrl, targetElement) {
	        debug("prepareIframeAndScript: " + userSyncUrl);

	        var iframe = document.createElement('iframe');
	        iframe.id = "apn_user_sync";

	        iframe.src = userSyncUrl;
	        iframe.width = "1";
	        iframe.height = "1";
	        iframe.frameborder = "0";
	        iframe.scrolling = "no";
	        iframe.marginheight = "0";
	        iframe.marginwidth = "0";
	        iframe.topmargin = "0";
	        iframe.leftmargin = "0";
	        iframe.style.position = "absolute";
	        iframe.style.overflow = "hidden";
	        iframe.style.clip = "rect(0 0 0 0)";
	        iframe.style.height = "1px";
	        iframe.style.width = "1px";
	        iframe.style.margin = "-1px";
	        iframe.style.padding = "0";
	        iframe.style.border = "0";

	        //iframe.style.display = "none";
	        targetElement.appendChild(iframe);

	        debug("UserSync iframe injected into target element: " + targetElement.id);
	    };
	};

	//singleton because this should be executed only onetime in life of adunits
	var UserSyncSingleton = (function () {
	    var instance;

	    var createInstance = function() {
	        var object = new UserSync();
	        return object;
	    };

	    return {
	        "sharedInstance": function () {
	            if (!instance) {
	                instance = createInstance();
	            }
	            return instance;
	        }
	    };
	})();

	module.exports = UserSyncSingleton;



/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	var _logger = __webpack_require__(3);
	var _ImpbusCommunicator = __webpack_require__(17);
	try {
		var _molPlugin = __webpack_require__(33);	
	}
	catch(e) {}
	var _MarkersHandler = __webpack_require__(2);
	var _uaParser = __webpack_require__(9);
	var _UserSync = __webpack_require__(34);
	var _Utils = __webpack_require__(16);

	var _prefix = 'apnVmapVast->vastArrayManager';

	var vastArrayManager = function () {
		var _ua = _uaParser();
		var _player;
		var _options;
		var _adPlaying = false;
		var _defaultAdCancelTimeout = 3000;	
	    var _savedMarkers;
		var _markersHandler;
		var _markersReady = false;
	    var _contentDuration = 0;
	    var _adIndicator;
	    var _userSyncUrl;
		var _mobilePrerollNeedClick = false;
		
		var _cover = document.getElementById('apn-break-cover');

		var _adArray = [];
		var _timeMarkers = {};
		var _currentAdIdx;
		var _preparationDone = false;
		var _prerollNeedClickToPlay = false;
		var _impbusCommunicator = new _ImpbusCommunicator();

		var _playlist = [];
		var _playlistIdx = -1;
		var _nextPlaylistItemFired = false;
		var _lastAd = false;
		var _lastTimeOfNextListItemEvent = 0;
		var _curXmlIdx = -1;
		var _xmls = [];

		var _isMobile = _ua.device.type || _ua.device.model;
		var _isIos = _ua.os.name.toLowerCase() === 'ios';
		var _isIPhone = _isMobile && _ua.device.model.toLowerCase() === 'iphone';
		var _isIE = _ua.browser.name === 'IE';
	    
		function showCover(show) {
			_logger.log(_prefix, (show ? "Show" : "Hide") + " ad cover with spinner");
			if (show) {
	    		_cover.style.display = 'block';
	     		_player.el().classList.add('vjs-waiting');
			}
			else {
	    		_cover.style.display = 'none';
	    		_player.el().classList.remove('vjs-waiting');
			}
		}
		
		function resetContent() {
			setTimeout(function() {
				_adPlaying = false;
				if (_savedMarkers) {
			    	_player.markers.reset(JSON.parse(_savedMarkers));
				}
			}, 1000);
			_adIndicator.style.display = 'none';
			showCover(false);
			removeListeners();
			_Utils.showNextOverlay(true);
			_nextPlaylistItemFired = false;
			if (_lastAd) {
				_player.one('ended', function() {
					setTimeout(function() {
						if (!_nextPlaylistItemFired) {
							_logger.log(_prefix, "Go to next video in playlist");
							_player.playlist.next();
						}
					}, 1000);
				});
			}
		}
		
		function needPlayAdForPlaylistItem(plIdx) {
			if (_options.frequencyRules && _options.frequencyRules.playlistClips && _options.frequencyRules.playlistClips > 1) {
				var mod = plIdx % _options.frequencyRules.playlistClips;
				return mod === 0;
			}
			return true;
		}

		function nextListItemHandler() {
			_nextPlaylistItemFired = true;
			if (Date.now() - _lastTimeOfNextListItemEvent < 500) {
				// ignore repeated event
				return;
			}
			showCover(true);
			_lastTimeOfNextListItemEvent = Date.now();
			_playlistIdx++;
			if (_markersHandler && _player.markers && _player.markers.destroy) {
				_player.markers.destroy();
			}
			// _contentDuration = _player.duration() > 0 ? (parseInt(_player.duration()) - 0.5) : 0;
		
			if (needPlayAdForPlaylistItem(_player.playlist.currentIndex())) {
				// reset internal variables
				_options.apnTagParams = [];
				_adArray.forEach(function(val) {
					_options.apnTagParams.push({params: val.apnParams, timeOffset: val.timeOffset});
				});
				_adArray = [];
				_adPlaying = false;
				_savedMarkers = null;
				_markersReady = false;
				_timeMarkers = {};
				_currentAdIdx = undefined;
				_preparationDone = false;

				_logger.log(_prefix, "Start waiting metadata for next video in playlist");
				_player.one("loadedmetadata",prepareAdArray);
			}
			else {
				showCover(false);
				_player.playlist.autoadvance(0);
			}
		}

		function setPlaybackMethodData() {
			if (!_options) {
				return;
			}
			var initPlayback = "auto";
	    	if (_player.currentTime() === 0) {
	    		initPlayback = _player.autoplay() ? 'auto' : 'click';
	    	}
			var initAudio = _player.muted() ? 'off' : 'on';
			_options.initialPlayback = initPlayback;
			_options.initialAudio = initAudio;
		}
		
		function traceMessage(event) {
			_logger.log(_prefix, 'trace event message: ' + event.data.message);
			if (_options.pageNotificationCallback) {
				_options.pageNotificationCallback('message', event.data.message);
			}
		}
		
		function traceEvent(event) {
			_logger.log(_prefix, 'trace event: ' + event.data.event);
			if (_options.pageNotificationCallback) {
				_options.pageNotificationCallback('event', event.data.event);
			}
		}
		
	    function addListeners() {
	    	_player.one('vast.adStart', function() {
	      	  	_adIndicator.style.display = 'block';
	    		_adPlaying = true;
	    		if (_userSyncUrl) {
	    			_UserSync.sharedInstance().run({userSyncTargetElement: _player.el_, usersync_url: _userSyncUrl});
	    		}
				showCover(false);
			});
	    	
	    	_player.on('vast.adError', resetContent);    	
	    	_player.on('vast.adsCancel', resetContent);    	
	    	_player.on('vast.adSkip', resetContent);    	
	    	_player.on('vast.reset', resetContent);    	
	    	_player.on('vast.contentEnd', resetContent);
	    	_player.on('adFinished', resetContent);

	    	_player.on('trace.message', traceMessage);
	    	_player.on('trace.event', traceEvent);
	    }
	    
	    function removeListeners() {
	    	_player.off('vast.adError', resetContent);    	
	    	_player.off('vast.adsCancel', resetContent);    	
	    	_player.off('vast.adSkip', resetContent);    	
	    	_player.off('vast.reset', resetContent);    	
	    	_player.off('vast.contentEnd', resetContent);
	    	_player.off('adFinished', resetContent);

	    	_player.off('trace.message', traceMessage);
	    	_player.off('trace.event', traceEvent);
	    }

		function playAd(xml) {
			if (_adPlaying) {
				// not interrupt playing ad
				return;
			}
			removeListeners();
			setPlaybackMethodData();
			var needPauseAndPlay = !_isMobile || !_player.paused();
			if (needPauseAndPlay) {
				_player.pause();
			}
			_adPlaying = true;
			if (_markersHandler) {
				_savedMarkers = JSON.stringify(_player.markers.getMarkers());
				_player.markers.removeAll();
			}
			var clientParams = {
				verbosity: 5,	// for debugging only
				// VAST xml
				adTagXML: function(callback) { 
					setTimeout(function() {
						callback(null, xml);
					}, 0);
				},
				playAdAlways: false,
				//Note: As requested we set the ad timeout at the same place than the adsCancelTimeout
				adCancelTimeout: (_options && _options.timeouts && _options.timeouts.adStartTimeout) ? _options.timeouts.adStartTimeout : _defaultAdCancelTimeout,
				adsEnabled: true,
				initialPlayback: _options.initialPlayback,
				initialAudio: _options.initialAudio
			};
			if (_options && _options.skippable && _options.skippable.skipText) {
				clientParams.skipText = _options.skippable.skipText;
			}
			if (_options && _options.skippable && _options.skippable.skipButtonText) {
				clientParams.skipButtonText = _options.skippable.skipButtonText;
			}
			if (_options && _options.viewability) {
				_options.viewability.contextId = 'anoutstream';
				//_options.viewability.contextId = 'anbrighcoveplugin';
				clientParams.viewability = _options.viewability;
			}
			if (_options && _options.clickThruEnabled === false) {
				clientParams.disableClickThru = true;
			}
			if (_options && _options.skippable && _options.skippable.hasOwnProperty('enabled')) {
				clientParams.skippable = {};
				clientParams.skippable.enabled = _options.skippable.enabled;
				clientParams.skippable.videoThreshold = _options.skippable.videoThreshold * 1000;
				clientParams.skippable.videoOffset = _options.skippable.videoOffset * 1000;
			}
			if (_options && _options.wrapperLimit &&  _options.wrapperLimit > 0) {
				clientParams.wrapperLimit = _options.wrapperLimit;
			}
				
			addListeners();
			_player.vastClient(clientParams);
			if (_options.initialPlayback !== 'click' || _mobilePrerollNeedClick) {
				if (!_prerollNeedClickToPlay) {
					setTimeout(function() {
						_player.play();
					}, 0);
				}
			}
			_Utils.showNextOverlay(false);
		}

		function getXmlByTime(time) {
			for (var i = 0; i < _adArray.length; i++) {
				if (!_lastAd && i === (_adArray.length - 1)) {
					_lastAd = true;
				}
				if (_adArray[i].time === time) {
					if (!_adArray[i].played) {
						//traceMessage({data: {message: '_lastAd = ' + _lastAd}});
						_adArray[i].played = true;
						return _adArray[i].xml;
					}
					return null;
				}
			}
			return null;
		}

		function startAd(time) {
			_logger.log(_prefix, 'Try to play ad at time = ' + time);
			var xml = getXmlByTime(time);
			if (xml) {
				_logger.log(_prefix, 'VAST xml selected for time: ' + time);
				showCover(true);
				_mobilePrerollNeedClick = _isMobile && time === 0;
				if (_mobilePrerollNeedClick && _player.playlist && typeof _player.playlist === 'function') {
					if (_player.playlist.currentIndex() > 0) {
						_mobilePrerollNeedClick = false;
					}
				}
				if (_mobilePrerollNeedClick) {
					showCover(false);
					_player.bigPlayButton.el_.style.opacity = 1;
					if (_isIos) {
						// iOS
						if (_isIPhone) {
							// iPhone
							_player.one('play', function() {
								playAd(xml);
							});
						}
						else {
							// iPad
							_player.pause();
							_player.bigPlayButton.el_.style.display = 'block';
							_player.bigPlayButton.el_.style.opacity = 1;
							_player.one('play', function() {
								playAd(xml);
							});	
						}
					}
					else {
						// android
						_player.one('play', function() {
							playAd(xml);
						});
					}
				}
				else {
					_prerollNeedClickToPlay = false;
					if (time === 0 && _player.paused()) {
						_prerollNeedClickToPlay = true;
						_player.bigPlayButton.el_.style.display = 'block';
						_player.bigPlayButton.el_.style.opacity = 1;
					}
					playAd(xml);
				}
			}
			else {
				_logger.log(_prefix, 'VAST xml selected for time: ' + time + ' is invalid: ' + xml);
				showCover(false);
				if (time === 0 && _player.paused()) {
					_player.bigPlayButton.el_.style.display = 'block';
					_player.bigPlayButton.el_.style.opacity = 1;
					_player.one('play', function() {
						_player.bigPlayButton.el_.style.display = 'none';
					});	
				}
			}
		}

		function prepareXmlsForNextPlaylistItem() {
			_options.apnTagParams = _adArray[_curXmlIdx].apnParams;
			_impbusCommunicator.getXML(_options, _player, function(xml, errorCode, errorMessage) {
				if (errorCode) {
					_logger.error(_prefix, 'Error to get VAST xml for next playlist item. Erorr code: ' + errorCode + ". Error message: " + errorMessage);
					_xmls.push({xml: null, timeOffset: _adArray[_curXmlIdx].timeOffset});
				}
				else {
					_xmls.push({xml: xml, timeOffset: _adArray[_curXmlIdx].timeOffset});
				}
				_curXmlIdx++;
				if (_curXmlIdx < _adArray.length) {
					prepareXmlsForNextPlaylistItem();
				}
			});
		}

		function prepareNextAvailableXml() {
			var hasValidXml = false;
			if (_xmls.length > 0) {
				for (var i = 0; i < _adArray.length; i++) {
					var xmlEl = null;
					for (var j = 0; j < _xmls.length; j++) {
						if (_xmls[j].timeOffset === _adArray[i].timeOffset) {
							xmlEl = _xmls[j];
							break;
						}
					}
					if (xmlEl) {
						_adArray[i].xml = xmlEl.xml;
						if (!hasValidXml && _adArray[i].xml) {
							hasValidXml = true;
						}	
					}
				}
				_xmls = [];
				_preparationDone = true;
				if (_options.playerSettings.autostart) {
					_player.play();
				}
				if (hasValidXml && _markersHandler && !_markersReady) {
					_markersReady = true;
					_markersHandler.markers(_timeMarkers);
				}
				setTimeout(function() {
					_player.on('playlistitem', nextListItemHandler);
					if (_playlist.length > 1) {
						_player.playlist.autoadvance(hasValidXml ? null : 0);
					}
					if (_playlist.length > 1 && _player.playlist.currentIndex() < _playlist.length - 1) {
						_curXmlIdx = 0;
						prepareXmlsForNextPlaylistItem();
					}
				}, 1000);
			}
			else {
				_options.apnTagParams = _adArray[_currentAdIdx].apnParams;
				_impbusCommunicator.getXML(_options, _player, function(xml, errorCode, errorMessage) {
					if (_currentAdIdx >= _adArray.length) {
						return;
					}
					if (errorCode) {
						_logger.error(_prefix, 'Error to get VAST xml. Erorr code: ' + errorCode + ". Error message: " + errorMessage);
						_adArray[_currentAdIdx].xml = null;
					}
					else {
						hasValidXml = true;
						_adArray[_currentAdIdx].xml = xml;
						if (!_isMobile) {
							_preparationDone = true;
							if (_markersHandler && !_markersReady) {
								_markersReady = true;
								_markersHandler.markers(_timeMarkers);
							}
						}
					}
					_currentAdIdx++;
					if (_currentAdIdx < _adArray.length) {
						prepareNextAvailableXml();
					}
					else {
						_preparationDone = true;
						if (!_adPlaying) {
							showCover(false);
						}
						if (_options.playerSettings.autostart) {
							if (_isMobile) {
								if (_markersHandler && !_markersReady) {
									_markersReady = true;
									_markersHandler.markers(_timeMarkers);
								}
								_player.bigPlayButton.el_.style.display = 'block';
								_player.bigPlayButton.el_.style.opacity = 1;
								_player.one('play', function() {
									_player.bigPlayButton.el_.style.display = 'none';
								});	
							}
							_player.play();
						}
						setTimeout(function() {
							_player.on('playlistitem', nextListItemHandler);
							if (_playlist.length > 1) {
								_player.playlist.autoadvance(hasValidXml ? null : 0);
							}
							if (_playlist.length > 1 && _player.playlist.currentIndex() < _playlist.length - 1) {
								_curXmlIdx = 0;
								prepareXmlsForNextPlaylistItem();
							}
						}, 1000);
					}
				});
			}
		}
		
		function prepareAdArray() {
			_logger.log(_prefix, "Start preparing ad array (may called on loadmetadata event)");
			_lastAd = false;
			_preparationDone = false;
			_playlist = (_player.playlist && typeof _player.playlist === 'function') ? _player.playlist() : [];
			showCover(true);
			_timeMarkers = {
				markerStyle: {
					'width': '5px',
					'border-radius': '10%',
					'background-color': 'white'
				},
				markerTip: {
					display: false
				},
				onMarkerReached: function(marker) {
					startAd(marker.time);
				},
				markers: [],
				metadataLoaded: true
			};
			_player.off("loadedmetadata",prepareAdArray);
			var i;
			// get cue points data
			var cpTime = [];
			var textTracks = _player.textTracks()[0];
			if (textTracks.cues_ && textTracks.cues_.length > 0){
				for (i = 0; i < textTracks.cues_.length; i++) {
					var time = textTracks.cues_[i].startTime;
					cpTime.push(time);
				}
			}
			//_contentDuration = parseInt(_player.duration()) - 0.5;
			var hasPreroll = false;
			_contentDuration = _player.duration();
			for (i = 0; i < _options.apnTagParams.length; i++) {
				var seconds = _Utils.convertStringToSeconds(_options.apnTagParams[i].timeOffset, _contentDuration);
				if (seconds !== null && seconds <= _contentDuration) {
					var adObj = {time: seconds, played: false, apnParams: _options.apnTagParams[i].params,
						timeOffset: _options.apnTagParams[i].timeOffset};
					if (seconds < 0) {
						// cue point
						// get time from cue points data
						var idx = (-seconds) - 1;
						if (idx < cpTime.length) {
							seconds = cpTime[idx];
						}
					}
					if (seconds >= 0 && seconds <= _contentDuration) {
						if (seconds === _contentDuration) {
							seconds = parseInt(_contentDuration + 0.5);
						}
						_timeMarkers.markers.push({time: seconds});
						adObj.time = seconds;
						_adArray.push(adObj);
						if (seconds < 1) {
							hasPreroll = true;
						}
					}
				}
			}
			_adArray.sort(function(first, second) {
				return first.time - second.time;
			});

			if (_timeMarkers.markers.length > 0) {
				// initialize markers for all ads
				if (!_markersHandler) {
					_markersHandler = new _MarkersHandler(videojs);
				}
				_markersHandler.init(_player);
				//_markersHandler.markers(_timeMarkers);

				if (!hasPreroll) {
					showCover(false);
				}

				_currentAdIdx = 0;
				_options.apnTagParams = _adArray[_currentAdIdx].apnParams;
				prepareNextAvailableXml();
			}
			else {
				showCover(false);
			}
		}
	    
		this.play = function (vjsPlayer, options) {
	    	_player = vjsPlayer;
			_options = options;

	    	// get player autostart and audio settings
	    	_options.playerSettings = {};
	    	_options.playerSettings.autostart = _player.currentTime() === 0 ? _player.autoplay() : !_player.paused();
	    	_options.playerSettings.muted = _player.muted();
	    	
			// initialize graphics 
			_cover = document.createElement('div');
			_cover.id = 'apn-break-cover';
			_cover.style.width = '100%';
			_cover.style.height = '100%';
			_cover.style.backgroundColor = 'black';
			_cover.style.position = 'absolute';
			_cover.style.zIndex = 101;
			_player.el().appendChild(_cover);
			_cover.style.display = 'none';

			_adIndicator = document.createElement('p');
			_adIndicator.className = 'vjs-overlay';
			_adIndicator.innerHTML = _options.adText ? _options.adText : "Ad";
			_adIndicator.style.display = 'none';
			_adIndicator.style.left = '10px';
			_player.el().appendChild(_adIndicator);
			
		    _contentDuration = _player.duration() > 0 ? (parseInt(_player.duration()) - 0.5) : 0;
			
			_player.bigPlayButton.el_.style.opacity = 1;
	    	if (!_ua.device.type && !_ua.device.model && _options.playerSettings.autostart) {
				// hide big play button for desktop
				_player.bigPlayButton.el_.style.display = 'none';
			}
			if (_contentDuration) {
	    		// main content passible playing
	    		_player.pause();
				prepareAdArray();
			}
			else {
				showCover(true);
	    		if (_ua.device.type || _ua.device.model) {
					// mobile
					_options.playerSettings.autostart = true;
					_options.playerSettings.muted = _player.muted();
					if (_player.autoplay() === true) {
						_player.autoplay('any');
					}

					if (!_preparationDone) {
						_player.pause();
					}
					_player.one("loadedmetadata",prepareAdArray);
				}
				else {
					// desktop
					setTimeout(function() {
						if (!_isIE && _player.paused() && _player.bigPlayButton.el_.style.display !== 'block' && !_adPlaying) {
							showCover(false);
							_player.bigPlayButton.el_.style.display = 'block';
							_player.bigPlayButton.one('click', function() {
								_player.bigPlayButton.el_.style.display = 'none';
							});
						}	
					}, 1000);
					_player.one('playing', function() {
						if (_player.paused()) {
							showCover(false);
							_player.bigPlayButton.el_.style.display = 'block';
							_player.bigPlayButton.one('click', function() {
								_player.bigPlayButton.el_.style.display = 'none';
								prepareAdArray();
							});
						}
						else {
							_player.bigPlayButton.el_.style.display = 'none';
							prepareAdArray();
						}
						if (!_preparationDone) {
							_player.pause();
						}
					});
				}
			}
		};

	    this.stop = function() {
	    	if (_adPlaying) {
	    		_player.trigger('vast.adsCancel');
	    	}
			if (_markersHandler) {
	  	  		_player.markers.destroy();
			}
	    };

	};

	module.exports = vastArrayManager;


/***/ })
/******/ ]);
